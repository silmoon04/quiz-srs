{
  "name": "IN2002 Data Structures & Algorithms - Viva Preparation (Weeks 1-7)",
  "description": "A comprehensive, scenario-based practice module designed to cover complexity analysis, linear structures, trees, heaps, hashing, and graphs. Geared towards 'Sketch an Algorithm' viva questions.",
  "chapters": [
    {
      "id": "ch_complexity_1",
      "name": "Chapter 1: Complexity Analysis & Recursion",
      "description": "Mastering Big O, time vs space, and recursive cost analysis.",
      "questions": [
        {
          "questionId": "ch_complexity_1_q1",
          "questionText": "You are analyzing an algorithm with two nested loops. The outer loop runs $n$ times. The inner loop runs $i$ times, where $i$ is the current index of the outer loop (i.e., $1, 2, ..., n$). What is the **exact** Time Complexity?",
          "options": [
            { "optionId": "ch_complexity_1_q1_opt1", "optionText": "$O(n)$" },
            { "optionId": "ch_complexity_1_q1_opt2", "optionText": "$O(n \\log n)$" },
            { "optionId": "ch_complexity_1_q1_opt3", "optionText": "$O(n^2)$" },
            { "optionId": "ch_complexity_1_q1_opt4", "optionText": "$O(n^2 / 2)$" },
            { "optionId": "ch_complexity_1_q1_opt5", "optionText": "$O(n^3)$" },
            { "optionId": "ch_complexity_1_q1_opt6", "optionText": "$O(\\log n)$" }
          ],
          "correctOptionIds": ["ch_complexity_1_q1_opt3"],
          "explanationText": "The total number of steps is the sum of the integers from 1 to $n$, which is the arithmetic series: $$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2} = \\frac{n^2 + n}{2}$$. In Big O notation, we drop constants and lower-order terms, resulting in **$O(n^2)$**.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_complexity_1_q2",
          "questionText": "Consider the following recursive function for calculating Fibonacci: `fib(n) = fib(n-1) + fib(n-2)`. What is the **Space Complexity** of this specific implementation (without memoization)?",
          "options": [
            { "optionId": "ch_complexity_1_q2_opt1", "optionText": "$O(1)$" },
            { "optionId": "ch_complexity_1_q2_opt2", "optionText": "$O(n)$" },
            { "optionId": "ch_complexity_1_q2_opt3", "optionText": "$O(n^2)$" },
            { "optionId": "ch_complexity_1_q2_opt4", "optionText": "$O(2^n)$" },
            { "optionId": "ch_complexity_1_q2_opt5", "optionText": "$O(\\log n)$" }
          ],
          "correctOptionIds": ["ch_complexity_1_q2_opt2"],
          "explanationText": "While the *Time Complexity* is $O(2^n)$, the **Space Complexity** is determined by the maximum depth of the call stack (the height of the recursion tree). For `fib(n)`, the tree goes $n$ levels deep. Thus, space is **$O(n)$**.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_complexity_1_q3",
          "questionText": "You perform a **Binary Search** on a sorted array of size $N$. Which of the following best describes the recurrence relation for its time complexity?",
          "options": [
            { "optionId": "ch_complexity_1_q3_opt1", "optionText": "$T(N) = T(N-1) + O(1)$" },
            { "optionId": "ch_complexity_1_q3_opt2", "optionText": "$T(N) = T(N/2) + O(1)$" },
            { "optionId": "ch_complexity_1_q3_opt3", "optionText": "$T(N) = 2T(N/2) + O(N)$" },
            { "optionId": "ch_complexity_1_q3_opt4", "optionText": "$T(N) = T(N/2) + O(N)$" },
            { "optionId": "ch_complexity_1_q3_opt5", "optionText": "$T(N) = 2T(N/2) + O(1)$" }
          ],
          "correctOptionIds": ["ch_complexity_1_q3_opt2"],
          "explanationText": "Binary search divides the problem size in half ($N/2$) and performs a constant amount of work (comparison) at each step ($O(1)$). This yields **$T(N) = T(N/2) + O(1)$**, which solves to $O(\\log N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 3,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_linear_2",
      "name": "Chapter 2: Linear Data Structures",
      "description": "Manipulation of Arrays, Linked Lists, Stacks, and Queues.",
      "questions": [
        {
          "questionId": "ch_linear_2_q1",
          "questionText": "You are asked to **swap the first two nodes** of a Singly Linked List (`head` and `head.next`). Which sequence of pointer operations is correct? (Assume `temp = head.next`)",
          "options": [
            {
              "optionId": "ch_linear_2_q1_opt1",
              "optionText": "`head = temp`; `head.next = temp.next`; `temp.next = head`;"
            },
            {
              "optionId": "ch_linear_2_q1_opt2",
              "optionText": "`head.next = temp.next`; `temp.next = head`; `head = temp`;"
            },
            {
              "optionId": "ch_linear_2_q1_opt3",
              "optionText": "`temp.next = head`; `head.next = temp.next`; `head = temp`;"
            },
            {
              "optionId": "ch_linear_2_q1_opt4",
              "optionText": "`head.next = temp`; `temp.next = head.next`; `head = temp`;"
            }
          ],
          "correctOptionIds": ["ch_linear_2_q1_opt2"],
          "explanationText": "1. `head.next = temp.next` (The old 1st node must point to the 3rd node).\n2. `temp.next = head` (The old 2nd node must point to the old 1st node).\n3. `head = temp` (Update the head pointer to start at the new 1st node).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_linear_2_q2",
          "questionText": "You need to **reverse a Queue** using only the basic ADT operations of a Stack and Queue. Which algorithm is correct?",
          "options": [
            {
              "optionId": "ch_linear_2_q2_opt1",
              "optionText": "Dequeue all items into a Stack, then Pop all items back into the Queue."
            },
            {
              "optionId": "ch_linear_2_q2_opt2",
              "optionText": "Dequeue all items into a Stack, then Peek the Stack and Enqueue."
            },
            {
              "optionId": "ch_linear_2_q2_opt3",
              "optionText": "Dequeue all items into a second Queue, then Enqueue them back."
            },
            {
              "optionId": "ch_linear_2_q2_opt4",
              "optionText": "Swap the Front and Rear pointers of the Queue."
            },
            {
              "optionId": "ch_linear_2_q2_opt5",
              "optionText": "Use recursion to hold the Dequeued items in the stack frame, then Enqueue them."
            }
          ],
          "correctOptionIds": ["ch_linear_2_q2_opt1", "ch_linear_2_q2_opt5"],
          "explanationText": "Because a Stack is LIFO (Last-In, First-Out), pushing elements into it and then popping them out reverses their order. Using recursion (Option 5) essentially utilizes the call stack to achieve the same result.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_linear_2_q3",
          "questionText": "You are given a **Circular Singly Linked List** and asked to convert it to a **Doubly Linked List**. What is the critical first step before iterating to add `prev` pointers?",
          "options": [
            {
              "optionId": "ch_linear_2_q3_opt1",
              "optionText": "Traverse to find the tail and set `tail.next = null` to break the cycle."
            },
            { "optionId": "ch_linear_2_q3_opt2", "optionText": "Create a new dummy head node." },
            { "optionId": "ch_linear_2_q3_opt3", "optionText": "Set `head.prev = head.next`." },
            { "optionId": "ch_linear_2_q3_opt4", "optionText": "Swap the head and tail pointers." }
          ],
          "correctOptionIds": ["ch_linear_2_q3_opt1"],
          "explanationText": "To treat it as a linear doubly linked list (or even a circular one where you don't loop infinitely during construction), you generally identify the boundary (tail) first. If the goal is a linear DLL, breaking the cycle `tail.next = null` is essential to prevent infinite loops during traversal.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_linear_2_q4",
          "questionText": "What is the **time complexity** of finding the middle element of a Singly Linked List in a single pass?",
          "options": [
            { "optionId": "ch_linear_2_q4_opt1", "optionText": "$O(n)$" },
            { "optionId": "ch_linear_2_q4_opt2", "optionText": "$O(n/2)$ which is $O(n)$" },
            { "optionId": "ch_linear_2_q4_opt3", "optionText": "$O(n^2)$" },
            { "optionId": "ch_linear_2_q4_opt4", "optionText": "$O(\\log n)$" },
            { "optionId": "ch_linear_2_q4_opt5", "optionText": "$O(1)$" }
          ],
          "correctOptionIds": ["ch_linear_2_q4_opt2"],
          "explanationText": "Using the 'Tortoise and Hare' method (two pointers, one moving 1 step, one moving 2 steps), you reach the middle when the fast pointer reaches the end. This touches $n/2$ nodes, which simplifies to **$O(n)$**.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_linear_2_q5",
          "questionText": "You are implementing a Queue using a **Circular Array** of size $N$. You have `front` and `count` variables. How do you calculate the index for `enqueue` (inserting at rear)?",
          "options": [
            { "optionId": "ch_linear_2_q5_opt1", "optionText": "`(front + count) % N`" },
            { "optionId": "ch_linear_2_q5_opt2", "optionText": "`(front + count)`" },
            { "optionId": "ch_linear_2_q5_opt3", "optionText": "`(front - 1) % N`" },
            { "optionId": "ch_linear_2_q5_opt4", "optionText": "`(count + 1) % N`" },
            { "optionId": "ch_linear_2_q5_opt5", "optionText": "`(front + count - 1) % N`" }
          ],
          "correctOptionIds": ["ch_linear_2_q5_opt1"],
          "explanationText": "The rear index is `count` positions away from `front`. The modulo operator `% N` handles the wrap-around case where the queue continues at index 0 after reaching index $N-1$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_hashing_3",
      "name": "Chapter 3: Hashing & Heaps",
      "description": "Hash tables, collision resolution, and Heap properties.",
      "questions": [
        {
          "questionId": "ch_hashing_3_q1",
          "questionText": "In a Hash Table using **Linear Probing**, what happens if you simply set a slot to `null` when deleting an item?",
          "options": [
            { "optionId": "ch_hashing_3_q1_opt1", "optionText": "It works perfectly." },
            {
              "optionId": "ch_hashing_3_q1_opt2",
              "optionText": "It breaks the probe chain, making subsequent items that collided unreachable."
            },
            {
              "optionId": "ch_hashing_3_q1_opt3",
              "optionText": "It causes the hash function to return different values."
            },
            { "optionId": "ch_hashing_3_q1_opt4", "optionText": "It increases the load factor." }
          ],
          "correctOptionIds": ["ch_hashing_3_q1_opt2"],
          "explanationText": "Linear probing relies on contiguous blocks of data to find items that collided. If you create a hole (`null`), a search for an item that was pushed further down the chain will stop at the hole and falsely return 'not found'. You must use a **tombstone** (lazy deletion) or rehash the cluster.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_hashing_3_q2",
          "questionText": "You are given a **Min-Heap** implemented as an array. The node at index `i` (0-indexed) has a parent at:",
          "options": [
            { "optionId": "ch_hashing_3_q2_opt1", "optionText": "`floor((i - 1) / 2)`" },
            { "optionId": "ch_hashing_3_q2_opt2", "optionText": "`i / 2`" },
            { "optionId": "ch_hashing_3_q2_opt3", "optionText": "`2*i + 1`" },
            { "optionId": "ch_hashing_3_q2_opt4", "optionText": "`2*i`" },
            { "optionId": "ch_hashing_3_q2_opt5", "optionText": "`floor(i / 2)`" }
          ],
          "correctOptionIds": ["ch_hashing_3_q2_opt1"],
          "explanationText": "For 0-indexed arrays:\n- Left Child: $2i + 1$\n- Right Child: $2i + 2$\n- Parent: $\\lfloor (i - 1) / 2 \\rfloor$",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_hashing_3_q3",
          "questionText": "You want to find the **Kth largest element** in an unsorted array of size $N$. What is the time complexity if you use a **Min-Heap of size K**?",
          "options": [
            { "optionId": "ch_hashing_3_q3_opt1", "optionText": "$O(N \\log N)$" },
            { "optionId": "ch_hashing_3_q3_opt2", "optionText": "$O(N \\log K)$" },
            { "optionId": "ch_hashing_3_q3_opt3", "optionText": "$O(K \\log N)$" },
            { "optionId": "ch_hashing_3_q3_opt4", "optionText": "$O(N + K)$" },
            { "optionId": "ch_hashing_3_q3_opt5", "optionText": "$O(N^2)$" }
          ],
          "correctOptionIds": ["ch_hashing_3_q3_opt2"],
          "explanationText": "You iterate through all $N$ elements. For each element, you insert it into the Min-Heap. If the heap size exceeds $K$, you remove the minimum (root). Insertion/Deletion in a heap of size $K$ takes $O(\\log K)$. Doing this $N$ times results in **$O(N \\log K)$**.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_hashing_3_q4",
          "questionText": "Which collision resolution strategy is most likely to suffer from **secondary clustering**?",
          "options": [
            { "optionId": "ch_hashing_3_q4_opt1", "optionText": "Separate Chaining" },
            { "optionId": "ch_hashing_3_q4_opt2", "optionText": "Linear Probing" },
            { "optionId": "ch_hashing_3_q4_opt3", "optionText": "Quadratic Probing" },
            { "optionId": "ch_hashing_3_q4_opt4", "optionText": "Double Hashing" }
          ],
          "correctOptionIds": ["ch_hashing_3_q4_opt3"],
          "explanationText": "**Quadratic Probing** eliminates primary clustering (long solid runs of keys) but suffers from secondary clustering: if two keys hash to the same initial slot, they follow the exact same probe sequence ($+1, +4, +9...$). Double Hashing solves this.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 4,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_trees_4",
      "name": "Chapter 4: Trees (BST & AVL)",
      "description": "Tree traversals, properties, and balancing rotations.",
      "questions": [
        {
          "questionId": "ch_trees_4_q1",
          "questionText": "In a Binary Search Tree (BST), which traversal method yields the nodes in **ascending sorted order**?",
          "options": [
            { "optionId": "ch_trees_4_q1_opt1", "optionText": "Pre-order Traversal" },
            { "optionId": "ch_trees_4_q1_opt2", "optionText": "In-order Traversal" },
            { "optionId": "ch_trees_4_q1_opt3", "optionText": "Post-order Traversal" },
            { "optionId": "ch_trees_4_q1_opt4", "optionText": "Level-order Traversal (BFS)" }
          ],
          "correctOptionIds": ["ch_trees_4_q1_opt2"],
          "explanationText": "**In-order** traversal visits Left Subtree $\\rightarrow$ Root $\\rightarrow$ Right Subtree. Since a BST is structured such that Left < Root < Right, this order naturally prints the values from smallest to largest.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_trees_4_q2",
          "questionText": "You insert nodes into an empty AVL tree in this order: `10, 20, 30`. What rotation occurs?",
          "options": [
            { "optionId": "ch_trees_4_q2_opt1", "optionText": "Right Rotation (LL case)" },
            { "optionId": "ch_trees_4_q2_opt2", "optionText": "Left Rotation (RR case)" },
            { "optionId": "ch_trees_4_q2_opt3", "optionText": "Left-Right Rotation (LR case)" },
            { "optionId": "ch_trees_4_q2_opt4", "optionText": "Right-Left Rotation (RL case)" },
            { "optionId": "ch_trees_4_q2_opt5", "optionText": "No rotation is needed." }
          ],
          "correctOptionIds": ["ch_trees_4_q2_opt2"],
          "explanationText": "The tree becomes skewed to the right: `10 -> 20 -> 30`. This is the Right-Right (RR) case. It requires a **Single Left Rotation** on the root (10) to make 20 the new root, balancing the tree.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_trees_4_q3",
          "questionText": "Sketching Algorithm: You need to calculate the **average value** of all keys in a Binary Tree. Which approach is best?",
          "options": [
            {
              "optionId": "ch_trees_4_q3_opt1",
              "optionText": "Traverse once to calculate Sum, traverse again to calculate Count, then divide."
            },
            {
              "optionId": "ch_trees_4_q3_opt2",
              "optionText": "Use a single traversal that returns an object/pair `{sum, count}` from each subtree."
            },
            {
              "optionId": "ch_trees_4_q3_opt3",
              "optionText": "Perform BFS to find the max value, DFS to find the min value, and average them."
            },
            {
              "optionId": "ch_trees_4_q3_opt4",
              "optionText": "Convert the tree to an array, sort the array, and find the median."
            }
          ],
          "correctOptionIds": ["ch_trees_4_q3_opt2"],
          "explanationText": "Option 2 is the most efficient ($O(n)$ time, single pass). Returning a pair `{sum, count}` allows the parent to calculate `totalSum = left.sum + right.sum + root.val` and `totalCount = left.count + right.count + 1` in one go.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_trees_4_q4",
          "questionText": "What is the worst-case time complexity for searching in a **non-balanced** Binary Search Tree?",
          "options": [
            { "optionId": "ch_trees_4_q4_opt1", "optionText": "$O(\\log n)$" },
            { "optionId": "ch_trees_4_q4_opt2", "optionText": "$O(n)$" },
            { "optionId": "ch_trees_4_q4_opt3", "optionText": "$O(n \\log n)$" },
            { "optionId": "ch_trees_4_q4_opt4", "optionText": "$O(1)$" }
          ],
          "correctOptionIds": ["ch_trees_4_q4_opt2"],
          "explanationText": "In the worst case (skewed tree, e.g., inserting 1, 2, 3, 4, 5 in order), the BST degenerates into a Linked List. Searching the leaf takes **$O(n)$**. Balanced trees (AVL) guarantee $O(\\log n)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 4,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_graphs_5",
      "name": "Chapter 5: Graphs & Algorithms",
      "description": "BFS, DFS, Matrix vs List, and scenario based problem solving.",
      "questions": [
        {
          "questionId": "ch_graphs_5_q1",
          "questionText": "You need to find the **shortest path** between two nodes in an **unweighted** graph. Which algorithm should you use?",
          "options": [
            { "optionId": "ch_graphs_5_q1_opt1", "optionText": "Depth-First Search (DFS)" },
            { "optionId": "ch_graphs_5_q1_opt2", "optionText": "Breadth-First Search (BFS)" },
            { "optionId": "ch_graphs_5_q1_opt3", "optionText": "Dijkstra's Algorithm" },
            { "optionId": "ch_graphs_5_q1_opt4", "optionText": "Prim's Algorithm" },
            { "optionId": "ch_graphs_5_q1_opt5", "optionText": "Topological Sort" }
          ],
          "correctOptionIds": ["ch_graphs_5_q1_opt2"],
          "explanationText": "**BFS** explores neighbors layer by layer (concentric circles). In an unweighted graph, the first time you reach the target node, you are guaranteed to have taken the path with the fewest edges.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_graphs_5_q2",
          "questionText": "What is the **Space Complexity** of representing a dense graph ($E \\approx V^2$) using an Adjacency Matrix?",
          "options": [
            { "optionId": "ch_graphs_5_q2_opt1", "optionText": "$O(V + E)$" },
            { "optionId": "ch_graphs_5_q2_opt2", "optionText": "$O(V^2)$" },
            { "optionId": "ch_graphs_5_q2_opt3", "optionText": "$O(E)$" },
            { "optionId": "ch_graphs_5_q2_opt4", "optionText": "$O(1)$" },
            { "optionId": "ch_graphs_5_q2_opt5", "optionText": "$O(V \\log V)$" }
          ],
          "correctOptionIds": ["ch_graphs_5_q2_opt2"],
          "explanationText": "An Adjacency Matrix requires a $V \\times V$ 2D array, regardless of the number of edges. Thus, space is always **$O(V^2)$**. This is efficient for dense graphs but wasteful for sparse graphs.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_graphs_5_q3",
          "questionText": "Scenario: You have a **Hash Table** of students and a **Stack** of student IDs. You want to check if every ID in the Stack exists in the Hash Table. What is the algorithm logic?",
          "options": [
            {
              "optionId": "ch_graphs_5_q3_opt1",
              "optionText": "Iterate the Hash Table keys; for each key, pop the Stack to check for a match."
            },
            {
              "optionId": "ch_graphs_5_q3_opt2",
              "optionText": "While Stack is not empty: `pop()` ID, `search()` ID in Hash Table. If not found, return False. Else continue."
            },
            {
              "optionId": "ch_graphs_5_q3_opt3",
              "optionText": "Convert the Stack to an Array, sort it, then binary search the Hash Table."
            },
            {
              "optionId": "ch_graphs_5_q3_opt4",
              "optionText": "Dump the Hash Table into a second Stack and compare the two Stacks."
            }
          ],
          "correctOptionIds": ["ch_graphs_5_q3_opt2"],
          "explanationText": "This is the most efficient $O(N)$ approach. You iterate the linear structure (Stack) and utilize the $O(1)$ lookup speed of the Hash Table for verification. If the loop completes without returning False, all items exist.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_graphs_5_q4",
          "questionText": "Which data structure is typically used to implement **Depth-First Search (DFS)** iteratively (without recursion)?",
          "options": [
            { "optionId": "ch_graphs_5_q4_opt1", "optionText": "Queue" },
            { "optionId": "ch_graphs_5_q4_opt2", "optionText": "Stack" },
            { "optionId": "ch_graphs_5_q4_opt3", "optionText": "Priority Queue" },
            { "optionId": "ch_graphs_5_q4_opt4", "optionText": "Hash Set" },
            { "optionId": "ch_graphs_5_q4_opt5", "optionText": "Linked List" }
          ],
          "correctOptionIds": ["ch_graphs_5_q4_opt2"],
          "explanationText": "DFS explores deep before wide. This LIFO (Last-In, First-Out) behavior corresponds to a **Stack**. (BFS uses a Queue for FIFO behavior).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 4,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}
