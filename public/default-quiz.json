{
  "name": "Advanced Data Structures & Algorithms Viva Prep",
  "description": "Top 50 'Archetype' questions covering complexity, pointer manipulation, and core ADT logic, designed for high-stakes spaced repetition.",
  "chapters": [
    {
      "id": "ch_viva_1",
      "name": "Core ADT Comparison and Transfer (Q1-Q10)",
      "questions": [
        {
          "questionId": "ch_viva_1_q1",
          "questionText": "Sketch an algorithm to check if a **Stack** and a **Queue** contain the exact same set of integer elements (order does not matter). You may use auxiliary data structures.",
          "options": [
            {
              "optionId": "ch_viva_1_q1_opt1",
              "optionText": "I will iterate through the stack using an index `i` from 0 to size..."
            },
            {
              "optionId": "ch_viva_1_q1_opt2",
              "optionText": "I will use two pointers, one at the top of the stack and one at the front of the queue, and compare them."
            },
            {
              "optionId": "ch_viva_1_q1_opt3",
              "optionText": "I will sort the Stack in place."
            },
            {
              "optionId": "ch_viva_1_q1_opt4",
              "optionText": "I will pop from the stack and dequeue from the queue simultaneously. If they don't match, return false."
            },
            {
              "optionId": "ch_viva_1_q1_opt5",
              "optionText": "I will use Binary Search on the Stack to find the Queue elements."
            },
            {
              "optionId": "ch_viva_1_q1_opt6",
              "optionText": "Time complexity is $O(1)$ because I'm just comparing elements."
            },
            {
              "optionId": "ch_viva_1_q1_opt7",
              "optionText": "I will check `stack.contains(queue.front())`."
            },
            {
              "optionId": "ch_viva_1_q1_opt8",
              "optionText": "I will pop everything from the Stack into the Queue and check for duplicates."
            },
            {
              "optionId": "ch_viva_1_q1_opt9",
              "optionText": "I will use a Hash Map to count frequencies. First, I pop all elements from the Stack, incrementing their counts in the Map. Then, I dequeue all elements from the Queue, decrementing their counts. Finally, I check if the Map is empty or all counts are zero. Return true if so."
            },
            {
              "optionId": "ch_viva_1_q1_opt10",
              "optionText": "I will initialize two empty auxiliary arrays. I will pop the Stack into Array A and dequeue the Queue into Array B. I will then Sort both arrays. Finally, I will iterate through both arrays simultaneously to check if they are identical. Return True if the loop finishes successfully."
            },
            {
              "optionId": "ch_viva_1_q1_opt11",
              "optionText": "I will use a Hash Set. I pop elements from the Stack and add them to the Set. Then, I dequeue from the Queue and check if each element exists in the Set."
            },
            {
              "optionId": "ch_viva_1_q1_opt12",
              "optionText": "I will simply return `stack.equals(queue)`."
            },
            {
              "optionId": "ch_viva_1_q1_opt13",
              "optionText": "I will peek at the top of the stack and the front of the queue loop until empty."
            },
            {
              "optionId": "ch_viva_1_q1_opt14",
              "optionText": "I will convert both to arrays and compare `array1 == array2`."
            },
            {
              "optionId": "ch_viva_1_q1_opt15",
              "optionText": "I will use a Frequency Map. I loop through the Stack and Queue, updating counts. If all counts are zero, they are equal."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q1_opt9", "ch_viva_1_q1_opt10", "ch_viva_1_q1_opt15"],
          "explanationText": "The key is handling duplicates and order independence efficiently. \n\n1. **Hash Map (O(N) Time, O(N) Space):** This is the most efficient method as it handles duplicates and order in a single pass.\n2. **Sorting (O(N log N) Time, O(N) Space):** This is also valid, but slower than the Hash Map approach.\n\nIncorrect answers fail because they assume order matters, use inefficient $O(N^2)$ search, or rely on non-existent methods.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q2",
          "questionText": "Sketch an algorithm to move all elements from a **Queue** into a **Stack** such that the order of elements is **reversed** compared to the original Queue.",
          "options": [
            {
              "optionId": "ch_viva_1_q2_opt1",
              "optionText": "I will initialize an empty Stack. While the Queue is not empty, I will `dequeue` an element and immediately `push` it onto the Stack. Finally, I return the Stack."
            },
            {
              "optionId": "ch_viva_1_q2_opt2",
              "optionText": "I'll create a function taking the Queue. I'll create a Stack. I loop until `queue.isEmpty()`. Inside the loop: `val = queue.dequeue()`, `stack.push(val)`. Return the Stack."
            },
            {
              "optionId": "ch_viva_1_q2_opt3",
              "optionText": "I will transfer elements directly. Since the Queue removes from the front (1st item) and the Stack adds to the top, the first item out of the Queue becomes the bottom of the Stack. The last item out becomes the top. This naturally reverses the access order."
            },
            {
              "optionId": "ch_viva_1_q2_opt4",
              "optionText": "I will use two auxiliary stacks to flip the order twice."
            },
            {
              "optionId": "ch_viva_1_q2_opt5",
              "optionText": "I will swap the head and tail pointers of the Queue."
            },
            {
              "optionId": "ch_viva_1_q2_opt6",
              "optionText": "I will iterate backwards through the Queue."
            },
            {
              "optionId": "ch_viva_1_q2_opt7",
              "optionText": "I will push the whole Queue object onto the Stack."
            },
            {
              "optionId": "ch_viva_1_q2_opt8",
              "optionText": "I will dequeue elements and add them to the *bottom* of the Stack."
            },
            {
              "optionId": "ch_viva_1_q2_opt9",
              "optionText": "I will use an array, fill it with the queue, reverse the array, then push to stack."
            },
            {
              "optionId": "ch_viva_1_q2_opt10",
              "optionText": "I will use recursion to reach the end of the queue first."
            },
            {
              "optionId": "ch_viva_1_q2_opt11",
              "optionText": "Time complexity is $O(N^2)$ because push is expensive."
            },
            {
              "optionId": "ch_viva_1_q2_opt12",
              "optionText": "I will use a Doubly Linked List to traverse the Queue in reverse."
            },
            {
              "optionId": "ch_viva_1_q2_opt13",
              "optionText": "I will delete the Queue and create a new Stack with the same values."
            },
            {
              "optionId": "ch_viva_1_q2_opt14",
              "optionText": "I will peek at the queue, push to stack, then dequeue."
            },
            {
              "optionId": "ch_viva_1_q2_opt15",
              "optionText": "I will return the Queue as a Stack."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q2_opt1", "ch_viva_1_q2_opt2", "ch_viva_1_q2_opt3"],
          "explanationText": "Moving elements from a FIFO structure (Queue) directly into a LIFO structure (Stack) naturally reverses the order of retrieval. The first element dequeued becomes the deepest element in the stack, and the last element dequeued becomes the top element. This is an $O(N)$ operation.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q3",
          "questionText": "Sketch an algorithm to insert a new node with value `K` at the **Head** of a **Circular Linked List**, given a pointer to the `tail`.",
          "options": [
            {
              "optionId": "ch_viva_1_q3_opt1",
              "optionText": "First, I check if the list is empty. If so, create the node and point it to itself. If not, I create `newNode`. I set `newNode.next = tail.next` (current head). Then, I update `tail.next = newNode`. I return the original `tail` pointer."
            },
            {
              "optionId": "ch_viva_1_q3_opt2",
              "optionText": "I will initialize a `newNode` with data `K`. I link `newNode.next` to the current `head` (which is `tail.next`). Then I simply update the `tail`'s next pointer to point to my `newNode`. This effectively places it at the start without moving the tail."
            },
            {
              "optionId": "ch_viva_1_q3_opt3",
              "optionText": "I handle the empty case by making the node point to itself. For the non-empty case, I perform a standard insertion after `tail`, but I strictly *do not* update the `tail` reference itself, leaving the new node as the new head."
            },
            {
              "optionId": "ch_viva_1_q3_opt4",
              "optionText": "I will create a node and set `head.prev = new node`."
            },
            {
              "optionId": "ch_viva_1_q3_opt5",
              "optionText": "I will set `tail.next = new node` and `new node.next = null`."
            },
            {
              "optionId": "ch_viva_1_q3_opt6",
              "optionText": "I will traverse to the end of the list."
            },
            {
              "optionId": "ch_viva_1_q3_opt7",
              "optionText": "I will set `tail = new node`."
            },
            {
              "optionId": "ch_viva_1_q3_opt8",
              "optionText": "I will update `head` pointer to `new node`."
            },
            {
              "optionId": "ch_viva_1_q3_opt9",
              "optionText": "Complexity is $O(N)$ because I have to find the head."
            },
            {
              "optionId": "ch_viva_1_q3_opt10",
              "optionText": "I will swap the values of the tail and the new node."
            },
            {
              "optionId": "ch_viva_1_q3_opt11",
              "optionText": "I will create a node, link it to `tail`, and link `tail` to it."
            },
            {
              "optionId": "ch_viva_1_q3_opt12",
              "optionText": "If the list is empty, I just set `tail = new node`."
            },
            {
              "optionId": "ch_viva_1_q3_opt13",
              "optionText": "I will use a temporary pointer to traverse the circle."
            },
            {
              "optionId": "ch_viva_1_q3_opt14",
              "optionText": "I will insert it after the tail and move the tail pointer forward."
            },
            {
              "optionId": "ch_viva_1_q3_opt15",
              "optionText": "I will check if `tail.next` is null."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q3_opt1", "ch_viva_1_q3_opt2", "ch_viva_1_q3_opt3"],
          "explanationText": "In a circular list managed by a `tail` pointer, the head is always `tail.next`. Insertion at the head is an $O(1)$ operation: link the new node to the current head, then update the tail's next pointer to the new node.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q4",
          "questionText": "Sketch an **iterative** (non-recursive) algorithm to find the **sum** of all keys in a **Binary Tree**.",
          "options": [
            {
              "optionId": "ch_viva_1_q4_opt1",
              "optionText": "I will use a **Queue** for Level-Order Traversal. Initialize `sum = 0`. Enqueue `root`. While Queue is not empty: Dequeue a node, add its key to `sum`. If `node.left` exists, Enqueue it. If `node.right` exists, Enqueue it. Return `sum`."
            },
            {
              "optionId": "ch_viva_1_q4_opt2",
              "optionText": "I will use a **Stack** for Depth-First Traversal. Initialize `sum = 0`. Push `root`. While Stack has items: Pop `current`. `sum += current.key`. Push `current.right` and `current.left` if they are not null. Return `sum`."
            },
            {
              "optionId": "ch_viva_1_q4_opt3",
              "optionText": "I will initialize a `total` variable. Using a standard iterative traversal (like BFS with a Queue), I visit every node exactly once. At each visit, I accumulate the value into `total`. Finally, I return `total`."
            },
            {
              "optionId": "ch_viva_1_q4_opt4",
              "optionText": "I will simply loop through the tree `for node in tree`..."
            },
            {
              "optionId": "ch_viva_1_q4_opt5",
              "optionText": "I will use `return sum(left) + sum(right)`."
            },
            {
              "optionId": "ch_viva_1_q4_opt6",
              "optionText": "I will use a Stack. Push root. Pop, add to sum. Push left child, Push right child. Return sum."
            },
            {
              "optionId": "ch_viva_1_q4_opt7",
              "optionText": "I will use a Binary Search to sum the nodes."
            },
            {
              "optionId": "ch_viva_1_q4_opt8",
              "optionText": "I will traverse the tree using pointers `current = current.left`."
            },
            {
              "optionId": "ch_viva_1_q4_opt9",
              "optionText": "I will convert the tree to an array using `tree.toArray()`."
            },
            {
              "optionId": "ch_viva_1_q4_opt10",
              "optionText": "Complexity is $O(\\log N)$."
            },
            {
              "optionId": "ch_viva_1_q4_opt11",
              "optionText": "I will use a Queue to perform DFS."
            },
            {
              "optionId": "ch_viva_1_q4_opt12",
              "optionText": "I initialize sum to 0. While root is not null, add root, root = root.next."
            },
            {
              "optionId": "ch_viva_1_q4_opt13",
              "optionText": "I will use a Hash Map to store visited nodes."
            },
            {
              "optionId": "ch_viva_1_q4_opt14",
              "optionText": "I will delete nodes as I sum them to save space."
            },
            {
              "optionId": "ch_viva_1_q4_opt15",
              "optionText": "I will start at the root and keep adding `node.key` until `node` is null."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q4_opt1", "ch_viva_1_q4_opt2", "ch_viva_1_q4_opt3"],
          "explanationText": "Iterative traversal requires an auxiliary data structure (Stack for DFS or Queue for BFS) to store unvisited nodes. Since summing requires visiting every node, the time complexity is $O(N)$. Option 6 is logically correct but lacks the necessary null checks for children.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q5",
          "questionText": "Sketch an algorithm to **sort** an array of integers in **descending** order using a **Min-Heap**.",
          "options": [
            {
              "optionId": "ch_viva_1_q5_opt1",
              "optionText": "I will create an empty Min-Heap. I insert all array elements into it. Then, I iterate an index `i` starting from the array's **length - 1 down to 0**. At each step, I call `extractMin()` and place the result at `array[i]`. This fills the array with the largest elements at the start and smallest at the end."
            },
            {
              "optionId": "ch_viva_1_q5_opt2",
              "optionText": "Alternatively, I could use a **Max-Heap**. I insert all elements. Then I call `extractMax()` repeatedly and fill the array from index 0 upwards. This results in descending order."
            },
            {
              "optionId": "ch_viva_1_q5_opt3",
              "optionText": "I will Heapify the array into a Min-Heap. Then, I will continuously extract the minimum element. Since I need descending order, I will use a Stack to store the extracted elements temporarily, then pop them back into the array."
            },
            {
              "optionId": "ch_viva_1_q5_opt4",
              "optionText": "I insert everything into the Min-Heap, then `extractMin` and put them in the array from index 0 upwards."
            },
            {
              "optionId": "ch_viva_1_q5_opt5",
              "optionText": "I use `binarySearch` on the Heap to find the largest element."
            },
            {
              "optionId": "ch_viva_1_q5_opt6",
              "optionText": "I simply traverse the Heap array and copy elements."
            },
            {
              "optionId": "ch_viva_1_q5_opt7",
              "optionText": "I insert into the Heap, then use Bubble Sort."
            },
            {
              "optionId": "ch_viva_1_q5_opt8",
              "optionText": "I extract elements and push them onto a Stack, then pop to array."
            },
            {
              "optionId": "ch_viva_1_q5_opt9",
              "optionText": "Time complexity is $O(N)$."
            },
            {
              "optionId": "ch_viva_1_q5_opt10",
              "optionText": "I check the leaf nodes for the maximum value."
            },
            {
              "optionId": "ch_viva_1_q5_opt11",
              "optionText": "I use a Min-Heap but negate the numbers before inserting."
            },
            {
              "optionId": "ch_viva_1_q5_opt12",
              "optionText": "I extract root, then swap root with random element."
            },
            {
              "optionId": "ch_viva_1_q5_opt13",
              "optionText": "I delete the heap and create a sorted list."
            },
            {
              "optionId": "ch_viva_1_q5_opt14",
              "optionText": "I assume the Heap is already sorted."
            },
            {
              "optionId": "ch_viva_1_q5_opt15",
              "optionText": "I return the underlying array of the Heap."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q5_opt1", "ch_viva_1_q5_opt2", "ch_viva_1_q5_opt3"],
          "explanationText": "A Min-Heap naturally extracts elements in ascending order. To achieve descending order, you must either use a Max-Heap (Option 2) or reverse the output of the Min-Heap, either by filling the array backwards (Option 1) or using an auxiliary Stack (Option 3). All methods result in $O(N \\log N)$ time complexity.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q6",
          "questionText": "Given a Graph (Adjacency List) and a starting vertex `S`, sketch an algorithm to find the **shortest path** (number of edges) from `S` to a target `T`.",
          "options": [
            {
              "optionId": "ch_viva_1_q6_opt1",
              "optionText": "I will use **BFS** with a Queue. I'll also maintain a `distance` Map (or array) initialized to -1. Set `distance[S] = 0`. Enqueue `S`. While Queue not empty: Dequeue `u`. If `u == T`, return `distance[u]`. For each neighbor `v` of `u`: If `v` is unvisited, set `distance[v] = distance[u] + 1` and Enqueue `v`."
            },
            {
              "optionId": "ch_viva_1_q6_opt2",
              "optionText": "I initialize a Queue for the traversal and a Set for visited nodes. I start a level-counter at 0. I process nodes level-by-level (using the queue size). If I encounter `T`, I return the current level count. If the queue empties, `T` is unreachable."
            },
            {
              "optionId": "ch_viva_1_q6_opt3",
              "optionText": "I employ a Breadth-First Search strategy. I enqueue the start node `S`. I keep track of `predecessor` pointers. When I find `T`, I backtrack using the predecessors to count the steps. This ensures the shortest path in an unweighted graph."
            },
            {
              "optionId": "ch_viva_1_q6_opt4",
              "optionText": "I will use DFS (Stack) to search for the node."
            },
            {
              "optionId": "ch_viva_1_q6_opt5",
              "optionText": "I will traverse the adjacency list linearly."
            },
            {
              "optionId": "ch_viva_1_q6_opt6",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_1_q6_opt7",
              "optionText": "I don't need to mark visited nodes because it's a list."
            },
            {
              "optionId": "ch_viva_1_q6_opt8",
              "optionText": "I will use Dijkstra's Algorithm."
            },
            {
              "optionId": "ch_viva_1_q6_opt9",
              "optionText": "I will sort the edges."
            },
            {
              "optionId": "ch_viva_1_q6_opt10",
              "optionText": "I will return `true` if found."
            },
            {
              "optionId": "ch_viva_1_q6_opt11",
              "optionText": "I use a Queue, enqueue S. While queue not empty, dequeue, check if T. If yes, return. Else enqueue neighbors."
            },
            {
              "optionId": "ch_viva_1_q6_opt12",
              "optionText": "Time complexity is $O(N^2)$."
            },
            {
              "optionId": "ch_viva_1_q6_opt13",
              "optionText": "I assume the graph is a tree."
            },
            {
              "optionId": "ch_viva_1_q6_opt14",
              "optionText": "I check `S.next` until I find `T`."
            },
            {
              "optionId": "ch_viva_1_q6_opt15",
              "optionText": "I use a Priority Queue."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q6_opt1", "ch_viva_1_q6_opt2", "ch_viva_1_q6_opt3"],
          "explanationText": "For unweighted graphs, Breadth-First Search (BFS) guarantees finding the shortest path in terms of the number of edges. DFS only finds *a* path. The complexity is $O(V+E)$. Tracking distance or predecessors is necessary to return the path length or the path itself.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q7",
          "questionText": "Sketch an algorithm to find all elements in an integer Array that appear **more than once** (duplicates).",
          "options": [
            {
              "optionId": "ch_viva_1_q7_opt1",
              "optionText": "I will initialize an empty **Hash Set** called `seen` and a Set called `duplicates`. I iterate through the array. For each number: if it is already in `seen`, I add it to `duplicates`. Else, I add it to `seen`. Finally, I return the `duplicates` set."
            },
            {
              "optionId": "ch_viva_1_q7_opt2",
              "optionText": "I will use a **Frequency Map**. Loop through the array, mapping `Number -> Count`. After the loop, iterate through the Map's keys. If `Count > 1`, add to my result list. Return result."
            },
            {
              "optionId": "ch_viva_1_q7_opt3",
              "optionText": "I initialize a Hash Set. I loop through the array. If `set.add(value)` returns false (meaning it's already there), I print/store that value as a duplicate."
            },
            {
              "optionId": "ch_viva_1_q7_opt4",
              "optionText": "I will use nested loops to compare every number with every other number."
            },
            {
              "optionId": "ch_viva_1_q7_opt5",
              "optionText": "I will Sort the array and check neighbors."
            },
            {
              "optionId": "ch_viva_1_q7_opt6",
              "optionText": "I will use a Binary Search Tree."
            },
            {
              "optionId": "ch_viva_1_q7_opt7",
              "optionText": "I will use a Stack to track numbers."
            },
            {
              "optionId": "ch_viva_1_q7_opt8",
              "optionText": "I will use a Hash Map. If key exists, return true."
            },
            {
              "optionId": "ch_viva_1_q7_opt9",
              "optionText": "I will use an array of size 100 to count."
            },
            {
              "optionId": "ch_viva_1_q7_opt10",
              "optionText": "I will delete duplicates from the array."
            },
            {
              "optionId": "ch_viva_1_q7_opt11",
              "optionText": "Space complexity is $O(1)$."
            },
            {
              "optionId": "ch_viva_1_q7_opt12",
              "optionText": "I will hash the whole array into one value."
            },
            {
              "optionId": "ch_viva_1_q7_opt13",
              "optionText": "I will use a Queue to cycle through numbers."
            },
            {
              "optionId": "ch_viva_1_q7_opt14",
              "optionText": "I will use a Linked List to store seen numbers."
            },
            {
              "optionId": "ch_viva_1_q7_opt15",
              "optionText": "I will compare the first and last elements."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q7_opt1", "ch_viva_1_q7_opt2", "ch_viva_1_q7_opt3"],
          "explanationText": "The most efficient solution is to use a Hash Table (Map or Set) to track frequencies or existence. This allows for an $O(N)$ time complexity solution, which is faster than sorting ($O(N \\log N)$) or nested loops ($O(N^2)$).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q8",
          "questionText": "Sketch an algorithm to check if a given Binary Tree is a valid **Binary Search Tree (BST)**.",
          "options": [
            {
              "optionId": "ch_viva_1_q8_opt1",
              "optionText": "I will perform an **In-Order Traversal** and store the values in a list. Then, I iterate through the list to check if it is **sorted** in strictly ascending order. If yes, it is a BST."
            },
            {
              "optionId": "ch_viva_1_q8_opt2",
              "optionText": "I will use a recursive function that takes a node and a valid range `(min, max)`. Initialize with `(-\\infty, +\\infty)`. At each node, check if `val` is within range. Recurse left updating `max` to `val`. Recurse right updating `min` to `val`."
            },
            {
              "optionId": "ch_viva_1_q8_opt3",
              "optionText": "I will use an Iterative In-Order traversal (using a Stack). I keep track of the `previous_value` visited. If the `current_value` is ever less than or equal to `previous_value`, I return False immediately."
            },
            {
              "optionId": "ch_viva_1_q8_opt4",
              "optionText": "I will traverse and check if `node.left.val < node.val` and `node.right.val > node.val`."
            },
            {
              "optionId": "ch_viva_1_q8_opt5",
              "optionText": "I will perform a Pre-Order traversal."
            },
            {
              "optionId": "ch_viva_1_q8_opt6",
              "optionText": "I will search for duplicates."
            },
            {
              "optionId": "ch_viva_1_q8_opt7",
              "optionText": "I will use a Queue for BFS and check values."
            },
            {
              "optionId": "ch_viva_1_q8_opt8",
              "optionText": "I will check if the tree is balanced."
            },
            {
              "optionId": "ch_viva_1_q8_opt9",
              "optionText": "I will sort the tree."
            },
            {
              "optionId": "ch_viva_1_q8_opt10",
              "optionText": "I will check if the height is $\\log N$."
            },
            {
              "optionId": "ch_viva_1_q8_opt11",
              "optionText": "I will assume it is a BST and try to search."
            },
            {
              "optionId": "ch_viva_1_q8_opt12",
              "optionText": "I compare the root with the leaves."
            },
            {
              "optionId": "ch_viva_1_q8_opt13",
              "optionText": "I convert it to a Heap and check."
            },
            {
              "optionId": "ch_viva_1_q8_opt14",
              "optionText": "I use recursion without passing min/max limits."
            },
            {
              "optionId": "ch_viva_1_q8_opt15",
              "optionText": "I return true if it has 2 children."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q8_opt1", "ch_viva_1_q8_opt2", "ch_viva_1_q8_opt3"],
          "explanationText": "The core property of a BST is that an In-Order traversal yields a sorted list (Options 1, 3). Alternatively, the recursive approach (Option 2) is robust, ensuring that every node adheres to the global min/max constraints imposed by its ancestors, not just its immediate parent.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q9",
          "questionText": "Sketch an algorithm to find the **middle node** of a Singly Linked List.",
          "options": [
            {
              "optionId": "ch_viva_1_q9_opt1",
              "optionText": "I will use the **Two Pointer Method** (Slow and Fast). Initialize both at head. Loop while `fast` and `fast.next` are not null. Move `slow` one step, move `fast` two steps. When `fast` reaches the end, `slow` will be at the middle. Return `slow`."
            },
            {
              "optionId": "ch_viva_1_q9_opt2",
              "optionText": "I will perform two passes. First, traverse to count total nodes `N`. Then, calculate `mid = N/2`. Traverse again from head `mid` times to reach the node. Return it."
            },
            {
              "optionId": "ch_viva_1_q9_opt3",
              "optionText": "I will push every node pointer onto a Stack while traversing. Then I pop $N/2$ elements off the stack. The element currently at the top is the middle."
            },
            {
              "optionId": "ch_viva_1_q9_opt4",
              "optionText": "I will access `list[size / 2]`."
            },
            {
              "optionId": "ch_viva_1_q9_opt5",
              "optionText": "I will use `head.next.next`."
            },
            {
              "optionId": "ch_viva_1_q9_opt6",
              "optionText": "I will check if `node.next == null`."
            },
            {
              "optionId": "ch_viva_1_q9_opt7",
              "optionText": "I will create a new array, copy the list, and take the middle index."
            },
            {
              "optionId": "ch_viva_1_q9_opt8",
              "optionText": "I will use recursion to fold the list in half."
            },
            {
              "optionId": "ch_viva_1_q9_opt9",
              "optionText": "I will guess the middle."
            },
            {
              "optionId": "ch_viva_1_q9_opt10",
              "optionText": "I will keep a count and stop at count 5."
            },
            {
              "optionId": "ch_viva_1_q9_opt11",
              "optionText": "I will iterate `i` and `j` at the same speed."
            },
            {
              "optionId": "ch_viva_1_q9_opt12",
              "optionText": "I will use a Doubly Linked List approach."
            },
            {
              "optionId": "ch_viva_1_q9_opt13",
              "optionText": "I will delete nodes from start and end until 1 remains."
            },
            {
              "optionId": "ch_viva_1_q9_opt14",
              "optionText": "I will use a Hash Map to store indices."
            },
            {
              "optionId": "ch_viva_1_q9_opt15",
              "optionText": "I will assume the list has size variable available."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q9_opt1", "ch_viva_1_q9_opt2", "ch_viva_1_q9_opt3"],
          "explanationText": "The Two-Pointer (Tortoise and Hare) method (Option 1) is the most efficient, solving the problem in a single pass $O(N)$ time and $O(1)$ space. The two-pass method (Option 2) is also $O(N)$ time but requires two full traversals. The Stack method (Option 3) is $O(N)$ time but uses $O(N)$ space.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_1_q10",
          "questionText": "Sketch an algorithm to **delete** a specific node `P` from a **Doubly Linked List**, given only the pointer to `P`.",
          "options": [
            {
              "optionId": "ch_viva_1_q10_opt1",
              "optionText": "I check if `P.prev` exists. If so, `P.prev.next = P.next`. If not, `P` was head (update head). Then check if `P.next` exists. If so, `P.next.prev = P.prev`. If not, `P` was tail. Finally, nullify `P`'s pointers."
            },
            {
              "optionId": "ch_viva_1_q10_opt2",
              "optionText": "Since I have access to neighbors, I link the node *before* `P` directly to the node *after* `P`, and vice versa. This effectively bypasses `P`. This is an $O(1)$ operation."
            },
            {
              "optionId": "ch_viva_1_q10_opt3",
              "optionText": "I identify `left = P.prev` and `right = P.next`. If `left` is not null, `left.next = right`. If `right` is not null, `right.prev = left`. The node is now detached."
            },
            {
              "optionId": "ch_viva_1_q10_opt4",
              "optionText": "I will traverse from Head to find `P`..."
            },
            {
              "optionId": "ch_viva_1_q10_opt5",
              "optionText": "I will set `P = null`."
            },
            {
              "optionId": "ch_viva_1_q10_opt6",
              "optionText": "I will set `P.next.prev = P.prev` only."
            },
            {
              "optionId": "ch_viva_1_q10_opt7",
              "optionText": "I will copy the data from the next node into `P` and delete the next node."
            },
            {
              "optionId": "ch_viva_1_q10_opt8",
              "optionText": "I will delete the whole list."
            },
            {
              "optionId": "ch_viva_1_q10_opt9",
              "optionText": "I will use a Stack to track previous nodes."
            },
            {
              "optionId": "ch_viva_1_q10_opt10",
              "optionText": "I will swap `P` with the Tail and delete Tail."
            },
            {
              "optionId": "ch_viva_1_q10_opt11",
              "optionText": "I will return the value of `P`."
            },
            {
              "optionId": "ch_viva_1_q10_opt12",
              "optionText": "Complexity is $O(N)$."
            },
            {
              "optionId": "ch_viva_1_q10_opt13",
              "optionText": "I assume `P` is always in the middle."
            },
            {
              "optionId": "ch_viva_1_q10_opt14",
              "optionText": "I link `P.prev` to `P.prev.prev`."
            },
            {
              "optionId": "ch_viva_1_q10_opt15",
              "optionText": "I will check if `P` is null and return."
            }
          ],
          "correctOptionIds": ["ch_viva_1_q10_opt1", "ch_viva_1_q10_opt2", "ch_viva_1_q10_opt3"],
          "explanationText": "Since a Doubly Linked List provides access to both `prev` and `next` pointers, deletion can be performed in $O(1)$ time by simply updating the neighbors' pointers to bypass the node `P`. Edge cases (deleting head or tail) must be handled by checking for null pointers.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 6,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_2",
      "name": "Linked List Cycles, Reversal, and Merging (Q11-Q15)",
      "questions": [
        {
          "questionId": "ch_viva_2_q11",
          "questionText": "Sketch an algorithm to determine if a **Singly Linked List** contains a cycle (a loop). You cannot modify the list structure.",
          "options": [
            {
              "optionId": "ch_viva_2_q11_opt1",
              "optionText": "I will use **Floydâ€™s Cycle-Finding Algorithm** (Tortoise and Hare). I initialize two pointers, `slow` and `fast`, both at the head. I loop while `fast` and `fast.next` are not null. `slow` moves 1 step; `fast` moves 2 steps. If `slow == fast`, I return True. If the loop ends, I return False."
            },
            {
              "optionId": "ch_viva_2_q11_opt2",
              "optionText": "I will use a **Hash Set** of Node References (not values). I traverse the list. For every node, I check if the *pointer address* is already in the Set. If yes, cycle detected. If no, add it. If I hit null, return False. (Note: This uses $O(N)$ space)."
            },
            {
              "optionId": "ch_viva_2_q11_opt3",
              "optionText": "I will use two pointers. `Fast` moves twice as fast as `Slow`. If there is a cycle, `Fast` will eventually 'lap' (catch up to) `Slow` inside the loop. If `Fast` reaches null, the list is linear."
            },
            {
              "optionId": "ch_viva_2_q11_opt4",
              "optionText": "I will traverse the list and check if `current.next == head`."
            },
            {
              "optionId": "ch_viva_2_q11_opt5",
              "optionText": "I will iterate for a set time (e.g., 5 seconds) and if it doesn't end, it's a cycle."
            },
            {
              "optionId": "ch_viva_2_q11_opt6",
              "optionText": "I will traverse the list and mark nodes as 'visited' by adding a boolean flag."
            },
            {
              "optionId": "ch_viva_2_q11_opt7",
              "optionText": "I will check if `next` pointers are increasing in memory address."
            },
            {
              "optionId": "ch_viva_2_q11_opt8",
              "optionText": "I will use recursion to traverse; if the stack overflows, there is a cycle."
            },
            {
              "optionId": "ch_viva_2_q11_opt9",
              "optionText": "I will compare the current node with the previous node."
            },
            {
              "optionId": "ch_viva_2_q11_opt10",
              "optionText": "I will reverse the list and see if I return to the start."
            },
            {
              "optionId": "ch_viva_2_q11_opt11",
              "optionText": "I will use two pointers moving at the same speed starting from opposite ends."
            },
            {
              "optionId": "ch_viva_2_q11_opt12",
              "optionText": "I will calculate the length of the list. If it's infinite, return true."
            },
            {
              "optionId": "ch_viva_2_q11_opt13",
              "optionText": "I will check if the last node points to null."
            },
            {
              "optionId": "ch_viva_2_q11_opt14",
              "optionText": "I will use a Hash Map to store values."
            },
            {
              "optionId": "ch_viva_2_q11_opt15",
              "optionText": "I will delete nodes as I go. If I hit a null, no cycle."
            }
          ],
          "correctOptionIds": ["ch_viva_2_q11_opt1", "ch_viva_2_q11_opt2", "ch_viva_2_q11_opt3"],
          "explanationText": "The Tortoise and Hare algorithm (Floyd's) is the optimal solution, providing $O(N)$ time complexity and $O(1)$ space complexity. Using a Hash Set is also $O(N)$ time but requires $O(N)$ space to store node references.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_2_q12",
          "questionText": "Sketch an algorithm to **reverse** a **Singly Linked List** in-place (without creating a new list).",
          "options": [
            {
              "optionId": "ch_viva_2_q12_opt1",
              "optionText": "I initialize three pointers: `prev` (null), `curr` (head), and `next` (null). I loop while `curr` is not null. Inside: 1. Save `next = curr.next`. 2. Reverse link `curr.next = prev`. 3. Move `prev = curr`. 4. Move `curr = next`. Finally, update `head = prev`."
            },
            {
              "optionId": "ch_viva_2_q12_opt2",
              "optionText": "I utilize a standard iterative pointer reversal. I maintain a `previous` pointer. As I traverse with `current`, I temporarily store the `future` node. I redirect `current` to point to `previous`, then shift our window of three pointers one step forward."
            },
            {
              "optionId": "ch_viva_2_q12_opt3",
              "optionText": "I use recursion. Base case: if head is empty or single, return it. Recursive step: `newHead = reverse(head.next)`. Then perform the surgery: `head.next.next = head` and `head.next = null`. Return `newHead`."
            },
            {
              "optionId": "ch_viva_2_q12_opt4",
              "optionText": "I will swap the `head` and `tail` pointers."
            },
            {
              "optionId": "ch_viva_2_q12_opt5",
              "optionText": "I will traverse the list and set `node.next = node.prev`."
            },
            {
              "optionId": "ch_viva_2_q12_opt6",
              "optionText": "I will use a Stack to store values, then overwrite the nodes."
            },
            {
              "optionId": "ch_viva_2_q12_opt7",
              "optionText": "I will iterate through: `curr.next = prev; prev = curr; curr = curr.next`."
            },
            {
              "optionId": "ch_viva_2_q12_opt8",
              "optionText": "I will swap the first node with the last, second with second-last..."
            },
            {
              "optionId": "ch_viva_2_q12_opt9",
              "optionText": "I will use Recursion: `head.next = reverse(head)`."
            },
            {
              "optionId": "ch_viva_2_q12_opt10",
              "optionText": "I will create a new List and add nodes to the head."
            },
            {
              "optionId": "ch_viva_2_q12_opt11",
              "optionText": "I will use Doubly Linked List logic."
            },
            {
              "optionId": "ch_viva_2_q12_opt12",
              "optionText": "I will iterate `i` from 0 to N and swap `next` pointers."
            },
            {
              "optionId": "ch_viva_2_q12_opt13",
              "optionText": "I will point the head to null and the tail to the head."
            },
            {
              "optionId": "ch_viva_2_q12_opt14",
              "optionText": "I will traverse to the end, then work backwards."
            },
            {
              "optionId": "ch_viva_2_q12_opt15",
              "optionText": "I will use a temporary variable to swap `node` and `node.next`."
            }
          ],
          "correctOptionIds": ["ch_viva_2_q12_opt1", "ch_viva_2_q12_opt2", "ch_viva_2_q12_opt3"],
          "explanationText": "The iterative solution (Options 1, 2) is the most common and efficient, using $O(N)$ time and $O(1)$ space by managing three pointers (`prev`, `curr`, `next`). The recursive solution (Option 3) is also $O(N)$ time but uses $O(N)$ space on the call stack.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_2_q13",
          "questionText": "Sketch an algorithm to merge two **Sorted Arrays** into a single **Sorted Array**.",
          "options": [
            {
              "optionId": "ch_viva_2_q13_opt1",
              "optionText": "I initialize a new array of size `A+B` and two pointers `i=0, j=0`. While both pointers are valid, I compare `A[i]` and `B[j]`. I add the smaller one to the new array and increment its pointer. Once one array is exhausted, I copy the remaining elements of the other array."
            },
            {
              "optionId": "ch_viva_2_q13_opt2",
              "optionText": "I use the 'Two Finger' method. I point to the start of both arrays. I repeatedly select the minimum of the two pointed values, append it to my result list, and advance that specific pointer. Finally, I append any 'tail' remaining in the non-empty array."
            },
            {
              "optionId": "ch_viva_2_q13_opt3",
              "optionText": "I iterate both arrays. If `A[i] \\le B[j]`, push `A[i]`. Else push `B[j]`. This linear scan merges them in $O(N)$ time."
            },
            {
              "optionId": "ch_viva_2_q13_opt4",
              "optionText": "I will append Array B to Array A and call `QuickSort`."
            },
            {
              "optionId": "ch_viva_2_q13_opt5",
              "optionText": "I will insert elements of Array B into Array A one by one."
            },
            {
              "optionId": "ch_viva_2_q13_opt6",
              "optionText": "I will use two loops: `for i in A` and `for j in B`."
            },
            {
              "optionId": "ch_viva_2_q13_opt7",
              "optionText": "I will use a Hash Set to merge them."
            },
            {
              "optionId": "ch_viva_2_q13_opt8",
              "optionText": "I will compare `A[i]` and `B[i]` and add the smaller one."
            },
            {
              "optionId": "ch_viva_2_q13_opt9",
              "optionText": "I will zip them together `A[0], B[0], A[1], B[1]`..."
            },
            {
              "optionId": "ch_viva_2_q13_opt10",
              "optionText": "I will use a Stack to sort them."
            },
            {
              "optionId": "ch_viva_2_q13_opt11",
              "optionText": "I will create a new array of size `A.length`."
            },
            {
              "optionId": "ch_viva_2_q13_opt12",
              "optionText": "I will iterate until `i < A.length` AND `j < B.length`, then stop."
            },
            {
              "optionId": "ch_viva_2_q13_opt13",
              "optionText": "I will use a Max-Heap."
            },
            {
              "optionId": "ch_viva_2_q13_opt14",
              "optionText": "I will delete elements from A as I move them."
            },
            {
              "optionId": "ch_viva_2_q13_opt15",
              "optionText": "I will start from the end of both arrays."
            }
          ],
          "correctOptionIds": ["ch_viva_2_q13_opt1", "ch_viva_2_q13_opt2", "ch_viva_2_q13_opt3"],
          "explanationText": "Since both input arrays are already sorted, the merge operation can be done in linear time, $O(N+M)$, using the 'Two Finger' approach. This is the core step of Merge Sort and is significantly faster than sorting the combined array ($O((N+M) \\log (N+M))$).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_2_q14",
          "questionText": "Sketch an algorithm to implement a **Queue** (FIFO) using only **two Stacks**.",
          "options": [
            {
              "optionId": "ch_viva_2_q14_opt1",
              "optionText": "I maintain an `InStack` and an `OutStack`. For `enqueue`, I simply push to `InStack`. For `dequeue`, I check if `OutStack` is empty. If it is, I pop *all* elements from `InStack` and push them to `OutStack` (reversing order). Then I pop from `OutStack`."
            },
            {
              "optionId": "ch_viva_2_q14_opt2",
              "optionText": "I separate concerns: Stack A is for writing, Stack B is for reading. When the user asks to read (dequeue) and Stack B is empty, I 'pour' the entire contents of A into B. This reverses the LIFO order to FIFO. I then pop from B."
            },
            {
              "optionId": "ch_viva_2_q14_opt3",
              "optionText": "I define `push` as `s1.push(x)`. I define `pop`: If `s2` is empty, transfer `s1` to `s2`. Return `s2.pop()`. This provides amortized $O(1)$ time complexity."
            },
            {
              "optionId": "ch_viva_2_q14_opt4",
              "optionText": "I will use one stack for evens and one for odds."
            },
            {
              "optionId": "ch_viva_2_q14_opt5",
              "optionText": "To enqueue, I push to Stack 1. To dequeue, I pop from Stack 1."
            },
            {
              "optionId": "ch_viva_2_q14_opt6",
              "optionText": "I will push to Stack 1. When I need to dequeue, I move *everything* to Stack 2, pop, then move *everything* back to Stack 1."
            },
            {
              "optionId": "ch_viva_2_q14_opt7",
              "optionText": "I will use Stack 1 as the Head and Stack 2 as the Tail."
            },
            {
              "optionId": "ch_viva_2_q14_opt8",
              "optionText": "I push to S1. To dequeue, I pop S1 and push to S2, then pop S2."
            },
            {
              "optionId": "ch_viva_2_q14_opt9",
              "optionText": "I alternate pushing between S1 and S2."
            },
            {
              "optionId": "ch_viva_2_q14_opt10",
              "optionText": "I use recursion to simulate the second stack."
            },
            {
              "optionId": "ch_viva_2_q14_opt11",
              "optionText": "I keep Stack 2 sorted."
            },
            {
              "optionId": "ch_viva_2_q14_opt12",
              "optionText": "I copy S1 to S2 only if S1 is full."
            },
            {
              "optionId": "ch_viva_2_q14_opt13",
              "optionText": "To enqueue, I empty S1 into S2, push new item to S1, move S2 back."
            },
            {
              "optionId": "ch_viva_2_q14_opt14",
              "optionText": "I push to both stacks to keep a backup."
            },
            {
              "optionId": "ch_viva_2_q14_opt15",
              "optionText": "I return `Stack1.pop()`."
            }
          ],
          "correctOptionIds": ["ch_viva_2_q14_opt1", "ch_viva_2_q14_opt2", "ch_viva_2_q14_opt3"],
          "explanationText": "The core idea is that transferring elements from one stack to another reverses their order. By using one stack for input (`InStack`) and one for output (`OutStack`), we achieve FIFO behavior. The transfer operation is $O(N)$, but since each element is transferred only once, the amortized time complexity for both push and pop is $O(1)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_2_q15",
          "questionText": "Sketch an algorithm using a **Stack** to check if a string of parentheses `()[]{}` is balanced.",
          "options": [
            {
              "optionId": "ch_viva_2_q15_opt1",
              "optionText": "I initialize an empty Stack. I loop through chars. If '(', '[', '{', I push it. If ')', ']', '}', I check if stack is empty (return false). Else, I pop. If the popped char doesn't match the current closing bracket type, return False. Finally, return `stack.isEmpty()`."
            },
            {
              "optionId": "ch_viva_2_q15_opt2",
              "optionText": "I use a Stack to store expected closing brackets. If I see `(`, I push `)`. If I see `[`, push `]`. If I see a closing bracket, I pop and compare. If they differ or stack is empty, it's invalid. At end, stack must be empty."
            },
            {
              "optionId": "ch_viva_2_q15_opt3",
              "optionText": "I iterate through the string. Open brackets go onto the Stack. For a closing bracket, I pop the top. If the pair is not a valid match (like `(` and `]`), I fail immediately. Also, if I finish the string and the stack still has items, it's invalid."
            },
            {
              "optionId": "ch_viva_2_q15_opt4",
              "optionText": "I will count the number of open and closed brackets. If counts match, it's valid."
            },
            {
              "optionId": "ch_viva_2_q15_opt5",
              "optionText": "I will use a Queue to match them."
            },
            {
              "optionId": "ch_viva_2_q15_opt6",
              "optionText": "I push everything to the stack and then check if it's a palindrome."
            },
            {
              "optionId": "ch_viva_2_q15_opt7",
              "optionText": "I iterate. If I see an open bracket, push. If closed, pop. If stack is not empty at end, return False."
            },
            {
              "optionId": "ch_viva_2_q15_opt8",
              "optionText": "I split the string in half and compare."
            },
            {
              "optionId": "ch_viva_2_q15_opt9",
              "optionText": "I use two stacks, one for open, one for closed."
            },
            {
              "optionId": "ch_viva_2_q15_opt10",
              "optionText": "I push closed brackets and pop open ones."
            },
            {
              "optionId": "ch_viva_2_q15_opt11",
              "optionText": "If `stack.pop()` returns null, ignore it."
            },
            {
              "optionId": "ch_viva_2_q15_opt12",
              "optionText": "I traverse from both ends inward."
            },
            {
              "optionId": "ch_viva_2_q15_opt13",
              "optionText": "I replace `()` with empty string until string is empty."
            },
            {
              "optionId": "ch_viva_2_q15_opt14",
              "optionText": "I use Regex."
            },
            {
              "optionId": "ch_viva_2_q15_opt15",
              "optionText": "I iterate. If I see open, push. If closed, peek. If peek matches, pop."
            }
          ],
          "correctOptionIds": ["ch_viva_2_q15_opt1", "ch_viva_2_q15_opt2", "ch_viva_2_q15_opt3"],
          "explanationText": "A Stack is ideal for checking nested structures because of its LIFO property (the last bracket opened must be the first one closed). The algorithm must handle three failure conditions: 1) Trying to pop from an empty stack (e.g., `))`), 2) Mismatched types (e.g., `([)]`), and 3) Stack not empty at the end (e.g., `((`).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_3",
      "name": "Tree and Graph Traversal & Structure (Q16-Q20)",
      "questions": [
        {
          "questionId": "ch_viva_3_q16",
          "questionText": "Sketch an algorithm to convert a Graph represented as an **Adjacency Matrix** into an **Adjacency List**.",
          "options": [
            {
              "optionId": "ch_viva_3_q16_opt1",
              "optionText": "I initialize an array of empty Linked Lists, size V. I iterate `i` from 0 to V-1 (rows). Inside, I iterate `j` from 0 to V-1 (cols). If `matrix[i][j] \\ne 0` (edge exists), I add `j` to `List[i]`. Return the array of lists."
            },
            {
              "optionId": "ch_viva_3_q16_opt2",
              "optionText": "I create an `AdjacencyList` structure. I loop through every cell of the matrix. Whenever I encounter a '1' at `[row][col]`, I access the list for `row` and append `col` to it. This filters out the non-edges."
            },
            {
              "optionId": "ch_viva_3_q16_opt3",
              "optionText": "I construct a Map where Key is Vertex ID and Value is a List. I scan the matrix. For every non-zero entry at `(u, v)`, I append `v` to `Map.get(u)`. This efficiently compresses the sparse data."
            },
            {
              "optionId": "ch_viva_3_q16_opt4",
              "optionText": "I will flatten the matrix into a single array."
            },
            {
              "optionId": "ch_viva_3_q16_opt5",
              "optionText": "I will assume the matrix is sparse and use a Hash Map."
            },
            {
              "optionId": "ch_viva_3_q16_opt6",
              "optionText": "I will loop `i` from 0 to N. `List[i] = Matrix[i]`."
            },
            {
              "optionId": "ch_viva_3_q16_opt7",
              "optionText": "I will use BFS to traverse the matrix."
            },
            {
              "optionId": "ch_viva_3_q16_opt8",
              "optionText": "I will swap rows and columns."
            },
            {
              "optionId": "ch_viva_3_q16_opt9",
              "optionText": "I will store the weights in a stack."
            },
            {
              "optionId": "ch_viva_3_q16_opt10",
              "optionText": "I iterate `matrix[i][j]`. If it is 0, I add it to the list."
            },
            {
              "optionId": "ch_viva_3_q16_opt11",
              "optionText": "I create a Linked List for every entry in the matrix."
            },
            {
              "optionId": "ch_viva_3_q16_opt12",
              "optionText": "I iterate `i` and `j`. `List.add(matrix[i][j])`."
            },
            {
              "optionId": "ch_viva_3_q16_opt13",
              "optionText": "I only check the upper triangle of the matrix."
            },
            {
              "optionId": "ch_viva_3_q16_opt14",
              "optionText": "I use a Queue to store neighbors."
            },
            {
              "optionId": "ch_viva_3_q16_opt15",
              "optionText": "I return the matrix as is."
            }
          ],
          "correctOptionIds": ["ch_viva_3_q16_opt1", "ch_viva_3_q16_opt2", "ch_viva_3_q16_opt3"],
          "explanationText": "The conversion requires iterating through the $V \\times V$ matrix. For every non-zero entry at `matrix[i][j]`, an edge exists from vertex `i` to vertex `j`. This means `j` must be added to the adjacency list of `i`. The time complexity is $O(V^2)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_3_q17",
          "questionText": "Sketch an algorithm to **count the number of leaf nodes** in a **Binary Tree**.",
          "options": [
            {
              "optionId": "ch_viva_3_q17_opt1",
              "optionText": "I will use **DFS** (recursion or stack). If `root` is null, return 0. If `root.left` and `root.right` are BOTH null, it is a leaf, return 1. Otherwise, return `count(left) + count(right)`."
            },
            {
              "optionId": "ch_viva_3_q17_opt2",
              "optionText": "I will perform a **Level Order Traversal** using a Queue. I initialize `count = 0`. As I dequeue each node, I check: does it have NO children? If yes, `count++`. If no, enqueue existing children. Return `count`."
            },
            {
              "optionId": "ch_viva_3_q17_opt3",
              "optionText": "I traverse the tree. For every node, I check the 'Leaf Condition': is it childless? If so, I increment my counter. I ensure I visit every node using a standard Stack-based traversal."
            },
            {
              "optionId": "ch_viva_3_q17_opt4",
              "optionText": "I will count all nodes and divide by 2."
            },
            {
              "optionId": "ch_viva_3_q17_opt5",
              "optionText": "I will traverse and count nodes where `next == null`."
            },
            {
              "optionId": "ch_viva_3_q17_opt6",
              "optionText": "I will return the size of the last level."
            },
            {
              "optionId": "ch_viva_3_q17_opt7",
              "optionText": "I will use In-Order traversal and count the first and last node."
            },
            {
              "optionId": "ch_viva_3_q17_opt8",
              "optionText": "I will count nodes that have 1 child."
            },
            {
              "optionId": "ch_viva_3_q17_opt9",
              "optionText": "I will use the height of the tree."
            },
            {
              "optionId": "ch_viva_3_q17_opt10",
              "optionText": "I will check if `node == null`."
            },
            {
              "optionId": "ch_viva_3_q17_opt11",
              "optionText": "I will count nodes where `left \\ne null` OR `right \\ne null`."
            },
            {
              "optionId": "ch_viva_3_q17_opt12",
              "optionText": "I will use an array to store the tree and count empty indices."
            },
            {
              "optionId": "ch_viva_3_q17_opt13",
              "optionText": "I will delete the root until only leaves remain."
            },
            {
              "optionId": "ch_viva_3_q17_opt14",
              "optionText": "I will assume the tree is a Heap."
            },
            {
              "optionId": "ch_viva_3_q17_opt15",
              "optionText": "I will count how many null pointers exist."
            }
          ],
          "correctOptionIds": ["ch_viva_3_q17_opt1", "ch_viva_3_q17_opt2", "ch_viva_3_q17_opt3"],
          "explanationText": "A leaf node is defined as a node where both the left and right children are null. Any full traversal (DFS or BFS) can be used, provided the leaf condition is checked at every node. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_3_q18",
          "questionText": "Sketch an algorithm to find the **height** (max depth) of a **Binary Tree**.",
          "options": [
            {
              "optionId": "ch_viva_3_q18_opt1",
              "optionText": "I will use **Recursion**. Base case: if node is null, return -1 (or 0). Recursive step: `leftH = height(node.left)`, `rightH = height(node.right)`. Return `1 + max(leftH, rightH)`."
            },
            {
              "optionId": "ch_viva_3_q18_opt2",
              "optionText": "I will use **BFS** with a Queue. I initialize `height = 0`. Inside the loop, I record `size = queue.size()`. I process exactly `size` nodes (this clears one level). Then I increment `height`. Repeat until queue empty."
            },
            {
              "optionId": "ch_viva_3_q18_opt3",
              "optionText": "I will use a Stack for DFS, but I will store pairs `(Node, Depth)`. I track a variable `maxDepth`. As I push nodes, I increment their depth. `maxDepth = max(maxDepth, currentDepth)`."
            },
            {
              "optionId": "ch_viva_3_q18_opt4",
              "optionText": "I will count the total number of nodes."
            },
            {
              "optionId": "ch_viva_3_q18_opt5",
              "optionText": "I will go strictly down the left branch."
            },
            {
              "optionId": "ch_viva_3_q18_opt6",
              "optionText": "I will use `height = left.height + right.height`."
            },
            {
              "optionId": "ch_viva_3_q18_opt7",
              "optionText": "I will use In-Order traversal."
            },
            {
              "optionId": "ch_viva_3_q18_opt8",
              "optionText": "I will return `node.value`."
            },
            {
              "optionId": "ch_viva_3_q18_opt9",
              "optionText": "I will subtract min depth from max depth."
            },
            {
              "optionId": "ch_viva_3_q18_opt10",
              "optionText": "I will use a Stack and return stack size."
            },
            {
              "optionId": "ch_viva_3_q18_opt11",
              "optionText": "I will count how many nulls there are."
            },
            {
              "optionId": "ch_viva_3_q18_opt12",
              "optionText": "I will traverse and increment height for every node."
            },
            {
              "optionId": "ch_viva_3_q18_opt13",
              "optionText": "I will check if the tree is AVL."
            },
            {
              "optionId": "ch_viva_3_q18_opt14",
              "optionText": "I will use a fast pointer and slow pointer."
            },
            {
              "optionId": "ch_viva_3_q18_opt15",
              "optionText": "I will use `1 + min(left, right)`."
            }
          ],
          "correctOptionIds": ["ch_viva_3_q18_opt1", "ch_viva_3_q18_opt2", "ch_viva_3_q18_opt3"],
          "explanationText": "Height is the longest path from the root to a leaf. This requires finding the maximum depth among all paths. Both recursive DFS (Option 1) and iterative BFS (Option 2) are $O(N)$ time solutions. BFS is often preferred for finding depth iteratively as it naturally processes level by level.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_3_q19",
          "questionText": "Sketch an algorithm to **print** the values of a Binary Tree **level-by-level** (Breadth-First).",
          "options": [
            {
              "optionId": "ch_viva_3_q19_opt1",
              "optionText": "I will use a **Queue**. Enqueue `root`. While Queue is not empty: `curr = queue.dequeue()`. Print `curr.data`. If `curr.left` exists, enqueue it. If `curr.right` exists, enqueue it."
            },
            {
              "optionId": "ch_viva_3_q19_opt2",
              "optionText": "I implement a standard Breadth-First Search. I start a Queue with the root. In a loop, I process the node at the front of the queue by printing it and adding its children to the back of the queue. This preserves the level order."
            },
            {
              "optionId": "ch_viva_3_q19_opt3",
              "optionText": "I use a Queue. To separate lines for each level, I track the `levelSize` at the start of each loop iteration. I dequeue `levelSize` nodes, printing them on one line, and enqueueing their children. Then I print a newline."
            },
            {
              "optionId": "ch_viva_3_q19_opt4",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_3_q19_opt5",
              "optionText": "I will use In-Order traversal."
            },
            {
              "optionId": "ch_viva_3_q19_opt6",
              "optionText": "I will use an array indices `2i+1`."
            },
            {
              "optionId": "ch_viva_3_q19_opt7",
              "optionText": "I will recurse left then recurse right."
            },
            {
              "optionId": "ch_viva_3_q19_opt8",
              "optionText": "I will print the root, then `root.left`, then `root.right`."
            },
            {
              "optionId": "ch_viva_3_q19_opt9",
              "optionText": "I will use a Priority Queue."
            },
            {
              "optionId": "ch_viva_3_q19_opt10",
              "optionText": "I will use a Hash Map keyed by depth."
            },
            {
              "optionId": "ch_viva_3_q19_opt11",
              "optionText": "I will iterate through the nodes."
            },
            {
              "optionId": "ch_viva_3_q19_opt12",
              "optionText": "I will flatten the tree to a list."
            },
            {
              "optionId": "ch_viva_3_q19_opt13",
              "optionText": "I will print as I delete nodes."
            },
            {
              "optionId": "ch_viva_3_q19_opt14",
              "optionText": "I will use binary search."
            },
            {
              "optionId": "ch_viva_3_q19_opt15",
              "optionText": "I will queue the root, then dequeue it, then stop."
            }
          ],
          "correctOptionIds": ["ch_viva_3_q19_opt1", "ch_viva_3_q19_opt2", "ch_viva_3_q19_opt3"],
          "explanationText": "Breadth-First Search (BFS) naturally processes nodes level by level, making it the required traversal for this task. A Queue is the necessary auxiliary data structure to manage the FIFO order of nodes. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_3_q20",
          "questionText": "Sketch an algorithm to check if an **Array** of integers is a **palindrome** (reads same forwards and backwards).",
          "options": [
            {
              "optionId": "ch_viva_3_q20_opt1",
              "optionText": "I initialize two pointers: `start = 0` and `end = length-1`. I loop while `start < end`. If `array[start] \\ne array[end]`, return False. Else, increment `start`, decrement `end`. If loop finishes, return True."
            },
            {
              "optionId": "ch_viva_3_q20_opt2",
              "optionText": "I iterate from the outside in. I compare the element at index `i` with the element at `len-1-i`. I only need to iterate up to `len/2`. Any mismatch returns False."
            },
            {
              "optionId": "ch_viva_3_q20_opt3",
              "optionText": "I use a Two-Pointer approach. One pointer at the head, one at the tail. I check for equality and move them towards the center. This is $O(N)$ time and $O(1)$ space."
            },
            {
              "optionId": "ch_viva_3_q20_opt4",
              "optionText": "I will use two loops."
            },
            {
              "optionId": "ch_viva_3_q20_opt5",
              "optionText": "I will reverse the array and compare `A == B`."
            },
            {
              "optionId": "ch_viva_3_q20_opt6",
              "optionText": "I will use a Stack to reverse it."
            },
            {
              "optionId": "ch_viva_3_q20_opt7",
              "optionText": "I will check if `array[i] == array[i+1]`."
            },
            {
              "optionId": "ch_viva_3_q20_opt8",
              "optionText": "I will loop from 0 to N and check `array[i] == array[N-i]`."
            },
            {
              "optionId": "ch_viva_3_q20_opt9",
              "optionText": "I will hash the array."
            },
            {
              "optionId": "ch_viva_3_q20_opt10",
              "optionText": "I will split the array in half and swap halves."
            },
            {
              "optionId": "ch_viva_3_q20_opt11",
              "optionText": "I will use recursion without pointers."
            },
            {
              "optionId": "ch_viva_3_q20_opt12",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_3_q20_opt13",
              "optionText": "I will check the first and last elements."
            },
            {
              "optionId": "ch_viva_3_q20_opt14",
              "optionText": "I will loop until `start == end`."
            },
            {
              "optionId": "ch_viva_3_q20_opt15",
              "optionText": "I will return true if `length \\% 2 == 0`."
            }
          ],
          "correctOptionIds": ["ch_viva_3_q20_opt1", "ch_viva_3_q20_opt2", "ch_viva_3_q20_opt3"],
          "explanationText": "The most efficient way to check for array symmetry is the Two-Pointer method, which runs in $O(N)$ time and $O(1)$ space. Pointers start at opposite ends and move inward, comparing elements at each step.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_4",
      "name": "Advanced List and Tree Operations (Q21-Q25)",
      "questions": [
        {
          "questionId": "ch_viva_4_q21",
          "questionText": "Sketch an algorithm to **remove duplicates** from an **Unsorted Singly Linked List**.",
          "options": [
            {
              "optionId": "ch_viva_4_q21_opt1",
              "optionText": "I will use a **Hash Set** to store seen values. I traverse the list with `prev` and `curr` pointers. If `curr.value` is in the Set, I delete it by setting `prev.next = curr.next`. If not, I add it to the Set and move `prev` forward. `curr` moves forward every step."
            },
            {
              "optionId": "ch_viva_4_q21_opt2",
              "optionText": "I initialize an empty Set. I iterate through the Linked List. For each node, I check membership in the Set. If it's a duplicate, I perform a standard deletion by relinking the previous node to the next node. Otherwise, I register the value in the Set."
            },
            {
              "optionId": "ch_viva_4_q21_opt3",
              "optionText": "I maintain a `previous` pointer. As I scan the list, I query a Hash Set. If the current value is new, I add it and update `previous`. If it's a repeat, I skip the current node using `previous.next`, effectively removing it."
            },
            {
              "optionId": "ch_viva_4_q21_opt4",
              "optionText": "I will check if `curr.value == curr.next.value`."
            },
            {
              "optionId": "ch_viva_4_q21_opt5",
              "optionText": "I will use two loops to compare every node."
            },
            {
              "optionId": "ch_viva_4_q21_opt6",
              "optionText": "I will delete the node by setting `curr = null`."
            },
            {
              "optionId": "ch_viva_4_q21_opt7",
              "optionText": "I will sort the list first."
            },
            {
              "optionId": "ch_viva_4_q21_opt8",
              "optionText": "I will use an array to count frequencies."
            },
            {
              "optionId": "ch_viva_4_q21_opt9",
              "optionText": "I will traverse backwards to find duplicates."
            },
            {
              "optionId": "ch_viva_4_q21_opt10",
              "optionText": "I will use a Stack to track numbers."
            },
            {
              "optionId": "ch_viva_4_q21_opt11",
              "optionText": "I will skip the node using `curr = curr.next`."
            },
            {
              "optionId": "ch_viva_4_q21_opt12",
              "optionText": "I will use recursion to delete."
            },
            {
              "optionId": "ch_viva_4_q21_opt13",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_4_q21_opt14",
              "optionText": "I will compare the head with the tail."
            },
            {
              "optionId": "ch_viva_4_q21_opt15",
              "optionText": "I will create a new list and add *all* nodes."
            }
          ],
          "correctOptionIds": ["ch_viva_4_q21_opt1", "ch_viva_4_q21_opt2", "ch_viva_4_q21_opt3"],
          "explanationText": "Since the list is unsorted, the only way to achieve $O(N)$ time complexity is by using a Hash Set to track seen values. The deletion process requires careful management of the `prev` pointer to correctly bypass the duplicate node.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_4_q22",
          "questionText": "Sketch an algorithm to find the **In-Order Successor** of a given node `N` in a **Binary Search Tree**.",
          "options": [
            {
              "optionId": "ch_viva_4_q22_opt1",
              "optionText": "Case 1: If `N` has a right child, I go to the right child, then traverse strictly **left** until I hit null. That node is the successor. Case 2: If `N` has no right child, I start from the **root** and traverse down. I keep a variable `successor`. If `root.val > N.val`, I update `successor = root` and go left. If `root.val < N.val`, I go right. Return `successor`."
            },
            {
              "optionId": "ch_viva_4_q22_opt2",
              "optionText": "I check for a right subtree. If present, the minimum value in that subtree is the answer. If not, I utilize the property that the successor is the lowest ancestor for which the given node falls in the left subtree."
            },
            {
              "optionId": "ch_viva_4_q22_opt3",
              "optionText": "If right child exists: `goRight()`, then `goLeftUntilNull()`. If not: Walk down from root. Every time I go *left*, I save the current node as a potential candidate. The last saved candidate is the successor."
            },
            {
              "optionId": "ch_viva_4_q22_opt4",
              "optionText": "The successor is `node.right`."
            },
            {
              "optionId": "ch_viva_4_q22_opt5",
              "optionText": "The successor is `node.left`."
            },
            {
              "optionId": "ch_viva_4_q22_opt6",
              "optionText": "I will just look at the parent."
            },
            {
              "optionId": "ch_viva_4_q22_opt7",
              "optionText": "I will search for `node.value + 1`."
            },
            {
              "optionId": "ch_viva_4_q22_opt8",
              "optionText": "I will traverse the whole tree and sort it."
            },
            {
              "optionId": "ch_viva_4_q22_opt9",
              "optionText": "I will use Level-Order traversal."
            },
            {
              "optionId": "ch_viva_4_q22_opt10",
              "optionText": "I will return the root."
            },
            {
              "optionId": "ch_viva_4_q22_opt11",
              "optionText": "If it has no right child, it has no successor."
            },
            {
              "optionId": "ch_viva_4_q22_opt12",
              "optionText": "I will check the left child of the right child."
            },
            {
              "optionId": "ch_viva_4_q22_opt13",
              "optionText": "I will use recursion to find the max value."
            },
            {
              "optionId": "ch_viva_4_q22_opt14",
              "optionText": "I will compare with `root` and go down."
            },
            {
              "optionId": "ch_viva_4_q22_opt15",
              "optionText": "I will use a Stack."
            }
          ],
          "correctOptionIds": ["ch_viva_4_q22_opt1", "ch_viva_4_q22_opt2", "ch_viva_4_q22_opt3"],
          "explanationText": "The In-Order Successor is the next largest value. If a right subtree exists, the successor is the minimum element in that subtree. If no right subtree exists, the successor is the lowest ancestor whose left child is the current node (or one of its ancestors). This is an $O(H)$ operation, where $H$ is the height of the tree.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_4_q23",
          "questionText": "Sketch the algorithm for **deleting the root** (Extract-Max) from a **Max-Heap** implemented as an array.",
          "options": [
            {
              "optionId": "ch_viva_4_q23_opt1",
              "optionText": "First, I save the value at `array[0]` to return later. Then, I take the **last** element in the array (`array[size-1]`) and move it to `array[0]`. I decrement the size. Finally, I perform **'Bubble Down'**: compare the new root with its children, swap with the larger child, and repeat until the heap property is restored."
            },
            {
              "optionId": "ch_viva_4_q23_opt2",
              "optionText": "I replace the root with the last leaf node to maintain the 'Complete Tree' structure. Then, I check the new root against its children. If a child is larger, I swap. I continue this process down the tree until the node dominates its children or becomes a leaf."
            },
            {
              "optionId": "ch_viva_4_q23_opt3",
              "optionText": "I overwrite the root with the tail element. Then I 'sink' this element. I calculate indices of Left (`2i+1`) and Right (`2i+2`) children. I swap with the max of the two children if the parent is smaller. Repeat recursively."
            },
            {
              "optionId": "ch_viva_4_q23_opt4",
              "optionText": "I remove the root and move the second element to the top."
            },
            {
              "optionId": "ch_viva_4_q23_opt5",
              "optionText": "I remove the root and shift the array left by 1."
            },
            {
              "optionId": "ch_viva_4_q23_opt6",
              "optionText": "I swap the root with the left child."
            },
            {
              "optionId": "ch_viva_4_q23_opt7",
              "optionText": "I delete the last element."
            },
            {
              "optionId": "ch_viva_4_q23_opt8",
              "optionText": "I search for the max element."
            },
            {
              "optionId": "ch_viva_4_q23_opt9",
              "optionText": "I sort the array."
            },
            {
              "optionId": "ch_viva_4_q23_opt10",
              "optionText": "I swap root with a random leaf."
            },
            {
              "optionId": "ch_viva_4_q23_opt11",
              "optionText": "I recursively delete children."
            },
            {
              "optionId": "ch_viva_4_q23_opt12",
              "optionText": "I bubble up the root."
            },
            {
              "optionId": "ch_viva_4_q23_opt13",
              "optionText": "I insert the new root at the correct spot."
            },
            {
              "optionId": "ch_viva_4_q23_opt14",
              "optionText": "I use a second heap."
            },
            {
              "optionId": "ch_viva_4_q23_opt15",
              "optionText": "I return the root and do nothing else."
            }
          ],
          "correctOptionIds": ["ch_viva_4_q23_opt1", "ch_viva_4_q23_opt2", "ch_viva_4_q23_opt3"],
          "explanationText": "Extracting the root of a heap is an $O(\\log N)$ operation. It involves three steps: 1) Save the root value, 2) Replace the root with the last element (to maintain the complete tree property), and 3) Restore the heap property by 'bubbling down' (or sinking) the new root.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_4_q24",
          "questionText": "Sketch an algorithm to **sort** a **Stack** using only recursion (and the stack itself, no auxiliary data structures like arrays).",
          "options": [
            {
              "optionId": "ch_viva_4_q24_opt1",
              "optionText": "I define `sort(stack)`: If not empty, `pop` element `x`, recursively call `sort(stack)`, then call `sortedInsert(stack, x)`. I define `sortedInsert(stack, x)`: If stack empty or `top < x`, push `x`. Else, `pop` `temp`, recurse `sortedInsert(stack, x)`, then push `temp` back."
            },
            {
              "optionId": "ch_viva_4_q24_opt2",
              "optionText": "I rely on the Call Stack. I strip the stack naked recursively holding values in the function frames. As the recursion unwinds, I re-insert each value into the stack, but I use a helper function to ensure each value is placed deeply enough to maintain order."
            },
            {
              "optionId": "ch_viva_4_q24_opt3",
              "optionText": "I use recursion to hold all values. Base case: Stack empty. Recursive step: Pop item, Sort remaining stack. Then, insert the popped item into the sorted stack at its correct position (which requires a second recursive lookup)."
            },
            {
              "optionId": "ch_viva_4_q24_opt4",
              "optionText": "I will use an array, sort it, and push back."
            },
            {
              "optionId": "ch_viva_4_q24_opt5",
              "optionText": "I will use Bubble Sort on the stack."
            },
            {
              "optionId": "ch_viva_4_q24_opt6",
              "optionText": "I will pop everything, find the min, and push it."
            },
            {
              "optionId": "ch_viva_4_q24_opt7",
              "optionText": "I will use a second stack."
            },
            {
              "optionId": "ch_viva_4_q24_opt8",
              "optionText": "I will swap the top two elements until sorted."
            },
            {
              "optionId": "ch_viva_4_q24_opt9",
              "optionText": "I will use a Priority Queue."
            },
            {
              "optionId": "ch_viva_4_q24_opt10",
              "optionText": "I will assume the stack is sorted."
            },
            {
              "optionId": "ch_viva_4_q24_opt11",
              "optionText": "I will pop elements and push them in sorted order."
            },
            {
              "optionId": "ch_viva_4_q24_opt12",
              "optionText": "I will use QuickSort."
            },
            {
              "optionId": "ch_viva_4_q24_opt13",
              "optionText": "I will reverse the stack."
            },
            {
              "optionId": "ch_viva_4_q24_opt14",
              "optionText": "I will use `Stack.sort()`."
            },
            {
              "optionId": "ch_viva_4_q24_opt15",
              "optionText": "I will print them in sorted order."
            }
          ],
          "correctOptionIds": ["ch_viva_4_q24_opt1", "ch_viva_4_q24_opt2", "ch_viva_4_q24_opt3"],
          "explanationText": "This is a classic recursive sorting problem. It requires two mutually recursive functions: one to empty the stack (`sort`) and one to insert the popped element back into the now-sorted stack while maintaining order (`sortedInsert`). The time complexity is $O(N^2)$ because `sortedInsert` can take $O(N)$ time, and it is called $N$ times.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_4_q25",
          "questionText": "You are given an array containing $N-1$ distinct numbers taken from the range $1$ to $N$. Sketch an algorithm to find the **missing number**.",
          "options": [
            {
              "optionId": "ch_viva_4_q25_opt1",
              "optionText": "I calculate the **Expected Sum** of integers 1 to N using the formula $N(N+1)/2$. Then, I iterate through the array to calculate the **Actual Sum**. The difference `Expected - Actual` is the missing number."
            },
            {
              "optionId": "ch_viva_4_q25_opt2",
              "optionText": "I initialize `sum = 0$. I loop through the array adding values to `sum`. I also compute the mathematical sum of the range 1 to N. Subtracting my calculated array sum from the mathematical sum reveals the missing value in $O(N)$ time and $O(1)$ space."
            },
            {
              "optionId": "ch_viva_4_q25_opt3",
              "optionText": "Alternatively, I can use **XOR**. I XOR all numbers from 1 to N. Then I XOR that result with all elements in the array. The property $A \\oplus A = 0$ means all duplicates cancel out, leaving only the missing number."
            },
            {
              "optionId": "ch_viva_4_q25_opt4",
              "optionText": "I will sort the array and check for gaps."
            },
            {
              "optionId": "ch_viva_4_q25_opt5",
              "optionText": "I will use a boolean array of size N."
            },
            {
              "optionId": "ch_viva_4_q25_opt6",
              "optionText": "I will check if 1 exists, then 2, then 3..."
            },
            {
              "optionId": "ch_viva_4_q25_opt7",
              "optionText": "I will look for the number that isn't there."
            },
            {
              "optionId": "ch_viva_4_q25_opt8",
              "optionText": "I will traverse and see which index is empty."
            },
            {
              "optionId": "ch_viva_4_q25_opt9",
              "optionText": "I will use a Hash Map."
            },
            {
              "optionId": "ch_viva_4_q25_opt10",
              "optionText": "I will use Binary Search."
            },
            {
              "optionId": "ch_viva_4_q25_opt11",
              "optionText": "I will check if the last number is N."
            },
            {
              "optionId": "ch_viva_4_q25_opt12",
              "optionText": "I will add 1 to every element."
            },
            {
              "optionId": "ch_viva_4_q25_opt13",
              "optionText": "I will subtract the first from the last."
            },
            {
              "optionId": "ch_viva_4_q25_opt14",
              "optionText": "I will assume the array is `[1, 2, 3...]`."
            },
            {
              "optionId": "ch_viva_4_q25_opt15",
              "optionText": "I will check for duplicates."
            }
          ],
          "correctOptionIds": ["ch_viva_4_q25_opt1", "ch_viva_4_q25_opt2", "ch_viva_4_q25_opt3"],
          "explanationText": "The most efficient solution is to use the mathematical property of summation (Gauss's formula) or the XOR property. Both methods achieve $O(N)$ time complexity and $O(1)$ space complexity, avoiding the overhead of sorting or auxiliary data structures.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_5",
      "name": "Graph, Circular List, and Array Manipulation (Q26-Q30)",
      "questions": [
        {
          "questionId": "ch_viva_5_q26",
          "questionText": "Sketch an algorithm to determine if there is a **valid path** from Vertex A to Vertex B in a **Directed Graph**.",
          "options": [
            {
              "optionId": "ch_viva_5_q26_opt1",
              "optionText": "I will use **BFS** (Queue) or **DFS** (Stack). I initialize a `Visited` set. Enqueue `A` and mark it visited. While queue not empty: Dequeue `curr`. If `curr == B`, return True. Else, for each neighbor of `curr`, if not visited, Enqueue and mark visited. If queue empties, return False."
            },
            {
              "optionId": "ch_viva_5_q26_opt2",
              "optionText": "I maintain a Set of visited vertices to prevent cycles. Starting at A, I perform a traversal. If I encounter B during the traversal, I immediately return True. If the traversal finishes without seeing B, I return False."
            },
            {
              "optionId": "ch_viva_5_q26_opt3",
              "optionText": "I employ a standard Graph Traversal. I start at the Source. I explore all adjacent neighbors recursively (DFS). I flag every node I enter. If I step onto the Destination node, I propagate a 'True' signal back up the chain."
            },
            {
              "optionId": "ch_viva_5_q26_opt4",
              "optionText": "I will iterate the adjacency matrix rows."
            },
            {
              "optionId": "ch_viva_5_q26_opt5",
              "optionText": "I will check if A is connected to B directly."
            },
            {
              "optionId": "ch_viva_5_q26_opt6",
              "optionText": "I will use DFS without a visited set."
            },
            {
              "optionId": "ch_viva_5_q26_opt7",
              "optionText": "I will calculate the shortest path."
            },
            {
              "optionId": "ch_viva_5_q26_opt8",
              "optionText": "I will reverse the graph."
            },
            {
              "optionId": "ch_viva_5_q26_opt9",
              "optionText": "I will check if they are in the same component."
            },
            {
              "optionId": "ch_viva_5_q26_opt10",
              "optionText": "I will assume it's a tree."
            },
            {
              "optionId": "ch_viva_5_q26_opt11",
              "optionText": "I will check if `A.next == B`."
            },
            {
              "optionId": "ch_viva_5_q26_opt12",
              "optionText": "I will sort the edges."
            },
            {
              "optionId": "ch_viva_5_q26_opt13",
              "optionText": "I will use recursion with a base case."
            },
            {
              "optionId": "ch_viva_5_q26_opt14",
              "optionText": "I will use Union-Find."
            },
            {
              "optionId": "ch_viva_5_q26_opt15",
              "optionText": "I will check the degree of the nodes."
            }
          ],
          "correctOptionIds": ["ch_viva_5_q26_opt1", "ch_viva_5_q26_opt2", "ch_viva_5_q26_opt3"],
          "explanationText": "Path existence (reachability) is solved using standard graph traversal algorithms, BFS or DFS. The critical component is the `Visited` set to prevent infinite loops in the presence of cycles. Time complexity is $O(V+E)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_5_q27",
          "questionText": "Sketch an algorithm to convert a **Doubly Linked List** into a **Circular Doubly Linked List**.",
          "options": [
            {
              "optionId": "ch_viva_5_q27_opt1",
              "optionText": "I take the `head` and `tail` pointers. I set `tail.next = head` (closing the forward loop). I set `head.prev = tail` (closing the backward loop). I return the `head`. Complexity $O(1)$."
            },
            {
              "optionId": "ch_viva_5_q27_opt2",
              "optionText": "I eliminate the null terminations. The last node's 'Next' pointer is updated to point to the first node. The first node's 'Previous' pointer is updated to point to the last node. This creates a bidirectional ring."
            },
            {
              "optionId": "ch_viva_5_q27_opt3",
              "optionText": "If the list is empty, return. If not, I bridge the gap: Link Tail to Head, Link Head to Tail. The list is now circular."
            },
            {
              "optionId": "ch_viva_5_q27_opt4",
              "optionText": "I will set `tail.next = head`."
            },
            {
              "optionId": "ch_viva_5_q27_opt5",
              "optionText": "I will set `head.prev = tail`."
            },
            {
              "optionId": "ch_viva_5_q27_opt6",
              "optionText": "I will create a new circular list and copy nodes."
            },
            {
              "optionId": "ch_viva_5_q27_opt7",
              "optionText": "I will use a loop to connect them."
            },
            {
              "optionId": "ch_viva_5_q27_opt8",
              "optionText": "I will traverse to find the middle."
            },
            {
              "optionId": "ch_viva_5_q27_opt9",
              "optionText": "I will set `head = tail`."
            },
            {
              "optionId": "ch_viva_5_q27_opt10",
              "optionText": "I will delete the null pointers."
            },
            {
              "optionId": "ch_viva_5_q27_opt11",
              "optionText": "I will swap head and tail."
            },
            {
              "optionId": "ch_viva_5_q27_opt12",
              "optionText": "I will use a sentinel node."
            },
            {
              "optionId": "ch_viva_5_q27_opt13",
              "optionText": "I will assume it's already circular."
            },
            {
              "optionId": "ch_viva_5_q27_opt14",
              "optionText": "I will set `node.next = node`."
            },
            {
              "optionId": "ch_viva_5_q27_opt15",
              "optionText": "I will use recursion."
            }
          ],
          "correctOptionIds": ["ch_viva_5_q27_opt1", "ch_viva_5_q27_opt2", "ch_viva_5_q27_opt3"],
          "explanationText": "Converting a Doubly Linked List to a Circular Doubly Linked List is an $O(1)$ operation. It requires two pointer updates: the tail's `next` must point to the head, and the head's `prev` must point to the tail.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_5_q28",
          "questionText": "Sketch an algorithm to **count the number of nodes** in a **Circular Linked List**.",
          "options": [
            {
              "optionId": "ch_viva_5_q28_opt1",
              "optionText": "I handle the empty case (return 0). Else, I initialize `count = 1` and `curr = head.next`. I loop while `curr \\ne head`. Inside, `count++` and `curr = curr.next`. Return `count`."
            },
            {
              "optionId": "ch_viva_5_q28_opt2",
              "optionText": "I mark the starting point (`head`). I traverse the list, incrementing a counter for each step. I stop the traversal exactly when my pointer lands back on the `head` reference."
            },
            {
              "optionId": "ch_viva_5_q28_opt3",
              "optionText": "I initialize `temp = head`. Do-While loop: move `temp` forward, increment count. Condition: `while temp \\ne head`. This ensures I count the list exactly once."
            },
            {
              "optionId": "ch_viva_5_q28_opt4",
              "optionText": "I loop until `curr == null`."
            },
            {
              "optionId": "ch_viva_5_q28_opt5",
              "optionText": "I loop until `curr.next == null`."
            },
            {
              "optionId": "ch_viva_5_q28_opt6",
              "optionText": "I count for 100 iterations."
            },
            {
              "optionId": "ch_viva_5_q28_opt7",
              "optionText": "I use a Hash Set to count unique nodes."
            },
            {
              "optionId": "ch_viva_5_q28_opt8",
              "optionText": "I start at head and loop. `count++`."
            },
            {
              "optionId": "ch_viva_5_q28_opt9",
              "optionText": "I check if `head == tail`."
            },
            {
              "optionId": "ch_viva_5_q28_opt10",
              "optionText": "I use recursion."
            },
            {
              "optionId": "ch_viva_5_q28_opt11",
              "optionText": "I break the circle then count."
            },
            {
              "optionId": "ch_viva_5_q28_opt12",
              "optionText": "I return `list.size`."
            },
            {
              "optionId": "ch_viva_5_q28_opt13",
              "optionText": "I use two pointers."
            },
            {
              "optionId": "ch_viva_5_q28_opt14",
              "optionText": "I assume size is stored in head."
            },
            {
              "optionId": "ch_viva_5_q28_opt15",
              "optionText": "I count until `curr.value` repeats."
            }
          ],
          "correctOptionIds": ["ch_viva_5_q28_opt1", "ch_viva_5_q28_opt2", "ch_viva_5_q28_opt3"],
          "explanationText": "Since a circular list has no null termination, the traversal must stop when the pointer returns to the starting node (`head`). The `do-while` loop (Option 3) is often the most elegant way to ensure the loop executes at least once for a non-empty list. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_5_q29",
          "questionText": "Sketch an algorithm to **reverse a string** using a **Stack**.",
          "options": [
            {
              "optionId": "ch_viva_5_q29_opt1",
              "optionText": "I create an empty Stack. I iterate over the string, pushing each **character** onto the Stack. Then, I create a StringBuilder (or char array). While Stack is not empty, I `pop` the character and append it to the builder. Return the built string."
            },
            {
              "optionId": "ch_viva_5_q29_opt2",
              "optionText": "I exploit the LIFO property. First pass: read string left-to-right, pushing characters. Second pass: pop characters (which come out right-to-left) and construct the new string."
            },
            {
              "optionId": "ch_viva_5_q29_opt3",
              "optionText": "I transfer the string data into a Stack. Since the last character entered is the first one retrieved, simply emptying the Stack into a new buffer produces the reversed string."
            },
            {
              "optionId": "ch_viva_5_q29_opt4",
              "optionText": "I push the string, then pop the string."
            },
            {
              "optionId": "ch_viva_5_q29_opt5",
              "optionText": "I use a Queue."
            },
            {
              "optionId": "ch_viva_5_q29_opt6",
              "optionText": "I swap the first and last characters."
            },
            {
              "optionId": "ch_viva_5_q29_opt7",
              "optionText": "I use recursion."
            },
            {
              "optionId": "ch_viva_5_q29_opt8",
              "optionText": "I push half the string."
            },
            {
              "optionId": "ch_viva_5_q29_opt9",
              "optionText": "I use an array."
            },
            {
              "optionId": "ch_viva_5_q29_opt10",
              "optionText": "I traverse backwards."
            },
            {
              "optionId": "ch_viva_5_q29_opt11",
              "optionText": "I push chars, then peek."
            },
            {
              "optionId": "ch_viva_5_q29_opt12",
              "optionText": "I push words, not chars."
            },
            {
              "optionId": "ch_viva_5_q29_opt13",
              "optionText": "I use `string.reverse()`."
            },
            {
              "optionId": "ch_viva_5_q29_opt14",
              "optionText": "I pop before pushing."
            },
            {
              "optionId": "ch_viva_5_q29_opt15",
              "optionText": "I use two stacks."
            }
          ],
          "correctOptionIds": ["ch_viva_5_q29_opt1", "ch_viva_5_q29_opt2", "ch_viva_5_q29_opt3"],
          "explanationText": "The LIFO property of a Stack is perfectly suited for reversal. By pushing characters in order and popping them out, the order is naturally inverted. This is an $O(N)$ time and $O(N)$ space operation.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_5_q30",
          "questionText": "Sketch an algorithm to find the **minimum element** in a **Sorted Array that has been Rotated** (e.g., `[4, 5, 1, 2, 3]`).",
          "options": [
            {
              "optionId": "ch_viva_5_q30_opt1",
              "optionText": "I use **Binary Search**. `Lo=0`, `Hi=len-1`. Loop while `Lo < Hi`. `Mid = (Lo+Hi)/2`. If `arr[mid] > arr[Hi]`, the min is in the **right** half (`Lo = Mid + 1`). Else, min is in **left** half or is mid (`Hi = Mid`). Return `arr[Lo]`."
            },
            {
              "optionId": "ch_viva_5_q30_opt2",
              "optionText": "I perform a logarithmic search. I compare the middle element to the right-most element. If the middle is larger, the 'reset point' (minimum) must be to the right. Otherwise, it's to the left. I narrow the range until one element remains."
            },
            {
              "optionId": "ch_viva_5_q30_opt3",
              "optionText": "I detect the inflection point using Binary Search. The inflection point is the only place where `Element(i) > Element(i+1)`. I adjust my bounds to hone in on this drop."
            },
            {
              "optionId": "ch_viva_5_q30_opt4",
              "optionText": "I will iterate and find the min."
            },
            {
              "optionId": "ch_viva_5_q30_opt5",
              "optionText": "I will sort the array."
            },
            {
              "optionId": "ch_viva_5_q30_opt6",
              "optionText": "I will use standard Binary Search looking for 0."
            },
            {
              "optionId": "ch_viva_5_q30_opt7",
              "optionText": "I will check if `arr[0] < arr[last]`."
            },
            {
              "optionId": "ch_viva_5_q30_opt8",
              "optionText": "I will split the array in half and check mins recursively."
            },
            {
              "optionId": "ch_viva_5_q30_opt9",
              "optionText": "I will use a Hash Set."
            },
            {
              "optionId": "ch_viva_5_q30_opt10",
              "optionText": "I will compare `mid` with `left`."
            },
            {
              "optionId": "ch_viva_5_q30_opt11",
              "optionText": "I will stop when `mid == target`."
            },
            {
              "optionId": "ch_viva_5_q30_opt12",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_5_q30_opt13",
              "optionText": "I will swap elements back to sorted."
            },
            {
              "optionId": "ch_viva_5_q30_opt14",
              "optionText": "I will return `arr[0]`."
            },
            {
              "optionId": "ch_viva_5_q30_opt15",
              "optionText": "I will check neighbors of mid only."
            }
          ],
          "correctOptionIds": ["ch_viva_5_q30_opt1", "ch_viva_5_q30_opt2", "ch_viva_5_q30_opt3"],
          "explanationText": "Since the array is partially sorted, we can use a modified Binary Search to find the minimum element in $O(\\log N)$ time. The key is comparing the middle element with the rightmost element to determine which half contains the 'dip' (the minimum).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_6",
      "name": "Tree Structure and Serialization (Q31-Q35)",
      "questions": [
        {
          "questionId": "ch_viva_6_q31",
          "questionText": "Sketch an algorithm to **invert** (mirror) a **Binary Tree**.",
          "options": [
            {
              "optionId": "ch_viva_6_q31_opt1",
              "optionText": "I use **Recursion**. Base case: if node is null, return. Recursive step: `invert(node.left)`, `invert(node.right)`. Then, perform the swap: `temp = node.left`, `node.left = node.right`, `node.right = temp`."
            },
            {
              "optionId": "ch_viva_6_q31_opt2",
              "optionText": "I use **Iterative BFS** (Queue). Enqueue root. While queue not empty: Dequeue node. Swap its left and right pointers. If left exists, enqueue it. If right exists, enqueue it. Return root."
            },
            {
              "optionId": "ch_viva_6_q31_opt3",
              "optionText": "I perform a recursive Post-Order traversal. I visit the left child, then the right child. Once the recursion returns, I swap the left and right pointers of the current node. This propagates the inversion from bottom to top."
            },
            {
              "optionId": "ch_viva_6_q31_opt4",
              "optionText": "I will swap the root's left and right children."
            },
            {
              "optionId": "ch_viva_6_q31_opt5",
              "optionText": "I will traverse In-Order and swap."
            },
            {
              "optionId": "ch_viva_6_q31_opt6",
              "optionText": "I will swap nodes with same values."
            },
            {
              "optionId": "ch_viva_6_q31_opt7",
              "optionText": "I will create a new tree and insert nodes in reverse order."
            },
            {
              "optionId": "ch_viva_6_q31_opt8",
              "optionText": "I will use a Stack to reverse the node values."
            },
            {
              "optionId": "ch_viva_6_q31_opt9",
              "optionText": "I will rotate the tree left."
            },
            {
              "optionId": "ch_viva_6_q31_opt10",
              "optionText": "I will sort the tree descending."
            },
            {
              "optionId": "ch_viva_6_q31_opt11",
              "optionText": "I will swap leaf nodes only."
            },
            {
              "optionId": "ch_viva_6_q31_opt12",
              "optionText": "I will change the pointers to point up."
            },
            {
              "optionId": "ch_viva_6_q31_opt13",
              "optionText": "I will mirror the array representation."
            },
            {
              "optionId": "ch_viva_6_q31_opt14",
              "optionText": "I will swap left.left with right.right."
            },
            {
              "optionId": "ch_viva_6_q31_opt15",
              "optionText": "I will use binary search."
            }
          ],
          "correctOptionIds": ["ch_viva_6_q31_opt1", "ch_viva_6_q31_opt2", "ch_viva_6_q31_opt3"],
          "explanationText": "Inverting a tree requires swapping the left and right children of *every* node. This can be achieved recursively (DFS, Options 1, 3) or iteratively (BFS, Option 2). The time complexity is $O(N)$ as every node is visited exactly once.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_6_q32",
          "questionText": "Sketch an algorithm to **serialize** a Binary Tree into a **String**.",
          "options": [
            {
              "optionId": "ch_viva_6_q32_opt1",
              "optionText": "I use **Pre-Order Traversal** (DFS). If node is null, append `#` to string. Else, append `node.val` + `,`. Then recurse left, then recurse right. The string captures the structure uniquely."
            },
            {
              "optionId": "ch_viva_6_q32_opt2",
              "optionText": "I use **Level-Order Traversal** (Queue). I enqueue the root. When I dequeue a node, if it is null, I append `null`. If it is real, I append its value and enqueue its children (even if they are null). This creates an array-like representation."
            },
            {
              "optionId": "ch_viva_6_q32_opt3",
              "optionText": "I build a string recursively. I define the structure as `Root(Left,Right)`. If a child is missing, I write `()`. This recursive bracket notation preserves the hierarchy."
            },
            {
              "optionId": "ch_viva_6_q32_opt4",
              "optionText": "I will perform In-Order traversal and save values."
            },
            {
              "optionId": "ch_viva_6_q32_opt5",
              "optionText": "I will save just the values in a list."
            },
            {
              "optionId": "ch_viva_6_q32_opt6",
              "optionText": "I will save root, then leaves."
            },
            {
              "optionId": "ch_viva_6_q32_opt7",
              "optionText": "I will use a Hash Map."
            },
            {
              "optionId": "ch_viva_6_q32_opt8",
              "optionText": "I will save the height and width."
            },
            {
              "optionId": "ch_viva_6_q32_opt9",
              "optionText": "I will convert it to a Heap array."
            },
            {
              "optionId": "ch_viva_6_q32_opt10",
              "optionText": "I will save `node.value` string."
            },
            {
              "optionId": "ch_viva_6_q32_opt11",
              "optionText": "I will ignore null nodes."
            },
            {
              "optionId": "ch_viva_6_q32_opt12",
              "optionText": "I will use BFS but skip nulls."
            },
            {
              "optionId": "ch_viva_6_q32_opt13",
              "optionText": "I will save parent pointers."
            },
            {
              "optionId": "ch_viva_6_q32_opt14",
              "optionText": "I will print the tree."
            },
            {
              "optionId": "ch_viva_6_q32_opt15",
              "optionText": "I will sort the values."
            }
          ],
          "correctOptionIds": ["ch_viva_6_q32_opt1", "ch_viva_6_q32_opt2", "ch_viva_6_q32_opt3"],
          "explanationText": "Serialization requires capturing the tree's structure uniquely so it can be reconstructed. This necessitates recording null pointers. Pre-Order (DFS) and Level-Order (BFS) are the standard methods, both running in $O(N)$ time.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_6_q33",
          "questionText": "Sketch an algorithm to move all **zeros** in an integer array to the **end**, while maintaining the relative order of non-zero elements.",
          "options": [
            {
              "optionId": "ch_viva_6_q33_opt1",
              "optionText": "I use a **`writeIndex`** initialized to 0. I loop through the array. If `array[i] \\ne 0`, I set `array[writeIndex] = array[i]` and increment `writeIndex`. After the loop, I fill indices from `writeIndex` to end with `0`."
            },
            {
              "optionId": "ch_viva_6_q33_opt2",
              "optionText": "I maintain a pointer for the 'Last Non-Zero Found'. I iterate through the array. When I find a non-zero, I swap it with the element at the 'Last Non-Zero' pointer and advance that pointer. This bubbles non-zeros to the front and zeros to the back."
            },
            {
              "optionId": "ch_viva_6_q33_opt3",
              "optionText": "I treat the array as a queue. I iterate through. If I see a non-zero, I move it to the first available 'slot' (tracked by a counter). I don't care what happens to the zeros initially. Finally, I overwrite the remaining tail slots with 0."
            },
            {
              "optionId": "ch_viva_6_q33_opt4",
              "optionText": "I will sort the array."
            },
            {
              "optionId": "ch_viva_6_q33_opt5",
              "optionText": "I will create a new array, copy non-zeros, then fill zeros."
            },
            {
              "optionId": "ch_viva_6_q33_opt6",
              "optionText": "I will loop and swap zeros with the last element."
            },
            {
              "optionId": "ch_viva_6_q33_opt7",
              "optionText": "I will delete zeros."
            },
            {
              "optionId": "ch_viva_6_q33_opt8",
              "optionText": "I will use a Stack for non-zeros."
            },
            {
              "optionId": "ch_viva_6_q33_opt9",
              "optionText": "I will use Bubble Sort logic."
            },
            {
              "optionId": "ch_viva_6_q33_opt10",
              "optionText": "I will search for 0 and shift the whole array left."
            },
            {
              "optionId": "ch_viva_6_q33_opt11",
              "optionText": "I will use two pointers at start and end."
            },
            {
              "optionId": "ch_viva_6_q33_opt12",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_6_q33_opt13",
              "optionText": "I will replace zeros with -1."
            },
            {
              "optionId": "ch_viva_6_q33_opt14",
              "optionText": "I will rotate the array."
            },
            {
              "optionId": "ch_viva_6_q33_opt15",
              "optionText": "I will count zeros and restart the array."
            }
          ],
          "correctOptionIds": ["ch_viva_6_q33_opt1", "ch_viva_6_q33_opt2", "ch_viva_6_q33_opt3"],
          "explanationText": "The requirement to maintain the relative order of non-zero elements necessitates an $O(N)$ time, $O(1)$ space in-place solution. The 'write index' or 'snowball' method (Option 1) achieves this by effectively overwriting the array with non-zeros first, then filling the remaining space with zeros.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_6_q34",
          "questionText": "Sketch an algorithm to check if two Strings are **valid anagrams** of each other.",
          "options": [
            {
              "optionId": "ch_viva_6_q34_opt1",
              "optionText": "I use a **Frequency Map** (or integer array size 26). I iterate String A, incrementing counts for each char. I iterate String B, decrementing counts. Finally, I check if all counts are zero. If yes, True."
            },
            {
              "optionId": "ch_viva_6_q34_opt2",
              "optionText": "I create two Hash Maps. I populate them with character frequencies from String A and String B respectively. I then compare if `MapA.equals(MapB)`. Return the result."
            },
            {
              "optionId": "ch_viva_6_q34_opt3",
              "optionText": "I verify lengths match. Then I sort both strings alphabetically. I iterate through the sorted arrays comparing index `i`. If any mismatch found, return False. Else True."
            },
            {
              "optionId": "ch_viva_6_q34_opt4",
              "optionText": "I will sort both strings and compare."
            },
            {
              "optionId": "ch_viva_6_q34_opt5",
              "optionText": "I will check if they have the same length."
            },
            {
              "optionId": "ch_viva_6_q34_opt6",
              "optionText": "I will check if they contain the same characters."
            },
            {
              "optionId": "ch_viva_6_q34_opt7",
              "optionText": "I will sum the ASCII values."
            },
            {
              "optionId": "ch_viva_6_q34_opt8",
              "optionText": "I will multiply the ASCII values."
            },
            {
              "optionId": "ch_viva_6_q34_opt9",
              "optionText": "I will use a Set."
            },
            {
              "optionId": "ch_viva_6_q34_opt10",
              "optionText": "I will iterate nested loops."
            },
            {
              "optionId": "ch_viva_6_q34_opt11",
              "optionText": "I will reverse one string."
            },
            {
              "optionId": "ch_viva_6_q34_opt12",
              "optionText": "I will remove chars from String B as I find them in String A."
            },
            {
              "optionId": "ch_viva_6_q34_opt13",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_6_q34_opt14",
              "optionText": "I will check first and last chars."
            },
            {
              "optionId": "ch_viva_6_q34_opt15",
              "optionText": "I will use a Stack."
            }
          ],
          "correctOptionIds": ["ch_viva_6_q34_opt1", "ch_viva_6_q34_opt2", "ch_viva_6_q34_opt3"],
          "explanationText": "Anagrams are permutations, meaning they must have the exact same character counts. The most efficient method is using a frequency map/array ($O(N)$ time). Sorting is also valid but slower ($O(N \\log N)$).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_6_q35",
          "questionText": "Sketch an algorithm to find the node where two **Singly Linked Lists intersect** (merge).",
          "options": [
            {
              "optionId": "ch_viva_6_q35_opt1",
              "optionText": "I calculate the **length** of List A and List B. I calculate the difference `d`. I advance the pointer of the longer list by `d` steps. Now both pointers are equidistant from the end. I move both forward until `ptrA == ptrB`. Return that node."
            },
            {
              "optionId": "ch_viva_6_q35_opt2",
              "optionText": "I traverse List A and insert all nodes (references) into a **Hash Set**. Then I traverse List B. The first node from B that already exists in the Set is the intersection point."
            },
            {
              "optionId": "ch_viva_6_q35_opt3",
              "optionText": "I use the **Two Pointer Switch** trick. Pointers `pA` and `pB`. Traverse. When `pA` reaches end, redirect it to Head B. When `pB` reaches end, redirect to Head A. They will meet at the intersection after 1 extra pass."
            },
            {
              "optionId": "ch_viva_6_q35_opt4",
              "optionText": "I will iterate both lists until values match."
            },
            {
              "optionId": "ch_viva_6_q35_opt5",
              "optionText": "I will use a hash map for values."
            },
            {
              "optionId": "ch_viva_6_q35_opt6",
              "optionText": "I will check if tails are different."
            },
            {
              "optionId": "ch_viva_6_q35_opt7",
              "optionText": "I will iterate `i` and `j`."
            },
            {
              "optionId": "ch_viva_6_q35_opt8",
              "optionText": "I will reverse both lists."
            },
            {
              "optionId": "ch_viva_6_q35_opt9",
              "optionText": "I will traverse one list, then the other."
            },
            {
              "optionId": "ch_viva_6_q35_opt10",
              "optionText": "I will compare heads."
            },
            {
              "optionId": "ch_viva_6_q35_opt11",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_6_q35_opt12",
              "optionText": "I will assume same length."
            },
            {
              "optionId": "ch_viva_6_q35_opt13",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_6_q35_opt14",
              "optionText": "I will add lists values together."
            },
            {
              "optionId": "ch_viva_6_q35_opt15",
              "optionText": "I will use Tortoise and Hare."
            }
          ],
          "correctOptionIds": ["ch_viva_6_q35_opt1", "ch_viva_6_q35_opt2", "ch_viva_6_q35_opt3"],
          "explanationText": "The intersection point is found by aligning the starting points of the two lists. The length difference method (Option 1) is $O(N)$ time and $O(1)$ space. The Hash Set method (Option 2) is $O(N)$ time but $O(N)$ space. The Two Pointer Switch (Option 3) is a clever $O(N)$ time, $O(1)$ space solution.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_7",
      "name": "Advanced Graph and Tree Properties (Q36-Q40)",
      "questions": [
        {
          "questionId": "ch_viva_7_q36",
          "questionText": "Sketch an algorithm to **Deep Clone** a Graph (given a starting node).",
          "options": [
            {
              "optionId": "ch_viva_7_q36_opt1",
              "optionText": "I use **BFS** with a Queue and a **Hash Map** mapping `Original -> Clone`. Enqueue start. Create clone, put in Map. While queue not empty: Dequeue `u`. For each neighbor `v`: If `v` not in Map, clone it, map it, enqueue it. Link `Map[u].neighbors.add(Map[v])`."
            },
            {
              "optionId": "ch_viva_7_q36_opt2",
              "optionText": "I use **DFS** (Recursion). Function `clone(node)`: If `node` is in Map, return `Map[node]`. Else, create `newNode`, add to Map. For each neighbor, `newNode.neighbors.add(clone(neighbor))`. Return `newNode`."
            },
            {
              "optionId": "ch_viva_7_q36_opt3",
              "optionText": "I traverse the graph. I maintain a registry (Map) of copied nodes. For every node I encounter, I check the registry. If it exists, I use the existing copy. If not, I mint a fresh copy and register it before processing its edges."
            },
            {
              "optionId": "ch_viva_7_q36_opt4",
              "optionText": "I will just return the reference to the start node."
            },
            {
              "optionId": "ch_viva_7_q36_opt5",
              "optionText": "I will iterate and create new nodes."
            },
            {
              "optionId": "ch_viva_7_q36_opt6",
              "optionText": "I will use BFS but no map."
            },
            {
              "optionId": "ch_viva_7_q36_opt7",
              "optionText": "I will use recursion without visited set."
            },
            {
              "optionId": "ch_viva_7_q36_opt8",
              "optionText": "I will copy the adjacency matrix."
            },
            {
              "optionId": "ch_viva_7_q36_opt9",
              "optionText": "I will serialize and deserialize."
            },
            {
              "optionId": "ch_viva_7_q36_opt10",
              "optionText": "I will create a new graph object."
            },
            {
              "optionId": "ch_viva_7_q36_opt11",
              "optionText": "I will copy values only."
            },
            {
              "optionId": "ch_viva_7_q36_opt12",
              "optionText": "I will use Dijkstra."
            },
            {
              "optionId": "ch_viva_7_q36_opt13",
              "optionText": "I will assume it is a tree."
            },
            {
              "optionId": "ch_viva_7_q36_opt14",
              "optionText": "I will clone neighbors first."
            },
            {
              "optionId": "ch_viva_7_q36_opt15",
              "optionText": "I will use an array."
            }
          ],
          "correctOptionIds": ["ch_viva_7_q36_opt1", "ch_viva_7_q36_opt2", "ch_viva_7_q36_opt3"],
          "explanationText": "Deep cloning a graph requires two things: 1) Creating a new node for every original node, and 2) Using a Hash Map to link the original nodes to their clones. This map prevents infinite recursion/loops when cycles are encountered and ensures that shared nodes are only cloned once. Time complexity is $O(V+E)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_7_q37",
          "questionText": "Sketch an algorithm to find the **Lowest Common Ancestor (LCA)** of two nodes in a **Binary Search Tree**.",
          "options": [
            {
              "optionId": "ch_viva_7_q37_opt1",
              "optionText": "Since it's a **BST**, I start at Root. I compare `p.val` and `q.val` with `root.val`. If both are smaller than root, I move `root = root.left`. If both are larger, `root = root.right`. If they split (one smaller, one larger) or one equals root, **this** root is the LCA. Return it."
            },
            {
              "optionId": "ch_viva_7_q37_opt2",
              "optionText": "I use Iteration. `curr = root`. While `curr` is not null: if `p` and `q` are both > `curr`, go right. If both < `curr`, go left. Else, break and return `curr`. This works because the LCA is the split point."
            },
            {
              "optionId": "ch_viva_7_q37_opt3",
              "optionText": "I use Recursion. If `root.val` > max(p, q), return `LCA(root.left)`. If `root.val` < min(p, q), return `LCA(root.right)`. Otherwise, we found the split point, return `root`."
            },
            {
              "optionId": "ch_viva_7_q37_opt4",
              "optionText": "I will search for both nodes."
            },
            {
              "optionId": "ch_viva_7_q37_opt5",
              "optionText": "I will return the root."
            },
            {
              "optionId": "ch_viva_7_q37_opt6",
              "optionText": "I will use BFS."
            },
            {
              "optionId": "ch_viva_7_q37_opt7",
              "optionText": "I will store paths to both nodes and compare."
            },
            {
              "optionId": "ch_viva_7_q37_opt8",
              "optionText": "I will use the parent pointers."
            },
            {
              "optionId": "ch_viva_7_q37_opt9",
              "optionText": "I will find the node with max value."
            },
            {
              "optionId": "ch_viva_7_q37_opt10",
              "optionText": "I will check if `left == right`."
            },
            {
              "optionId": "ch_viva_7_q37_opt11",
              "optionText": "I will use Dijkstra."
            },
            {
              "optionId": "ch_viva_7_q37_opt12",
              "optionText": "I will calculate depth."
            },
            {
              "optionId": "ch_viva_7_q37_opt13",
              "optionText": "I will use In-Order traversal."
            },
            {
              "optionId": "ch_viva_7_q37_opt14",
              "optionText": "I will start from leaves and go up."
            },
            {
              "optionId": "ch_viva_7_q37_opt15",
              "optionText": "I will check `root.left` and `root.right`."
            }
          ],
          "correctOptionIds": ["ch_viva_7_q37_opt1", "ch_viva_7_q37_opt2", "ch_viva_7_q37_opt3"],
          "explanationText": "For a BST, the LCA is the first node encountered during traversal from the root where the two target nodes lie in different subtrees (one left, one right). This property allows for an efficient $O(H)$ time, $O(1)$ space solution, where $H$ is the height of the tree.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_7_q38",
          "questionText": "Sketch an algorithm to find the **Diameter** (longest path between any two nodes) of a Binary Tree.",
          "options": [
            {
              "optionId": "ch_viva_7_q38_opt1",
              "optionText": "I define a recursive function `getHeight(node)`. It returns `1 + max(leftH, rightH)`. Inside this function, before returning, I update a global variable `maxDiameter = max(maxDiameter, leftH + rightH)`. This checks the path through *every* node."
            },
            {
              "optionId": "ch_viva_7_q38_opt2",
              "optionText": "I use DFS. At every node, I compute the depth of the left and right branches. The potential diameter through *this* node is `leftDepth + rightDepth`. I verify if this is the new maximum. Then I return the max depth to the parent."
            },
            {
              "optionId": "ch_viva_7_q38_opt3",
              "optionText": "I treat every node as a potential 'turning point' (anchor) of the path. I calculate the longest arms extending from each node. The maximum sum of two arms found anywhere in the tree is the diameter."
            },
            {
              "optionId": "ch_viva_7_q38_opt4",
              "optionText": "I will return `height(left) + height(right)`."
            },
            {
              "optionId": "ch_viva_7_q38_opt5",
              "optionText": "I will find the two deepest leaves and measure distance."
            },
            {
              "optionId": "ch_viva_7_q38_opt6",
              "optionText": "I will use BFS to find width."
            },
            {
              "optionId": "ch_viva_7_q38_opt7",
              "optionText": "I will sum all edges."
            },
            {
              "optionId": "ch_viva_7_q38_opt8",
              "optionText": "I will use Dijkstra from root."
            },
            {
              "optionId": "ch_viva_7_q38_opt9",
              "optionText": "I will check left-most and right-most nodes."
            },
            {
              "optionId": "ch_viva_7_q38_opt10",
              "optionText": "I will simply calculate height."
            },
            {
              "optionId": "ch_viva_7_q38_opt11",
              "optionText": "I will traverse In-Order."
            },
            {
              "optionId": "ch_viva_7_q38_opt12",
              "optionText": "I will use a matrix."
            },
            {
              "optionId": "ch_viva_7_q38_opt13",
              "optionText": "I will modify the tree."
            },
            {
              "optionId": "ch_viva_7_q38_opt14",
              "optionText": "I will return `max(left, right) + 1`."
            },
            {
              "optionId": "ch_viva_7_q38_opt15",
              "optionText": "I will assume the tree is balanced."
            }
          ],
          "correctOptionIds": ["ch_viva_7_q38_opt1", "ch_viva_7_q38_opt2", "ch_viva_7_q38_opt3"],
          "explanationText": "The diameter is the longest path between any two nodes. This path may or may not pass through the root. The efficient $O(N)$ solution involves calculating the height of the left and right subtrees at every node and updating a global maximum diameter with the sum of those two heights.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_7_q39",
          "questionText": "Sketch an algorithm to check if a Binary Tree is **Symmetric** (a mirror of itself around the center).",
          "options": [
            {
              "optionId": "ch_viva_7_q39_opt1",
              "optionText": "I define a helper `isMirror(node1, node2)`. If both null, True. If one null, False. If values differ, False. Else, return `isMirror(node1.left, node2.right)` AND `isMirror(node1.right, node2.left)`. Call this on `root.left` and `root.right`."
            },
            {
              "optionId": "ch_viva_7_q39_opt2",
              "optionText": "I use an Iterative approach with a Queue. I enqueue `root.left` and `root.right`. Loop: Dequeue `u` and `v`. Check equality. Enqueue `u.left, v.right` (Outers) and `u.right, v.left` (Inners). If mismatch, return False."
            },
            {
              "optionId": "ch_viva_7_q39_opt3",
              "optionText": "I verify symmetry by checking: 1. Roots match. 2. The left subtree is a mirror reflection of the right subtree. This requires recursive cross-comparison of children."
            },
            {
              "optionId": "ch_viva_7_q39_opt4",
              "optionText": "I will check if `root.left == root.right`."
            },
            {
              "optionId": "ch_viva_7_q39_opt5",
              "optionText": "I will check if left subtree is same as right subtree."
            },
            {
              "optionId": "ch_viva_7_q39_opt6",
              "optionText": "I will use In-Order traversal and check palindrome."
            },
            {
              "optionId": "ch_viva_7_q39_opt7",
              "optionText": "I will invert the left subtree and compare with right."
            },
            {
              "optionId": "ch_viva_7_q39_opt8",
              "optionText": "I will check if `left.key == right.key` recursively."
            },
            {
              "optionId": "ch_viva_7_q39_opt9",
              "optionText": "I will use a Stack for one side."
            },
            {
              "optionId": "ch_viva_7_q39_opt10",
              "optionText": "I will count nodes on both sides."
            },
            {
              "optionId": "ch_viva_7_q39_opt11",
              "optionText": "I will check height balance."
            },
            {
              "optionId": "ch_viva_7_q39_opt12",
              "optionText": "I will assume it is a heap."
            },
            {
              "optionId": "ch_viva_7_q39_opt13",
              "optionText": "I will compare root with leaves."
            },
            {
              "optionId": "ch_viva_7_q39_opt14",
              "optionText": "I will use BFS queue."
            },
            {
              "optionId": "ch_viva_7_q39_opt15",
              "optionText": "I will return False."
            }
          ],
          "correctOptionIds": ["ch_viva_7_q39_opt1", "ch_viva_7_q39_opt2", "ch_viva_7_q39_opt3"],
          "explanationText": "Symmetry requires a recursive comparison of the left and right subtrees, but with cross-checking: the left child of the left subtree must match the right child of the right subtree, and vice versa. This is an $O(N)$ operation.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_7_q40",
          "questionText": "Sketch an algorithm to **flatten** a Binary Tree into a **Linked List** in-place (following Pre-Order `Root-Left-Right`).",
          "options": [
            {
              "optionId": "ch_viva_7_q40_opt1",
              "optionText": "I use Recursion. `flatten(root)`. 1. Flatten Left and Right subtrees. 2. Store `root.right` in `temp`. 3. Move `root.left` to `root.right`. 4. Set `root.left` to null. 5. Traverse to the *end* of the new right list. 6. Attach `temp` to the end."
            },
            {
              "optionId": "ch_viva_7_q40_opt2",
              "optionText": "I use a Stack. Push Root. While stack not empty: Pop `curr`. If `curr.right` exists, push it. If `curr.left` exists, push it. Link `curr.right` to `stack.peek()` (the next node in Pre-Order). Set `curr.left` to null."
            },
            {
              "optionId": "ch_viva_7_q40_opt3",
              "optionText": "I iterate down the right spine. If a node has a left child, I find the right-most node of that left child (predecessor). I connect that predecessor to the current node's right child. Then I move the whole left subtree to the right."
            },
            {
              "optionId": "ch_viva_7_q40_opt4",
              "optionText": "I will create a new Linked List."
            },
            {
              "optionId": "ch_viva_7_q40_opt5",
              "optionText": "I will set `root.right = root.left`."
            },
            {
              "optionId": "ch_viva_7_q40_opt6",
              "optionText": "I will use a Stack to print."
            },
            {
              "optionId": "ch_viva_7_q40_opt7",
              "optionText": "I will set `left = null`."
            },
            {
              "optionId": "ch_viva_7_q40_opt8",
              "optionText": "I will traverse In-Order."
            },
            {
              "optionId": "ch_viva_7_q40_opt9",
              "optionText": "I will swap left and right."
            },
            {
              "optionId": "ch_viva_7_q40_opt10",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_7_q40_opt11",
              "optionText": "I will delete the tree."
            },
            {
              "optionId": "ch_viva_7_q40_opt12",
              "optionText": "I will put all nodes in an array."
            },
            {
              "optionId": "ch_viva_7_q40_opt13",
              "optionText": "I will link `node.next`."
            },
            {
              "optionId": "ch_viva_7_q40_opt14",
              "optionText": "I will start from leaves."
            },
            {
              "optionId": "ch_viva_7_q40_opt15",
              "optionText": "I will use recursion without fixing pointers."
            }
          ],
          "correctOptionIds": ["ch_viva_7_q40_opt1", "ch_viva_7_q40_opt2", "ch_viva_7_q40_opt3"],
          "explanationText": "Flattening a tree in-place requires complex pointer manipulation to ensure the original right subtree is correctly appended to the end of the newly flattened left subtree. Both recursive (Option 1) and iterative (Option 2, using a stack to manage the Pre-Order sequence) solutions are $O(N)$ time.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_8",
      "name": "List, Array, and Tree Search (Q41-Q45)",
      "questions": [
        {
          "questionId": "ch_viva_8_q41",
          "questionText": "Sketch an algorithm to find the **Kth Smallest** element in a **Binary Search Tree**.",
          "options": [
            {
              "optionId": "ch_viva_8_q41_opt1",
              "optionText": "I will use an **Iterative In-Order Traversal** with a Stack. I push nodes going left. Then, I pop a node and increment a counter. If `counter == K`, I return that node's value. Else, I go right."
            },
            {
              "optionId": "ch_viva_8_q41_opt2",
              "optionText": "I define a recursive function `inOrder(node)`. It traverses left first. I maintain a global counter. Every time I visit a node (after returning from left), I decrement K. When `K == 0`, I record the result and stop recursion."
            },
            {
              "optionId": "ch_viva_8_q41_opt3",
              "optionText": "I perform a simulation of sorted reading. I descend to the leftmost node (minimum). I then trace the 'next' successor path $K-1$ times. The node I land on is the answer."
            },
            {
              "optionId": "ch_viva_8_q41_opt4",
              "optionText": "I will use BFS and return the Kth element."
            },
            {
              "optionId": "ch_viva_8_q41_opt5",
              "optionText": "I will go Left K times."
            },
            {
              "optionId": "ch_viva_8_q41_opt6",
              "optionText": "I will collect all nodes in an array and return `array[K-1]`."
            },
            {
              "optionId": "ch_viva_8_q41_opt7",
              "optionText": "I will use a Min-Heap."
            },
            {
              "optionId": "ch_viva_8_q41_opt8",
              "optionText": "I will use Pre-Order traversal."
            },
            {
              "optionId": "ch_viva_8_q41_opt9",
              "optionText": "I will search for value `K`."
            },
            {
              "optionId": "ch_viva_8_q41_opt10",
              "optionText": "I will modify the tree to count children."
            },
            {
              "optionId": "ch_viva_8_q41_opt11",
              "optionText": "I will start from the max and go backwards."
            },
            {
              "optionId": "ch_viva_8_q41_opt12",
              "optionText": "I will check `root.left.left...`."
            },
            {
              "optionId": "ch_viva_8_q41_opt13",
              "optionText": "I will return the Kth level."
            },
            {
              "optionId": "ch_viva_8_q41_opt14",
              "optionText": "I will assume the tree is balanced."
            },
            {
              "optionId": "ch_viva_8_q41_opt15",
              "optionText": "I will use recursion without a counter."
            }
          ],
          "correctOptionIds": ["ch_viva_8_q41_opt1", "ch_viva_8_q41_opt2", "ch_viva_8_q41_opt3"],
          "explanationText": "The In-Order traversal of a BST yields elements in sorted order. The most efficient solution is to perform an In-Order traversal (recursively or iteratively) and stop immediately after visiting the $K$-th node. This is $O(H + K)$ time, where $H$ is the height, and $O(H)$ space (for the stack).",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_8_q42",
          "questionText": "Sketch an algorithm to **insert** a new node with value `V` into a **Sorted Singly Linked List** while maintaining sorted order.",
          "options": [
            {
              "optionId": "ch_viva_8_q42_opt1",
              "optionText": "I handle the Head case: If `head` is null or `head.val \\ge V`, I insert at start and update head. Else, I traverse with `curr`. I look ahead: while `curr.next` is not null and `curr.next.val < V`, I move forward. Then I insert `newNode` between `curr` and `curr.next`."
            },
            {
              "optionId": "ch_viva_8_q42_opt2",
              "optionText": "I maintain `prev` and `curr` pointers. I iterate until I find a node `curr` where `curr.val > V`. I insert `newNode` between `prev` and `curr`. If `prev` is null, I update head. If `curr` is null, I append to tail."
            },
            {
              "optionId": "ch_viva_8_q42_opt3",
              "optionText": "I scan the list to find the 'gap'. The gap is the first position where the next value exceeds `V`. I perform a standard pointer splice at that gap."
            },
            {
              "optionId": "ch_viva_8_q42_opt4",
              "optionText": "I will just append to the tail."
            },
            {
              "optionId": "ch_viva_8_q42_opt5",
              "optionText": "I will sort the list after insertion."
            },
            {
              "optionId": "ch_viva_8_q42_opt6",
              "optionText": "I will swap values until it fits."
            },
            {
              "optionId": "ch_viva_8_q42_opt7",
              "optionText": "I will check `curr.val == V`."
            },
            {
              "optionId": "ch_viva_8_q42_opt8",
              "optionText": "I will start from the middle."
            },
            {
              "optionId": "ch_viva_8_q42_opt9",
              "optionText": "I will use Binary Search."
            },
            {
              "optionId": "ch_viva_8_q42_opt10",
              "optionText": "I will insert at head if `head > V` then stop."
            },
            {
              "optionId": "ch_viva_8_q42_opt11",
              "optionText": "I will use `curr.prev`."
            },
            {
              "optionId": "ch_viva_8_q42_opt12",
              "optionText": "I will use a second list."
            },
            {
              "optionId": "ch_viva_8_q42_opt13",
              "optionText": "I will traverse until `curr > V`."
            },
            {
              "optionId": "ch_viva_8_q42_opt14",
              "optionText": "I will insert it randomly."
            },
            {
              "optionId": "ch_viva_8_q42_opt15",
              "optionText": "I will check neighbors."
            }
          ],
          "correctOptionIds": ["ch_viva_8_q42_opt1", "ch_viva_8_q42_opt2", "ch_viva_8_q42_opt3"],
          "explanationText": "Insertion into a sorted linked list requires finding the correct position by traversing the list. Since it's a singly linked list, you must either track the previous node (`prev`) or look ahead (`curr.next`) to perform the insertion splice correctly. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_8_q43",
          "questionText": "Sketch an algorithm to **delete all even numbers** from a Singly Linked List.",
          "options": [
            {
              "optionId": "ch_viva_8_q43_opt1",
              "optionText": "First, I handle the Head: while `head` is not null and even, `head = head.next`. Then, I traverse with `curr`. While `curr.next` is not null: if `curr.next.val` is even, I bypass it (`curr.next = curr.next.next`). Else, I advance `curr`. Return head."
            },
            {
              "optionId": "ch_viva_8_q43_opt2",
              "optionText": "I use a 'Sentinel' or 'Dummy' node pointing to head. This simplifies edge cases. I traverse using `prev` (starts at dummy) and `curr` (starts at head). If `curr` is even, `prev.next = curr.next`. Else `prev = curr`. Move `curr` forward. Return `dummy.next`."
            },
            {
              "optionId": "ch_viva_8_q43_opt3",
              "optionText": "I iterate through the list. I aggressively prune 'next' nodes. If the upcoming node is even, I snip it out immediately and check the *new* upcoming node (without advancing). Only when the upcoming node is odd do I step forward."
            },
            {
              "optionId": "ch_viva_8_q43_opt4",
              "optionText": "I will verify if `curr \\% 2 == 0` and set `curr = null`."
            },
            {
              "optionId": "ch_viva_8_q43_opt5",
              "optionText": "I will iterate and set `curr.next = curr.next.next`."
            },
            {
              "optionId": "ch_viva_8_q43_opt6",
              "optionText": "I will make a new list with odds."
            },
            {
              "optionId": "ch_viva_8_q43_opt7",
              "optionText": "I will traverse backwards."
            },
            {
              "optionId": "ch_viva_8_q43_opt8",
              "optionText": "I will assume head is odd."
            },
            {
              "optionId": "ch_viva_8_q43_opt9",
              "optionText": "I will use `curr.prev`."
            },
            {
              "optionId": "ch_viva_8_q43_opt10",
              "optionText": "I will delete the node and move `curr`."
            },
            {
              "optionId": "ch_viva_8_q43_opt11",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_8_q43_opt12",
              "optionText": "I will replace values with 0."
            },
            {
              "optionId": "ch_viva_8_q43_opt13",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_8_q43_opt14",
              "optionText": "I will stop at the first even."
            },
            {
              "optionId": "ch_viva_8_q43_opt15",
              "optionText": "I will use two pointers but forget head update."
            }
          ],
          "correctOptionIds": ["ch_viva_8_q43_opt1", "ch_viva_8_q43_opt2", "ch_viva_8_q43_opt3"],
          "explanationText": "Deletion in a singly linked list requires tracking the previous node to perform the relinking. The primary challenge is handling the head node if it is even. Using a dummy node (Option 2) or handling the head separately (Option 1) simplifies the logic. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_8_q44",
          "questionText": "Sketch an algorithm to **rotate** a Singly Linked List to the right by $K$ places.",
          "options": [
            {
              "optionId": "ch_viva_8_q44_opt1",
              "optionText": "I traverse to find the length `Len` and the `Tail`. I set $K = K \\% Len$. If $K=0$ return head. I connect `Tail.next = Head` (forming a ring). Then I traverse `Len - K` steps from the connection. I set the new head, and break the ring (`newTail.next = null`)."
            },
            {
              "optionId": "ch_viva_8_q44_opt2",
              "optionText": "I visualize the list as a ring. I close the ring first. Then I shift my starting point (Head) forward by `Length - K` steps. I cut the ring just before this new Head."
            },
            {
              "optionId": "ch_viva_8_q44_opt3",
              "optionText": "I find the pivot point. The new tail is at index $Len - K - 1$. The new head is `newTail.next`. I set `oldTail.next = oldHead` and `newTail.next = null`. Return `newHead`."
            },
            {
              "optionId": "ch_viva_8_q44_opt4",
              "optionText": "I will move the tail to head $K$ times."
            },
            {
              "optionId": "ch_viva_8_q44_opt5",
              "optionText": "I will use an array."
            },
            {
              "optionId": "ch_viva_8_q44_opt6",
              "optionText": "I will swap values."
            },
            {
              "optionId": "ch_viva_8_q44_opt7",
              "optionText": "I will pointer arithmetic."
            },
            {
              "optionId": "ch_viva_8_q44_opt8",
              "optionText": "I will reverse the list."
            },
            {
              "optionId": "ch_viva_8_q44_opt9",
              "optionText": "I will start from the Kth node."
            },
            {
              "optionId": "ch_viva_8_q44_opt10",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_8_q44_opt11",
              "optionText": "I will ignore $K > N$."
            },
            {
              "optionId": "ch_viva_8_q44_opt12",
              "optionText": "I will split the list and swap halves."
            },
            {
              "optionId": "ch_viva_8_q44_opt13",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_8_q44_opt14",
              "optionText": "I will use Doubly list logic."
            },
            {
              "optionId": "ch_viva_8_q44_opt15",
              "optionText": "I will return null."
            }
          ],
          "correctOptionIds": ["ch_viva_8_q44_opt1", "ch_viva_8_q44_opt2", "ch_viva_8_q44_opt3"],
          "explanationText": "The most efficient solution is to first calculate the length, handle the modulo $K$, form a temporary circle, and then break the circle at the new tail position. This is an $O(N)$ time, $O(1)$ space operation.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_8_q45",
          "questionText": "Sketch an algorithm to return **all root-to-leaf paths** in a Binary Tree (as a list of strings `1->2->5`).",
          "options": [
            {
              "optionId": "ch_viva_8_q45_opt1",
              "optionText": "I use **DFS** (Recursion). The function takes a Node and a String `path`. I append `node.val` to `path`. If leaf, add `path` to result list. Else, recurse left with `path`, recurse right with `path`. Strings are immutable so backtracking is handled automatically."
            },
            {
              "optionId": "ch_viva_8_q45_opt2",
              "optionText": "I use an Iterative DFS with **two Stacks**. One for Nodes, one for `PathStrings`. When I push a child node, I also push `currentPath + \"->\" + child.val`. If I pop a leaf, I store the path string."
            },
            {
              "optionId": "ch_viva_8_q45_opt3",
              "optionText": "I build paths incrementally. As I descend, I construct the lineage of the node. When the descent hits a leaf node, I commit the current lineage to the final records."
            },
            {
              "optionId": "ch_viva_8_q45_opt4",
              "optionText": "I will use BFS."
            },
            {
              "optionId": "ch_viva_8_q45_opt5",
              "optionText": "I will only print the path."
            },
            {
              "optionId": "ch_viva_8_q45_opt6",
              "optionText": "I will use a global string."
            },
            {
              "optionId": "ch_viva_8_q45_opt7",
              "optionText": "I will traverse In-Order."
            },
            {
              "optionId": "ch_viva_8_q45_opt8",
              "optionText": "I will use a single list and remove items."
            },
            {
              "optionId": "ch_viva_8_q45_opt9",
              "optionText": "I will return the longest path."
            },
            {
              "optionId": "ch_viva_8_q45_opt10",
              "optionText": "I will store nodes in a Hash Map."
            },
            {
              "optionId": "ch_viva_8_q45_opt11",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_8_q45_opt12",
              "optionText": "I will start from leaves."
            },
            {
              "optionId": "ch_viva_8_q45_opt13",
              "optionText": "I will check for cycles."
            },
            {
              "optionId": "ch_viva_8_q45_opt14",
              "optionText": "I will use Dijkstra."
            },
            {
              "optionId": "ch_viva_8_q45_opt15",
              "optionText": "I will append `node` to string."
            }
          ],
          "correctOptionIds": ["ch_viva_8_q45_opt1", "ch_viva_8_q45_opt2", "ch_viva_8_q45_opt3"],
          "explanationText": "Finding all paths requires a Depth-First Search (DFS) approach, as it naturally explores one path completely before backtracking. Recursion (Option 1) is the most common method, using the call stack for implicit backtracking. The time complexity is $O(N \\cdot L)$, where $L$ is the average path length, due to string concatenation.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_viva_9",
      "name": "Advanced Graph and Stream Algorithms (Q46-Q50)",
      "questions": [
        {
          "questionId": "ch_viva_9_q46",
          "questionText": "Sketch an algorithm to find the **max depth** of an **N-ary Tree** (each node has a list of children).",
          "options": [
            {
              "optionId": "ch_viva_9_q46_opt1",
              "optionText": "I use **Recursion**. Base case: if children list is empty, return 1 (or 0). Else, initialize `max = 0$. Loop through all children: `max = Math.max(max, depth(child))`. Return `max + 1`."
            },
            {
              "optionId": "ch_viva_9_q46_opt2",
              "optionText": "I use **BFS** to count levels. I use a Queue. I keep a `level` counter. At the start of the outer loop, I capture `size = queue.size()`. I process that many nodes (adding all their children). Increment level. Repeat."
            },
            {
              "optionId": "ch_viva_9_q46_opt3",
              "optionText": "I traverse the tree. For every node, I poll all its subtrees to find the deepest one. I take that maximum depth and add one for the current node."
            },
            {
              "optionId": "ch_viva_9_q46_opt4",
              "optionText": "I will return `1 + children.size()`."
            },
            {
              "optionId": "ch_viva_9_q46_opt5",
              "optionText": "I will check `child[0]` and `child[last]`."
            },
            {
              "optionId": "ch_viva_9_q46_opt6",
              "optionText": "I will use binary tree logic."
            },
            {
              "optionId": "ch_viva_9_q46_opt7",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_9_q46_opt8",
              "optionText": "I will use BFS and return queue size."
            },
            {
              "optionId": "ch_viva_9_q46_opt9",
              "optionText": "I will count total nodes."
            },
            {
              "optionId": "ch_viva_9_q46_opt10",
              "optionText": "I will assume children are sorted by height."
            },
            {
              "optionId": "ch_viva_9_q46_opt11",
              "optionText": "I will use an array."
            },
            {
              "optionId": "ch_viva_9_q46_opt12",
              "optionText": "I will add 1 for every child."
            },
            {
              "optionId": "ch_viva_9_q46_opt13",
              "optionText": "I will return 0."
            },
            {
              "optionId": "ch_viva_9_q46_opt14",
              "optionText": "I will delete nodes."
            },
            {
              "optionId": "ch_viva_9_q46_opt15",
              "optionText": "I will use In-Order."
            }
          ],
          "correctOptionIds": ["ch_viva_9_q46_opt1", "ch_viva_9_q46_opt2", "ch_viva_9_q46_opt3"],
          "explanationText": "Finding the max depth in an N-ary tree is a generalization of the binary tree height problem. Recursion (DFS) is the most natural fit, requiring a loop over all children to find the maximum depth among them. BFS is also a valid iterative approach. Time complexity is $O(N)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_9_q47",
          "questionText": "Sketch an algorithm to check if an undirected Graph is **Bipartite** (can be colored with 2 colors such that no edge connects same colors).",
          "options": [
            {
              "optionId": "ch_viva_9_q47_opt1",
              "optionText": "I use **BFS** with a `Colors` array (0=Uncolored, 1=Red, 2=Blue). Loop all nodes (to handle disconnected). If uncolored, queue it and color Red. While queue not empty: Dequeue `u`. For neighbor `v`: If uncolored, color it opposite of `u` and enqueue. If colored same as `u`, return False."
            },
            {
              "optionId": "ch_viva_9_q47_opt2",
              "optionText": "I simulate a 2-coloring process. I paint the starting node Black. I enforce that all neighbors must be White. I propagate this constraint. If I ever find a neighbor that is already painted the 'wrong' color, I conclude it's impossible (not Bipartite)."
            },
            {
              "optionId": "ch_viva_9_q47_opt3",
              "optionText": "I traverse the graph. I maintain two sets: Set A and Set B. For every edge `(u, v)`, if `u` is in A, `v` must be in B. If I find a conflict where both ends of an edge fall in Set A, it fails."
            },
            {
              "optionId": "ch_viva_9_q47_opt4",
              "optionText": "I will check if the number of nodes is even."
            },
            {
              "optionId": "ch_viva_9_q47_opt5",
              "optionText": "I will check if it has cycles."
            },
            {
              "optionId": "ch_viva_9_q47_opt6",
              "optionText": "I will use DFS and check back-edges."
            },
            {
              "optionId": "ch_viva_9_q47_opt7",
              "optionText": "I will check vertex degrees."
            },
            {
              "optionId": "ch_viva_9_q47_opt8",
              "optionText": "I will count edges."
            },
            {
              "optionId": "ch_viva_9_q47_opt9",
              "optionText": "I will use Dijkstra."
            },
            {
              "optionId": "ch_viva_9_q47_opt10",
              "optionText": "I will use Union-Find."
            },
            {
              "optionId": "ch_viva_9_q47_opt11",
              "optionText": "I will color randomly."
            },
            {
              "optionId": "ch_viva_9_q47_opt12",
              "optionText": "I will split nodes into two sets randomly."
            },
            {
              "optionId": "ch_viva_9_q47_opt13",
              "optionText": "I will check if the graph is connected."
            },
            {
              "optionId": "ch_viva_9_q47_opt14",
              "optionText": "I will assume it is a tree."
            },
            {
              "optionId": "ch_viva_9_q47_opt15",
              "optionText": "I will use a Stack."
            }
          ],
          "correctOptionIds": ["ch_viva_9_q47_opt1", "ch_viva_9_q47_opt2", "ch_viva_9_q47_opt3"],
          "explanationText": "A graph is bipartite if and only if it contains no odd-length cycles. The most straightforward way to check this is using BFS (or DFS) with a 2-coloring scheme. If a neighbor is found to have the same color as the current node, an odd cycle exists, and the graph is not bipartite. Time complexity is $O(V+E)$.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_9_q48",
          "questionText": "Sketch an algorithm to efficiently find the **median** of a stream of integers.",
          "options": [
            {
              "optionId": "ch_viva_9_q48_opt1",
              "optionText": "I use **Two Heaps**: a `low` Max-Heap and a `high` Min-Heap. I balance them so their sizes differ by at most 1. New numbers go into `low`, then `low`'s max moves to `high` (to sort). If `high` is too big, move min back to `low`. Median is the top of the larger heap or average of both tops."
            },
            {
              "optionId": "ch_viva_9_q48_opt2",
              "optionText": "I maintain two halves of the dataset. The lower half is kept in a structure that gives me the maximum instantly. The upper half gives me the minimum instantly. The median sits at the boundary of these two structures."
            },
            {
              "optionId": "ch_viva_9_q48_opt3",
              "optionText": "I insert elements into a sorted structure (like two balanced heaps). I ensure the count of elements in both halves remains equal. The median is derived from the boundary elements."
            },
            {
              "optionId": "ch_viva_9_q48_opt4",
              "optionText": "I will sort the array every time."
            },
            {
              "optionId": "ch_viva_9_q48_opt5",
              "optionText": "I will use a Linked List and find middle."
            },
            {
              "optionId": "ch_viva_9_q48_opt6",
              "optionText": "I will use a BST."
            },
            {
              "optionId": "ch_viva_9_q48_opt7",
              "optionText": "I will average the min and max."
            },
            {
              "optionId": "ch_viva_9_q48_opt8",
              "optionText": "I will use a Hash Map."
            },
            {
              "optionId": "ch_viva_9_q48_opt9",
              "optionText": "I will use a single Heap."
            },
            {
              "optionId": "ch_viva_9_q48_opt10",
              "optionText": "I will use a Queue."
            },
            {
              "optionId": "ch_viva_9_q48_opt11",
              "optionText": "I will use just an array."
            },
            {
              "optionId": "ch_viva_9_q48_opt12",
              "optionText": "I will randomly sample."
            },
            {
              "optionId": "ch_viva_9_q48_opt13",
              "optionText": "I will swap elements."
            },
            {
              "optionId": "ch_viva_9_q48_opt14",
              "optionText": "I will use pointers."
            },
            {
              "optionId": "ch_viva_9_q48_opt15",
              "optionText": "I will use a Stack."
            }
          ],
          "correctOptionIds": ["ch_viva_9_q48_opt1", "ch_viva_9_q48_opt2", "ch_viva_9_q48_opt3"],
          "explanationText": "The Two-Heap approach is the standard optimal solution for finding the median in a data stream. It ensures that insertion and median retrieval are both $O(\\log N)$ operations, as opposed to $O(N)$ or $O(N \\log N)$ if using arrays or sorting repeatedly.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_9_q49",
          "questionText": "Sketch an algorithm to check if a string is a **palindrome**, ignoring non-alphanumeric characters.",
          "options": [
            {
              "optionId": "ch_viva_9_q49_opt1",
              "optionText": "I use **Two Pointers** (Head, Tail). Loop `Head < Tail`. Inside, I run small while loops: `while Head is symbol, Head++` and `while Tail is symbol, Tail--`. Then compare characters (case-insensitive). If match, advance both. Else return False."
            },
            {
              "optionId": "ch_viva_9_q49_opt2",
              "optionText": "I scan from both ends. If I encounter a non-letter, I skip it. When both pointers rest on valid letters, I compare them. Mismatch implies false. Meeting in the middle implies true."
            },
            {
              "optionId": "ch_viva_9_q49_opt3",
              "optionText": "I iterate inwards. I effectively ignore any character that isn't a digit or letter by advancing my pointers past them dynamically. This allows me to verify the palindrome property in-place."
            },
            {
              "optionId": "ch_viva_9_q49_opt4",
              "optionText": "I will replace all symbols using Regex."
            },
            {
              "optionId": "ch_viva_9_q49_opt5",
              "optionText": "I will create a new clean string."
            },
            {
              "optionId": "ch_viva_9_q49_opt6",
              "optionText": "I will skip only spaces."
            },
            {
              "optionId": "ch_viva_9_q49_opt7",
              "optionText": "I will check char codes."
            },
            {
              "optionId": "ch_viva_9_q49_opt8",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_9_q49_opt9",
              "optionText": "I will compare index `i` and `N-i`."
            },
            {
              "optionId": "ch_viva_9_q49_opt10",
              "optionText": "I will reverse and compare."
            },
            {
              "optionId": "ch_viva_9_q49_opt11",
              "optionText": "I will use hashing."
            },
            {
              "optionId": "ch_viva_9_q49_opt12",
              "optionText": "I will use recursion."
            },
            {
              "optionId": "ch_viva_9_q49_opt13",
              "optionText": "I will sort it."
            },
            {
              "optionId": "ch_viva_9_q49_opt14",
              "optionText": "I will delete symbols."
            },
            {
              "optionId": "ch_viva_9_q49_opt15",
              "optionText": "I will assume clean input."
            }
          ],
          "correctOptionIds": ["ch_viva_9_q49_opt1", "ch_viva_9_q49_opt2", "ch_viva_9_q49_opt3"],
          "explanationText": "The optimal solution uses the Two-Pointer technique, running in $O(N)$ time and $O(1)$ space. The key is to use inner loops to advance the pointers past any non-alphanumeric characters before performing the comparison.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_viva_9_q50",
          "questionText": "Sketch an algorithm to **evaluate** a mathematical **Expression Tree** (Leafs are numbers, Internal nodes are operators `+ - * /`).",
          "options": [
            {
              "optionId": "ch_viva_9_q50_opt1",
              "optionText": "I use **Recursion**. Base case: If node is Leaf, return its value. Recursive step: `leftVal = eval(node.left)`, `rightVal = eval(node.right)`. Then apply `node.operator` to `leftVal` and `rightVal`. Return the result."
            },
            {
              "optionId": "ch_viva_9_q50_opt2",
              "optionText": "I perform a Post-Order traversal. I compute the result of the left subtree and the right subtree first. Once I have those two numbers, I combine them using the operation stored in the current node."
            },
            {
              "optionId": "ch_viva_9_q50_opt3",
              "optionText": "I collapse the tree from bottom up. Leaves return numbers. Operator nodes wait for their children to return numbers, then perform the math and return the result up to *their* parent."
            },
            {
              "optionId": "ch_viva_9_q50_opt4",
              "optionText": "I will use In-Order traversal."
            },
            {
              "optionId": "ch_viva_9_q50_opt5",
              "optionText": "I will use BFS."
            },
            {
              "optionId": "ch_viva_9_q50_opt6",
              "optionText": "I will return the root value."
            },
            {
              "optionId": "ch_viva_9_q50_opt7",
              "optionText": "I will use a Stack."
            },
            {
              "optionId": "ch_viva_9_q50_opt8",
              "optionText": "I will add all leaves."
            },
            {
              "optionId": "ch_viva_9_q50_opt9",
              "optionText": "I will assume the tree is a heap."
            },
            {
              "optionId": "ch_viva_9_q50_opt10",
              "optionText": "I will multiply the height."
            },
            {
              "optionId": "ch_viva_9_q50_opt11",
              "optionText": "I will swap operands."
            },
            {
              "optionId": "ch_viva_9_q50_opt12",
              "optionText": "I will flatten to a list."
            },
            {
              "optionId": "ch_viva_9_q50_opt13",
              "optionText": "I will check for cycles."
            },
            {
              "optionId": "ch_viva_9_q50_opt14",
              "optionText": "I will use Dijkstra."
            },
            {
              "optionId": "ch_viva_9_q50_opt15",
              "optionText": "I will return 0."
            }
          ],
          "correctOptionIds": ["ch_viva_9_q50_opt1", "ch_viva_9_q50_opt2", "ch_viva_9_q50_opt3"],
          "explanationText": "Evaluating an expression tree requires a Post-Order traversal (Left, Right, Root). This ensures that the operands (numbers in the leaves) are evaluated before the operator (in the internal node) is applied. Recursion is the most straightforward way to implement this, running in $O(N)$ time.",
          "type": "mcq",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 5,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}
