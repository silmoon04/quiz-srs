{
  "batchIndex": 13,
  "questions": [
    {
      "chapterIndex": 6,
      "questionIndex": 4,
      "questionId": "ch_viva_7_q40",
      "questionText": "Sketch an algorithm to **flatten** a Binary Tree into a **Linked List** in-place (following Pre-Order `Root-Left-Right`).",
      "options": [
        {
          "optionId": "ch_viva_7_q40_opt1",
          "optionText": "I use Recursion. `flatten(root)`. 1. Flatten Left and Right subtrees. 2. Store `root.right` in `temp`. 3. Move `root.left` to `root.right`. 4. Set `root.left` to null. 5. Traverse to the *end* of the new right list. 6. Attach `temp` to the end."
        },
        {
          "optionId": "ch_viva_7_q40_opt2",
          "optionText": "I use a Stack. Push Root. While stack not empty: Pop `curr`. If `curr.right` exists, push it. If `curr.left` exists, push it. Link `curr.right` to `stack.peek()` (the next node in Pre-Order). Set `curr.left` to null."
        },
        {
          "optionId": "ch_viva_7_q40_opt3",
          "optionText": "I iterate down the right spine. If a node has a left child, I find the right-most node of that left child (predecessor). I connect that predecessor to the current node's right child. Then I move the whole left subtree to the right."
        },
        {
          "optionId": "ch_viva_7_q40_opt4",
          "optionText": "I will create a new Linked List."
        },
        {
          "optionId": "ch_viva_7_q40_opt5",
          "optionText": "I will set `root.right = root.left`."
        },
        {
          "optionId": "ch_viva_7_q40_opt6",
          "optionText": "I will use a Stack to print."
        },
        {
          "optionId": "ch_viva_7_q40_opt7",
          "optionText": "I will set `left = null`."
        },
        {
          "optionId": "ch_viva_7_q40_opt8",
          "optionText": "I will traverse In-Order."
        },
        {
          "optionId": "ch_viva_7_q40_opt9",
          "optionText": "I will swap left and right."
        },
        {
          "optionId": "ch_viva_7_q40_opt10",
          "optionText": "I will use a Queue."
        },
        {
          "optionId": "ch_viva_7_q40_opt11",
          "optionText": "I will delete the tree."
        },
        {
          "optionId": "ch_viva_7_q40_opt12",
          "optionText": "I will put all nodes in an array."
        },
        {
          "optionId": "ch_viva_7_q40_opt13",
          "optionText": "I will link `node.next`."
        },
        {
          "optionId": "ch_viva_7_q40_opt14",
          "optionText": "I will start from leaves."
        },
        {
          "optionId": "ch_viva_7_q40_opt15",
          "optionText": "I will use recursion without fixing pointers."
        }
      ],
      "correctOptionIds": ["ch_viva_7_q40_opt1", "ch_viva_7_q40_opt2", "ch_viva_7_q40_opt3"],
      "explanationText": "Flattening a tree in-place requires complex pointer manipulation to ensure the original right subtree is correctly appended to the end of the newly flattened left subtree. Both recursive (Option 1) and iterative (Option 2, using a stack to manage the Pre-Order sequence) solutions are $O(N)$ time."
    },
    {
      "chapterIndex": 7,
      "questionIndex": 0,
      "questionId": "ch_viva_8_q41",
      "questionText": "Sketch an algorithm to find the **Kth Smallest** element in a **Binary Search Tree**.",
      "options": [
        {
          "optionId": "ch_viva_8_q41_opt1",
          "optionText": "I will use an **Iterative In-Order Traversal** with a Stack. I push nodes going left. Then, I pop a node and increment a counter. If `counter == K`, I return that node's value. Else, I go right."
        },
        {
          "optionId": "ch_viva_8_q41_opt2",
          "optionText": "I define a recursive function `inOrder(node)`. It traverses left first. I maintain a global counter. Every time I visit a node (after returning from left), I decrement K. When `K == 0`, I record the result and stop recursion."
        },
        {
          "optionId": "ch_viva_8_q41_opt3",
          "optionText": "I perform a simulation of sorted reading. I descend to the leftmost node (minimum). I then trace the 'next' successor path $K-1$ times. The node I land on is the answer."
        },
        {
          "optionId": "ch_viva_8_q41_opt4",
          "optionText": "I will use BFS and return the Kth element."
        },
        {
          "optionId": "ch_viva_8_q41_opt5",
          "optionText": "I will go Left K times."
        },
        {
          "optionId": "ch_viva_8_q41_opt6",
          "optionText": "I will collect all nodes in an array and return `array[K-1]`."
        },
        {
          "optionId": "ch_viva_8_q41_opt7",
          "optionText": "I will use a Min-Heap."
        },
        {
          "optionId": "ch_viva_8_q41_opt8",
          "optionText": "I will use Pre-Order traversal."
        },
        {
          "optionId": "ch_viva_8_q41_opt9",
          "optionText": "I will search for value `K`."
        },
        {
          "optionId": "ch_viva_8_q41_opt10",
          "optionText": "I will modify the tree to count children."
        },
        {
          "optionId": "ch_viva_8_q41_opt11",
          "optionText": "I will start from the max and go backwards."
        },
        {
          "optionId": "ch_viva_8_q41_opt12",
          "optionText": "I will check `root.left.left...`."
        },
        {
          "optionId": "ch_viva_8_q41_opt13",
          "optionText": "I will return the Kth level."
        },
        {
          "optionId": "ch_viva_8_q41_opt14",
          "optionText": "I will assume the tree is balanced."
        },
        {
          "optionId": "ch_viva_8_q41_opt15",
          "optionText": "I will use recursion without a counter."
        }
      ],
      "correctOptionIds": ["ch_viva_8_q41_opt1", "ch_viva_8_q41_opt2", "ch_viva_8_q41_opt3"],
      "explanationText": "The In-Order traversal of a BST yields elements in sorted order. The most efficient solution is to perform an In-Order traversal (recursively or iteratively) and stop immediately after visiting the $K$-th node. This is $O(H + K)$ time, where $H$ is the height, and $O(H)$ space (for the stack)."
    },
    {
      "chapterIndex": 7,
      "questionIndex": 1,
      "questionId": "ch_viva_8_q42",
      "questionText": "Sketch an algorithm to **insert** a new node with value `V` into a **Sorted Singly Linked List** while maintaining sorted order.",
      "options": [
        {
          "optionId": "ch_viva_8_q42_opt1",
          "optionText": "I handle the Head case: If `head` is null or `head.val \\ge V`, I insert at start and update head. Else, I traverse with `curr`. I look ahead: while `curr.next` is not null and `curr.next.val < V`, I move forward. Then I insert `newNode` between `curr` and `curr.next`."
        },
        {
          "optionId": "ch_viva_8_q42_opt2",
          "optionText": "I maintain `prev` and `curr` pointers. I iterate until I find a node `curr` where `curr.val > V`. I insert `newNode` between `prev` and `curr`. If `prev` is null, I update head. If `curr` is null, I append to tail."
        },
        {
          "optionId": "ch_viva_8_q42_opt3",
          "optionText": "I scan the list to find the 'gap'. The gap is the first position where the next value exceeds `V`. I perform a standard pointer splice at that gap."
        },
        {
          "optionId": "ch_viva_8_q42_opt4",
          "optionText": "I will just append to the tail."
        },
        {
          "optionId": "ch_viva_8_q42_opt5",
          "optionText": "I will sort the list after insertion."
        },
        {
          "optionId": "ch_viva_8_q42_opt6",
          "optionText": "I will swap values until it fits."
        },
        {
          "optionId": "ch_viva_8_q42_opt7",
          "optionText": "I will check `curr.val == V`."
        },
        {
          "optionId": "ch_viva_8_q42_opt8",
          "optionText": "I will start from the middle."
        },
        {
          "optionId": "ch_viva_8_q42_opt9",
          "optionText": "I will use Binary Search."
        },
        {
          "optionId": "ch_viva_8_q42_opt10",
          "optionText": "I will insert at head if `head > V` then stop."
        },
        {
          "optionId": "ch_viva_8_q42_opt11",
          "optionText": "I will use `curr.prev`."
        },
        {
          "optionId": "ch_viva_8_q42_opt12",
          "optionText": "I will use a second list."
        },
        {
          "optionId": "ch_viva_8_q42_opt13",
          "optionText": "I will traverse until `curr > V`."
        },
        {
          "optionId": "ch_viva_8_q42_opt14",
          "optionText": "I will insert it randomly."
        },
        {
          "optionId": "ch_viva_8_q42_opt15",
          "optionText": "I will check neighbors."
        }
      ],
      "correctOptionIds": ["ch_viva_8_q42_opt1", "ch_viva_8_q42_opt2", "ch_viva_8_q42_opt3"],
      "explanationText": "Insertion into a sorted linked list requires finding the correct position by traversing the list. Since it's a singly linked list, you must either track the previous node (`prev`) or look ahead (`curr.next`) to perform the insertion splice correctly. Time complexity is $O(N)$."
    }
  ]
}
