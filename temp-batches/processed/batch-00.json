{
  "batchIndex": 0,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 0,
      "questionId": "ch_viva_1_q1",
      "questionText": "Sketch an algorithm to check if a **Stack** and a **Queue** contain the exact same set of integer elements (order does not matter). You may use auxiliary data structures.",
      "options": [
        {
          "optionId": "ch_viva_1_q1_opt1",
          "optionText": "I will iterate through the stack using an index `i` from 0 to size, accessing elements via `stack.get(i)`. For each element, I will search through the queue linearly using `queue.get(j)`. If all elements are found, return true. This approach has $O(N^2)$ time complexity."
        },
        {
          "optionId": "ch_viva_1_q1_opt2",
          "optionText": "I will use two pointers, one initialized at the top of the stack and one at the front of the queue. I will advance both pointers simultaneously, comparing elements at each step. If any mismatch occurs, return false. Continue until both structures are exhausted."
        },
        {
          "optionId": "ch_viva_1_q1_opt3",
          "optionText": "I will sort the Stack in place using a modified bubble sort that works with push and pop operations. After sorting, I will compare elements one by one with the Queue by dequeuing and popping simultaneously. Return true if all elements match in sorted order."
        },
        {
          "optionId": "ch_viva_1_q1_opt4",
          "optionText": "I will pop from the stack and dequeue from the queue simultaneously in a loop. At each iteration, I compare the popped element with the dequeued element. If they don't match at any point, return false immediately. If the loop completes, return true."
        },
        {
          "optionId": "ch_viva_1_q1_opt5",
          "optionText": "I will first transfer all Stack elements into a sorted auxiliary array using insertion sort during transfer. Then I will use Binary Search on this sorted array to check if each Queue element exists. Return true if all Queue elements are found in the array."
        },
        {
          "optionId": "ch_viva_1_q1_opt6",
          "optionText": "I will check if both structures have the same size first. If sizes differ, return false immediately. If sizes match, I compare the top of Stack with front of Queue directly. Time complexity is $O(1)$ because I'm just comparing single elements at accessible positions."
        },
        {
          "optionId": "ch_viva_1_q1_opt7",
          "optionText": "I will iterate through the Queue using a loop. For each element at the front, I will call `stack.contains(queue.front())` to check membership. After each check, I dequeue the element. If any element is not found in the Stack, return false immediately."
        },
        {
          "optionId": "ch_viva_1_q1_opt8",
          "optionText": "I will pop everything from the Stack and enqueue each element into the Queue. Then I will iterate through the combined Queue, using a nested loop to detect duplicates. If duplicate counts match between original portions, the sets are equal. Return true if no mismatches found."
        },
        {
          "optionId": "ch_viva_1_q1_opt9",
          "optionText": "I will use a Hash Map to count frequencies. First, I pop all elements from the Stack, incrementing their counts in the Map. Then, I dequeue all elements from the Queue, decrementing their counts. Finally, I check if the Map is empty or all counts are zero. Return true if so."
        },
        {
          "optionId": "ch_viva_1_q1_opt10",
          "optionText": "I will initialize two empty auxiliary arrays. I will pop the Stack into Array A and dequeue the Queue into Array B. I will then Sort both arrays. Finally, I will iterate through both arrays simultaneously to check if they are identical. Return True if the loop finishes successfully."
        },
        {
          "optionId": "ch_viva_1_q1_opt11",
          "optionText": "I will use a Hash Set to track elements. I pop elements from the Stack and add them to the Set. Then, I dequeue from the Queue and check if each element exists in the Set using `set.contains()`. If all elements are found, the structures contain the same elements."
        },
        {
          "optionId": "ch_viva_1_q1_opt12",
          "optionText": "I will convert the Stack to a collection object and the Queue to a collection object. Then I will call `stackCollection.equals(queueCollection)` to perform a direct equality comparison. This built-in method handles all element comparisons internally and returns the result."
        },
        {
          "optionId": "ch_viva_1_q1_opt13",
          "optionText": "I will peek at the top of the stack and the front of the queue in a loop. Compare these values at each iteration. If they match, pop from stack and dequeue from queue, then continue. Repeat until both structures are empty or a mismatch is found."
        },
        {
          "optionId": "ch_viva_1_q1_opt14",
          "optionText": "I will convert both data structures to arrays using their respective `toArray()` methods. Then I will compare the arrays using reference equality with `array1 == array2`. This comparison returns true if both arrays contain identical elements in any order."
        },
        {
          "optionId": "ch_viva_1_q1_opt15",
          "optionText": "I will use a Frequency Map. I loop through the Stack and Queue, updating counts. If all counts are zero, they are equal."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q1_opt9", "ch_viva_1_q1_opt10", "ch_viva_1_q1_opt15"],
      "explanationText": "The key is handling duplicates and order independence efficiently.\n\n**Hash Map / Frequency Map Approach ($O(N)$ Time, $O(N)$ Space):** Count the frequency of each element from the Stack (incrementing counts), then process the Queue (decrementing counts). If all counts are zero at the end, the multisets are equal. This handles duplicates correctly and is the most efficient method.\n\n**Sorting Approach ($O(N \\log N)$ Time, $O(N)$ Space):** Extract all elements into arrays, sort both arrays, then compare element by element. This is also valid but slower than the Hash Map approach.\n\nIncorrect approaches fail for several reasons: comparing elements in order (Stack and Queue have different orderings but this doesn't mean different elements), using simple set membership without frequency tracking (fails with duplicates like [1,1,2] vs [1,2,2]), using reference equality instead of value comparison, or assuming methods like indexed access or `contains()` exist on standard Stack/Queue interfaces."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 1,
      "questionId": "ch_viva_1_q2",
      "questionText": "Sketch an algorithm to move all elements from a **Queue** into a **Stack** such that the order of elements is **reversed** compared to the original Queue.",
      "options": [
        {
          "optionId": "ch_viva_1_q2_opt1",
          "optionText": "I will initialize an empty Stack. While the Queue is not empty, I will `dequeue` an element and immediately `push` it onto the Stack. Finally, I return the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt2",
          "optionText": "I'll create a function taking the Queue. I'll create a Stack. I loop until `queue.isEmpty()`. Inside the loop: `val = queue.dequeue()`, `stack.push(val)`. Return the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt3",
          "optionText": "I will transfer elements directly. Since the Queue removes from the front (1st item) and the Stack adds to the top, the first item out of the Queue becomes the bottom of the Stack. The last item out becomes the top. This naturally reverses the access order."
        },
        {
          "optionId": "ch_viva_1_q2_opt4",
          "optionText": "I will use two auxiliary stacks to ensure proper reversal. First, I dequeue all elements from the Queue into Stack A. Then, I pop all elements from Stack A and push them onto Stack B. Finally, I return Stack B, which contains elements in reversed order."
        },
        {
          "optionId": "ch_viva_1_q2_opt5",
          "optionText": "I will access the internal representation of the Queue and swap the head and tail pointers directly. This reverses the logical order of elements without moving any data. Then I will cast the modified Queue structure to a Stack and return it."
        },
        {
          "optionId": "ch_viva_1_q2_opt6",
          "optionText": "I will iterate backwards through the Queue starting from the rear element. For each element accessed in reverse order, I push it onto an empty Stack. This ensures the first element pushed is the original rear, achieving the desired reversed order in the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt7",
          "optionText": "I will create a new Stack and push the entire Queue object onto it as a single element. Since the Queue maintains its internal ordering, accessing it from the Stack will reverse the perspective of traversal, achieving the reversal without moving individual elements."
        },
        {
          "optionId": "ch_viva_1_q2_opt8",
          "optionText": "I will dequeue elements one by one from the Queue. For each element, I will use a helper function to insert it at the bottom of the Stack rather than the top. This requires popping all existing elements, adding the new one, then pushing the old elements back."
        },
        {
          "optionId": "ch_viva_1_q2_opt9",
          "optionText": "I will create an auxiliary array and dequeue all elements from the Queue into the array in order. Then I will reverse the array in place using two-pointer swapping. Finally, I will iterate through the reversed array and push each element onto an empty Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt10",
          "optionText": "I will use a recursive approach where I dequeue one element, make a recursive call to process the remaining Queue, and after the recursive call returns, push the dequeued element onto the Stack. This processes the last element first due to call stack behavior."
        },
        {
          "optionId": "ch_viva_1_q2_opt11",
          "optionText": "I will analyze the time complexity: Each push operation onto the Stack requires shifting all existing elements down by one position, similar to array insertion. Therefore, pushing N elements results in $O(N^2)$ time complexity for the complete transfer operation."
        },
        {
          "optionId": "ch_viva_1_q2_opt12",
          "optionText": "I will convert the Queue to a Doubly Linked List implementation first, which allows bidirectional traversal. Then I will traverse from the tail to the head, pushing each element onto the Stack. This ensures proper reversal with $O(N)$ time complexity."
        },
        {
          "optionId": "ch_viva_1_q2_opt13",
          "optionText": "I will call `queue.clear()` to delete all elements from the Queue. Then I will create a new Stack and initialize it with a copy of the original Queue's values stored in a temporary variable. The Stack constructor will handle the reversal automatically."
        },
        {
          "optionId": "ch_viva_1_q2_opt14",
          "optionText": "I will use a loop where I first peek at the front of the Queue to get the value, then push that value onto the Stack, and finally dequeue from the Queue to remove the element. This three-step process ensures no data is lost during transfer."
        },
        {
          "optionId": "ch_viva_1_q2_opt15",
          "optionText": "I will use a type casting operation to convert the Queue directly to a Stack object. Since both are linear data structures with similar underlying storage, the cast operation `(Stack) queue` will reinterpret the Queue's elements in LIFO order automatically."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q2_opt1", "ch_viva_1_q2_opt2", "ch_viva_1_q2_opt3"],
      "explanationText": "Moving elements from a FIFO structure (Queue) directly into a LIFO structure (Stack) naturally reverses the order of retrieval. The algorithm is straightforward: repeatedly dequeue from the Queue and push onto the Stack until the Queue is empty.\n\n**Why this works:** The first element dequeued (originally at the front of the Queue) becomes the deepest element in the Stack (bottom). The last element dequeued (originally at the rear) becomes the top of the Stack. When you later pop from the Stack, you retrieve elements in reverse order compared to the original Queue order.\n\n**Time Complexity:** $O(N)$ where N is the number of elements, since each element is dequeued once and pushed once.\n\nIncorrect approaches include: using unnecessary auxiliary structures that add complexity without benefit, assuming you can iterate backwards through a Queue (standard Queue only supports front access), confusing peek with dequeue operations, or incorrectly analyzing the time complexity of stack push operations (which are $O(1)$ not $O(N)$)."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 2,
      "questionId": "ch_viva_1_q3",
      "questionText": "Sketch an algorithm to insert a new node with value `K` at the **Head** of a **Circular Linked List**, given a pointer to the `tail`.",
      "options": [
        {
          "optionId": "ch_viva_1_q3_opt1",
          "optionText": "First, I check if the list is empty. If so, create the node and point it to itself. If not, I create `newNode`. I set `newNode.next = tail.next` (current head). Then, I update `tail.next = newNode`. I return the original `tail` pointer."
        },
        {
          "optionId": "ch_viva_1_q3_opt2",
          "optionText": "I will initialize a `newNode` with data `K`. I link `newNode.next` to the current `head` (which is `tail.next`). Then I simply update the `tail`'s next pointer to point to my `newNode`. This effectively places it at the start without moving the tail."
        },
        {
          "optionId": "ch_viva_1_q3_opt3",
          "optionText": "I handle the empty case by making the node point to itself. For the non-empty case, I perform a standard insertion after `tail`, but I strictly *do not* update the `tail` reference itself, leaving the new node as the new head."
        },
        {
          "optionId": "ch_viva_1_q3_opt4",
          "optionText": "I will create a new node with value K. Since this is a doubly-linked circular list, I will set `head.prev = newNode` and `newNode.next = head`. Then I update `tail.next = newNode` and `newNode.prev = tail` to complete the circular connections."
        },
        {
          "optionId": "ch_viva_1_q3_opt5",
          "optionText": "I will create a new node with value K and set `tail.next = newNode` to link it after the tail. Since we want it at the head position, I then set `newNode.next = null` to mark it as the new end of the traversable sequence from the original head."
        },
        {
          "optionId": "ch_viva_1_q3_opt6",
          "optionText": "I will initialize a pointer `current` to `tail.next` (the head). I will traverse the entire circular list using a while loop until `current.next == tail.next`. Then I insert the new node before the head by updating the last node's next pointer to the new node."
        },
        {
          "optionId": "ch_viva_1_q3_opt7",
          "optionText": "I will create a new node with value K. I will set `newNode.next = tail.next` to link to the current head. Then I update `tail = newNode` to make the new node the new tail. This maintains the circular structure with the new node accessible from both ends."
        },
        {
          "optionId": "ch_viva_1_q3_opt8",
          "optionText": "I will create a new node and update a separate `head` pointer to point to the new node. Then I set `newNode.next` to the old head. However, since we only have the tail pointer, I will derive head from traversing the list once to find where `node.next == tail.next`."
        },
        {
          "optionId": "ch_viva_1_q3_opt9",
          "optionText": "I will create the new node with value K. Since I must traverse to find the head first (it's not directly accessible from tail), the complexity is $O(N)$ where N is the list size. I traverse until I find the node before the head, then insert the new node there."
        },
        {
          "optionId": "ch_viva_1_q3_opt10",
          "optionText": "I will create a new node with value K. To insert at head, I will swap the data value of the current tail with K, effectively making the tail hold the new value. Then I update all pointers so the original tail node becomes the new head position logically."
        },
        {
          "optionId": "ch_viva_1_q3_opt11",
          "optionText": "I will create a new node with value K. I set `newNode.next = tail` to link the new node to the tail. Then I update `tail.next = newNode` to complete the circular connection. This places the new node between the tail and its original successor."
        },
        {
          "optionId": "ch_viva_1_q3_opt12",
          "optionText": "I will check if the list is empty by testing if `tail == null`. If empty, I create a new node, set `tail = newNode`, and leave `newNode.next` uninitialized since there's only one element. For non-empty lists, I proceed with the standard insertion algorithm."
        },
        {
          "optionId": "ch_viva_1_q3_opt13",
          "optionText": "I will use a temporary pointer initialized to `tail.next` (the head). I traverse the entire circle by following next pointers until I return to the starting point. During traversal, I find the correct insertion point and update the necessary links to insert the new node."
        },
        {
          "optionId": "ch_viva_1_q3_opt14",
          "optionText": "I will create a new node with value K. I insert it immediately after the tail by setting `newNode.next = tail.next` and `tail.next = newNode`. Then I move the tail pointer forward by one position with `tail = tail.next`, making the new node the new tail."
        },
        {
          "optionId": "ch_viva_1_q3_opt15",
          "optionText": "I will first check if `tail.next == null` to determine if the list is empty or improperly formed. If null, I handle the empty case. Otherwise, I proceed with insertion by creating a new node and updating the circular links appropriately to place it at the head."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q3_opt1", "ch_viva_1_q3_opt2", "ch_viva_1_q3_opt3"],
      "explanationText": "In a circular linked list managed by a `tail` pointer, the head is always accessible via `tail.next`. This makes head insertion an $O(1)$ operation.\n\n**Correct Algorithm:**\n1. **Empty list case:** Create the new node and point its `next` to itself. Set `tail` to this node.\n2. **Non-empty list case:** Create `newNode` with value K. Set `newNode.next = tail.next` (linking to current head). Update `tail.next = newNode` (making new node the head). Do NOT update the tail pointer itself.\n\n**Key insight:** The new node is inserted *between* the tail and the current head. Since head = tail.next, updating tail.next to point to the new node automatically makes it the new head.\n\nIncorrect approaches include: assuming doubly-linked structure when only singly-linked is specified, setting `next` to null (breaks circularity), traversing the list (unnecessary since tail.next gives direct head access), updating the tail pointer (which would make the new node the tail, not the head), or checking for null in tail.next (in a proper circular list, tail.next is never null)."
    }
  ]
}
