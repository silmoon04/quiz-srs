{
  "batchIndex": 2,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 6,
      "questionId": "ch_viva_1_q7",
      "questionText": "Sketch an algorithm to find all elements in an integer Array that appear **more than once** (duplicates).",
      "options": [
        {
          "optionId": "ch_viva_1_q7_opt1",
          "optionText": "I will initialize an empty **Hash Set** called `seen` and a Set called `duplicates`. I iterate through the array. For each number: if it is already in `seen`, I add it to `duplicates`. Else, I add it to `seen`. Finally, I return the `duplicates` set."
        },
        {
          "optionId": "ch_viva_1_q7_opt2",
          "optionText": "I will use a **Frequency Map**. Loop through the array, mapping `Number -> Count`. After the loop, iterate through the Map's keys. If `Count > 1`, add to my result list. Return result."
        },
        {
          "optionId": "ch_viva_1_q7_opt3",
          "optionText": "I initialize a Hash Set. I loop through the array. If `set.add(value)` returns false (meaning it's already there), I print/store that value as a duplicate."
        },
        {
          "optionId": "ch_viva_1_q7_opt4",
          "optionText": "I will use **nested loops** to compare every element with every other element. For each index `i`, I iterate `j` from `i+1` to the end. If `arr[i] == arr[j]`, I add `arr[i]` to my result set. This gives me all duplicates after checking all pairs."
        },
        {
          "optionId": "ch_viva_1_q7_opt5",
          "optionText": "I will first **Sort the array** in ascending order using a standard sorting algorithm. Then I iterate through the sorted array checking if `arr[i] == arr[i+1]`. If equal, I add the value to my duplicates list. Return the list at the end."
        },
        {
          "optionId": "ch_viva_1_q7_opt6",
          "optionText": "I will construct a **Binary Search Tree** by inserting each element from the array. During insertion, if an element already exists in the tree, I mark it as a duplicate and add it to my result list. After processing all elements, I return the duplicates list."
        },
        {
          "optionId": "ch_viva_1_q7_opt7",
          "optionText": "I will use a **Stack** to track numbers as I iterate through the array. For each number, I pop elements and compare them with the current value. If a match is found, I record it as a duplicate, then push all elements back onto the stack."
        },
        {
          "optionId": "ch_viva_1_q7_opt8",
          "optionText": "I will use a **Hash Map** where each key is an array element. I iterate through the array once. For each element, if the key exists in the map, I immediately return true indicating duplicates exist. Otherwise, I add the key to the map."
        },
        {
          "optionId": "ch_viva_1_q7_opt9",
          "optionText": "I will create a **counting array of fixed size 100** (assuming values are 0-99). I iterate through the input array, incrementing `count[value]` for each element. Then I scan the counting array and return indices where `count > 1`."
        },
        {
          "optionId": "ch_viva_1_q7_opt10",
          "optionText": "I will iterate through the array and **delete duplicates** in-place by shifting elements. When I encounter a value that appears earlier in the array, I remove it by shifting all subsequent elements left. The original array will then contain only unique values."
        },
        {
          "optionId": "ch_viva_1_q7_opt11",
          "optionText": "I will use a **single pointer** that iterates through the array while maintaining a constant space complexity of $O(1)$. At each position, I check all previous elements without using any additional data structures to find if the current element is a duplicate."
        },
        {
          "optionId": "ch_viva_1_q7_opt12",
          "optionText": "I will compute a **single hash value** for the entire array by XORing all elements together. If the result is zero, duplicates exist; otherwise, the array contains all unique elements. I return this hash value as my duplicate indicator."
        },
        {
          "optionId": "ch_viva_1_q7_opt13",
          "optionText": "I will use a **Queue** to cycle through numbers in FIFO order. I enqueue each element from the array, then repeatedly dequeue and compare with all elements still in the queue. If a match is found, I record it as a duplicate."
        },
        {
          "optionId": "ch_viva_1_q7_opt14",
          "optionText": "I will construct a **Linked List** to store seen numbers as I iterate through the array. For each new element, I traverse the entire linked list to check if the value already exists. If it does, I add it to my duplicates result."
        },
        {
          "optionId": "ch_viva_1_q7_opt15",
          "optionText": "I will use a **two-pointer approach** starting at the first and last elements of the array. I move the pointers toward each other, comparing `arr[left]` with `arr[right]`. If they match, I record a duplicate and move both pointers inward."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q7_opt1", "ch_viva_1_q7_opt2", "ch_viva_1_q7_opt3"],
      "explanationText": "The most efficient solutions use a Hash Table (Map or Set) to track frequencies or existence. The **dual-set approach** maintains a `seen` set and a `duplicates` set, adding to duplicates when an element is already seen. The **frequency map approach** counts occurrences and filters for counts greater than 1. The **set.add() return value approach** leverages the boolean return of set insertion to detect duplicates. All these achieve $O(N)$ time complexity, which is faster than sorting ($O(N \\log N)$) or nested loops ($O(N^2)$). Approaches using linked lists, stacks, or queues for lookup are inefficient as they require $O(N)$ per lookup. Fixed-size counting arrays only work for constrained value ranges."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 7,
      "questionId": "ch_viva_1_q8",
      "questionText": "Sketch an algorithm to check if a given Binary Tree is a valid **Binary Search Tree (BST)**.",
      "options": [
        {
          "optionId": "ch_viva_1_q8_opt1",
          "optionText": "I will perform an **In-Order Traversal** and store the values in a list. Then, I iterate through the list to check if it is **sorted** in strictly ascending order. If yes, it is a BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt2",
          "optionText": "I will use a recursive function that takes a node and a valid range `(min, max)`. Initialize with `(-\\infty, +\\infty)`. At each node, check if `val` is within range. Recurse left updating `max` to `val`. Recurse right updating `min` to `val`."
        },
        {
          "optionId": "ch_viva_1_q8_opt3",
          "optionText": "I will use an Iterative In-Order traversal (using a Stack). I keep track of the `previous_value` visited. If the `current_value` is ever less than or equal to `previous_value`, I return False immediately."
        },
        {
          "optionId": "ch_viva_1_q8_opt4",
          "optionText": "I will traverse the tree recursively and at each node only check if `node.left.val < node.val` and `node.right.val > node.val`. If both conditions hold for the immediate children, I conclude the subtree rooted at this node is a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt5",
          "optionText": "I will perform a **Pre-Order traversal** of the tree (visiting root, then left, then right). As I visit each node, I check if the value is greater than all previously visited values. If so, I continue; otherwise, I return false."
        },
        {
          "optionId": "ch_viva_1_q8_opt6",
          "optionText": "I will traverse the entire tree and collect all node values into a list. Then I scan the list to **search for duplicate values**. If no duplicates are found, I conclude the tree is a valid BST since BSTs cannot have duplicates."
        },
        {
          "optionId": "ch_viva_1_q8_opt7",
          "optionText": "I will use a **Queue for BFS (level-order traversal)** and check that at each level, all values on the left half are smaller than values on the right half. I process level by level and validate this property throughout."
        },
        {
          "optionId": "ch_viva_1_q8_opt8",
          "optionText": "I will recursively check if the tree is **height-balanced** by computing the height of left and right subtrees at each node. If the heights differ by at most 1 at every node, I conclude the tree is a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt9",
          "optionText": "I will perform an in-order traversal to collect all values, then **sort this list** using a standard sorting algorithm. If the sorted list matches the original traversal list, then the tree is a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt10",
          "optionText": "I will calculate the **height of the tree** and check if it equals $\\log_2 N$ where N is the number of nodes. If the height matches this formula, the tree is properly structured as a BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt11",
          "optionText": "I will assume the tree is a valid BST and attempt to **search for an arbitrary value** using standard BST search logic. If the search terminates correctly (finding the value or reaching null), the tree is a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt12",
          "optionText": "I will **compare the root value with all leaf node values** by traversing to each leaf. If the root is greater than all left-side leaves and smaller than all right-side leaves, I conclude the tree is a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt13",
          "optionText": "I will **convert the binary tree to a Min-Heap** by rearranging nodes. Then I verify the heap property holds (parent â‰¤ children). If the heap is valid, the original tree was a valid BST."
        },
        {
          "optionId": "ch_viva_1_q8_opt14",
          "optionText": "I will use a **recursive helper function without passing min/max bounds**. At each node, I only recursively check the left and right subtrees and return true if both recursive calls return true, without validating the current node's value."
        },
        {
          "optionId": "ch_viva_1_q8_opt15",
          "optionText": "I will check if **every non-leaf node has exactly 2 children**. I traverse the tree and for each internal node, verify it has both a left and right child. If this property holds everywhere, the tree is a valid BST."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q8_opt1", "ch_viva_1_q8_opt2", "ch_viva_1_q8_opt3"],
      "explanationText": "The core property of a BST is that an In-Order traversal yields a sorted list. The **in-order traversal with list verification** approach collects values and checks if they are strictly ascending. The **iterative in-order with previous value tracking** achieves the same result with $O(1)$ extra space by comparing each value with the last visited. The **recursive min/max range approach** is robust, ensuring every node adheres to global min/max constraints imposed by its ancestors, not just its immediate parent. Simply checking immediate children fails because a node in the right subtree could be smaller than an ancestor. Height-balance and heap properties are unrelated to BST validity."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 8,
      "questionId": "ch_viva_1_q9",
      "questionText": "Sketch an algorithm to find the **middle node** of a Singly Linked List.",
      "options": [
        {
          "optionId": "ch_viva_1_q9_opt1",
          "optionText": "I will use the **Two Pointer Method** (Slow and Fast). Initialize both at head. Loop while `fast` and `fast.next` are not null. Move `slow` one step, move `fast` two steps. When `fast` reaches the end, `slow` will be at the middle. Return `slow`."
        },
        {
          "optionId": "ch_viva_1_q9_opt2",
          "optionText": "I will perform two passes. First, traverse to count total nodes `N`. Then, calculate `mid = N/2`. Traverse again from head `mid` times to reach the node. Return it."
        },
        {
          "optionId": "ch_viva_1_q9_opt3",
          "optionText": "I will push every node pointer onto a Stack while traversing. Then I pop $N/2$ elements off the stack. The element currently at the top is the middle."
        },
        {
          "optionId": "ch_viva_1_q9_opt4",
          "optionText": "I will treat the linked list as an array and **access `list[size / 2]`** directly using index-based access. Since linked lists support indexing like arrays, this gives me the middle element in $O(1)$ time."
        },
        {
          "optionId": "ch_viva_1_q9_opt5",
          "optionText": "I will access the middle node by following exactly two next pointers from head using **`head.next.next`**. This expression directly gives me the middle node since the middle is always two steps from the start of any linked list."
        },
        {
          "optionId": "ch_viva_1_q9_opt6",
          "optionText": "I will traverse the linked list and **check if `node.next == null`** at each step. When this condition becomes true, I have found the middle node because the middle node is the one just before the end of the list."
        },
        {
          "optionId": "ch_viva_1_q9_opt7",
          "optionText": "I will **create a new array and copy all node values** from the linked list into it during a single traversal. Then I access `array[array.length / 2]` to get the middle value. This converts the problem to array indexing."
        },
        {
          "optionId": "ch_viva_1_q9_opt8",
          "optionText": "I will use **recursion to fold the list in half** by having each recursive call process one node from the start and one from the end. When the two recursive paths meet in the middle, I return that node as the middle element."
        },
        {
          "optionId": "ch_viva_1_q9_opt9",
          "optionText": "I will **estimate the middle position** based on the memory address of the head node. By calculating the expected memory offset, I can compute a pointer to approximately where the middle node should be located in memory."
        },
        {
          "optionId": "ch_viva_1_q9_opt10",
          "optionText": "I will traverse the linked list while keeping a counter. I will **stop traversal when counter reaches 5** since the middle of most linked lists is around the 5th position. I then return the current node as the middle."
        },
        {
          "optionId": "ch_viva_1_q9_opt11",
          "optionText": "I will use two pointers `i` and `j` both starting at head. I will **iterate both pointers at the same speed** (one step per iteration). When pointer `j` reaches the end, pointer `i` will naturally be at the middle of the list."
        },
        {
          "optionId": "ch_viva_1_q9_opt12",
          "optionText": "I will **convert the singly linked list to a doubly linked list** first by adding `prev` pointers to each node. Then I start one pointer at head and one at tail, moving them toward each other until they meet at the middle."
        },
        {
          "optionId": "ch_viva_1_q9_opt13",
          "optionText": "I will **delete nodes alternately from the start and end** of the linked list. I remove one node from the head, then find and remove the tail. I repeat this process until only one or two nodes remain, which represents the middle."
        },
        {
          "optionId": "ch_viva_1_q9_opt14",
          "optionText": "I will use a **Hash Map to store each node with its index** as I traverse the list. After traversal, I calculate `mid = size / 2` and look up the node at that index in the Hash Map. Return the retrieved node."
        },
        {
          "optionId": "ch_viva_1_q9_opt15",
          "optionText": "I will assume the linked list object has a **`size` member variable available** that tracks the current length. I access this variable, divide by 2, then traverse that many steps from head to reach the middle node."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q9_opt1", "ch_viva_1_q9_opt2", "ch_viva_1_q9_opt3"],
      "explanationText": "The **Two-Pointer (Tortoise and Hare) method** is the most efficient approach, solving the problem in a single pass with $O(N)$ time and $O(1)$ space. By moving one pointer at double speed, when the fast pointer reaches the end, the slow pointer is exactly at the middle. The **two-pass counting method** is also $O(N)$ time but requires two full traversals: one to count and one to navigate to the middle position. The **stack-based method** pushes all nodes onto a stack, then pops half to find the middle, using $O(N)$ time and $O(N)$ space. Approaches assuming array-like indexing or a size variable are invalid for standard singly linked lists. Moving two pointers at the same speed won't find the middle."
    }
  ]
}
