{
  "batchIndex": 1,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 3,
      "questionId": "ch_viva_1_q4",
      "questionText": "Sketch an **iterative** (non-recursive) algorithm to find the **sum** of all keys in a **Binary Tree**.",
      "options": [
        {
          "optionId": "ch_viva_1_q4_opt1",
          "optionText": "I will use a **Queue** for Level-Order Traversal. Initialize `sum = 0`. Enqueue `root`. While Queue is not empty: Dequeue a node, add its key to `sum`. If `node.left` exists, Enqueue it. If `node.right` exists, Enqueue it. Return `sum`."
        },
        {
          "optionId": "ch_viva_1_q4_opt2",
          "optionText": "I will use a **Stack** for Depth-First Traversal. Initialize `sum = 0`. Push `root`. While Stack has items: Pop `current`. `sum += current.key`. Push `current.right` and `current.left` if they are not null. Return `sum`."
        },
        {
          "optionId": "ch_viva_1_q4_opt3",
          "optionText": "I will initialize a `total` variable. Using a standard iterative traversal (like BFS with a Queue), I visit every node exactly once. At each visit, I accumulate the value into `total`. Finally, I return `total`."
        },
        {
          "optionId": "ch_viva_1_q4_opt4",
          "optionText": "I will iterate through the tree using a standard `for node in tree` loop construct. Initialize `sum = 0`. For each node encountered in the iteration, add `node.key` to `sum`. Return `sum` after the loop completes. This assumes the tree has a built-in iterator."
        },
        {
          "optionId": "ch_viva_1_q4_opt5",
          "optionText": "I will implement a recursive approach where each call returns `node.key + sum(node.left) + sum(node.right)`. The base case returns 0 when the node is null. The final result bubbles up from the recursive calls to give the total sum."
        },
        {
          "optionId": "ch_viva_1_q4_opt6",
          "optionText": "I will use a Stack-based approach. Push the root node onto the Stack. Pop a node and add its value to the running sum. Push the left child onto the Stack, then push the right child. Continue until the Stack is empty and return the sum."
        },
        {
          "optionId": "ch_viva_1_q4_opt7",
          "optionText": "I will apply Binary Search principles to efficiently locate and sum nodes. Starting at the root, I compare each node's key with a target threshold. I traverse left or right based on comparisons, accumulating values along the search path until reaching null."
        },
        {
          "optionId": "ch_viva_1_q4_opt8",
          "optionText": "I will traverse the tree using only pointer manipulation with `current = current.left` in a loop. Initialize `sum = 0` and `current = root`. While `current` is not null, add `current.key` to sum and move `current = current.left`. Return `sum` after exiting the loop."
        },
        {
          "optionId": "ch_viva_1_q4_opt9",
          "optionText": "I will first convert the binary tree to an array representation using `tree.toArray()` which performs a level-order serialization. Then I iterate through the resulting array with a simple for loop, summing all non-null elements to get the total."
        },
        {
          "optionId": "ch_viva_1_q4_opt10",
          "optionText": "I will use a divide-and-conquer approach that achieves $O(\\log N)$ complexity. At each level, I split the problem in half by visiting only one subtree based on a balanced partition strategy. I accumulate partial sums and combine them at the root."
        },
        {
          "optionId": "ch_viva_1_q4_opt11",
          "optionText": "I will use a Queue data structure to perform a Depth-First Search traversal. Initialize `sum = 0` and enqueue the root. While the Queue has elements, dequeue a node, add its key to sum, and enqueue its children in DFS order. Return sum."
        },
        {
          "optionId": "ch_viva_1_q4_opt12",
          "optionText": "I will treat the tree as a linked list structure. Initialize `sum = 0` and `current = root`. While `current` is not null, add `current.key` to sum, then advance to the next node using `current = current.next`. Return sum when current becomes null."
        },
        {
          "optionId": "ch_viva_1_q4_opt13",
          "optionText": "I will maintain a Hash Map to track visited nodes and prevent double-counting. Initialize `sum = 0` and an empty visited map. For each node, check if it exists in the map before adding its key. Mark each processed node as visited in the map."
        },
        {
          "optionId": "ch_viva_1_q4_opt14",
          "optionText": "I will use a destructive traversal approach where I delete nodes after summing them to optimize space usage. Initialize `sum = 0`. Visit each node, add its key to sum, then remove the node from the tree. Continue until the tree is empty and return sum."
        },
        {
          "optionId": "ch_viva_1_q4_opt15",
          "optionText": "I will start at the root node and follow a single path downward. Initialize `sum = 0` and `node = root`. While `node` is not null, add `node.key` to sum and move to either left or right child. Return sum when reaching a null reference."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q4_opt1", "ch_viva_1_q4_opt2", "ch_viva_1_q4_opt3"],
      "explanationText": "Iterative traversal requires an auxiliary data structure (Stack for DFS or Queue for BFS) to store unvisited nodes. Since summing requires visiting every node, the time complexity is $O(N)$. The Stack-based approach that omits null checks for children before pushing is logically similar but would fail when attempting to access properties of null nodes. Approaches that only traverse one path (left-only or following a 'next' pointer) will miss most nodes. Using a Queue for DFS or claiming $O(\\log N)$ complexity reflects fundamental misunderstandings of the data structures and problem requirements."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 4,
      "questionId": "ch_viva_1_q5",
      "questionText": "Sketch an algorithm to **sort** an array of integers in **descending** order using a **Min-Heap**.",
      "options": [
        {
          "optionId": "ch_viva_1_q5_opt1",
          "optionText": "I will create an empty Min-Heap. I insert all array elements into it. Then, I iterate an index `i` starting from the array's **length - 1 down to 0**. At each step, I call `extractMin()` and place the result at `array[i]`. This fills the array with the largest elements at the start and smallest at the end."
        },
        {
          "optionId": "ch_viva_1_q5_opt2",
          "optionText": "Alternatively, I could use a **Max-Heap**. I insert all elements. Then I call `extractMax()` repeatedly and fill the array from index 0 upwards. This results in descending order."
        },
        {
          "optionId": "ch_viva_1_q5_opt3",
          "optionText": "I will Heapify the array into a Min-Heap. Then, I will continuously extract the minimum element. Since I need descending order, I will use a Stack to store the extracted elements temporarily, then pop them back into the array."
        },
        {
          "optionId": "ch_viva_1_q5_opt4",
          "optionText": "I will insert all elements into the Min-Heap structure. Then I repeatedly call `extractMin()` and place each extracted element into the array starting from index 0 and incrementing upwards. This fills the array sequentially from the smallest to largest values."
        },
        {
          "optionId": "ch_viva_1_q5_opt5",
          "optionText": "I will build a Min-Heap from all array elements. To find the largest element, I apply binary search on the heap array structure. Since heaps maintain partial ordering, binary search can efficiently locate the maximum value for extraction."
        },
        {
          "optionId": "ch_viva_1_q5_opt6",
          "optionText": "I will construct a Min-Heap from the input array using heapify. Then I simply traverse the underlying heap array from index 0 to n-1 and copy elements directly to the output. The heap property ensures this produces sorted order."
        },
        {
          "optionId": "ch_viva_1_q5_opt7",
          "optionText": "I will first insert all elements into the Min-Heap to establish heap ordering. After the heap is built, I apply Bubble Sort on the heap's underlying array to achieve the final descending order. This combines heap and comparison-based sorting."
        },
        {
          "optionId": "ch_viva_1_q5_opt8",
          "optionText": "I will build a Min-Heap and repeatedly extract minimum elements. Each extracted element is pushed onto a Stack data structure. After all extractions complete, I pop elements from the Stack back into the array to reverse the ascending order."
        },
        {
          "optionId": "ch_viva_1_q5_opt9",
          "optionText": "I will construct a Min-Heap using heapify which runs in $O(N)$ time. Then I perform N extract operations, each taking $O(1)$ amortized time. The total time complexity is therefore $O(N)$ which is optimal for comparison-based sorting."
        },
        {
          "optionId": "ch_viva_1_q5_opt10",
          "optionText": "I will build a Min-Heap from the array elements. To find the maximum value, I examine only the leaf nodes of the heap since the maximum must reside at the lowest level. I extract leaves in order to build the descending sorted array."
        },
        {
          "optionId": "ch_viva_1_q5_opt11",
          "optionText": "I will use a Min-Heap but negate all numbers before insertion (multiply by -1). This effectively inverts the ordering so extractMin returns the largest original values first. I extract and negate again to restore original values in descending order."
        },
        {
          "optionId": "ch_viva_1_q5_opt12",
          "optionText": "I will build the Min-Heap and extract the root element which is the minimum. Before the next extraction, I swap the new root with a randomly selected element from the remaining heap to maintain balance. Continue until all elements are extracted."
        },
        {
          "optionId": "ch_viva_1_q5_opt13",
          "optionText": "I will construct a Min-Heap from the input array. Then I delete all heap nodes systematically, which triggers the heap's internal reorganization. After deletion completes, I create a new sorted list from the deallocated node values."
        },
        {
          "optionId": "ch_viva_1_q5_opt14",
          "optionText": "I will insert all array elements into a Min-Heap data structure. Since the heap property maintains partial ordering, I assume the underlying array representation is already sorted. I simply return the heap's internal array as the sorted result."
        },
        {
          "optionId": "ch_viva_1_q5_opt15",
          "optionText": "I will call heapify on the input array to build a valid Min-Heap in-place. Once the heap structure is established, I return the underlying array directly without any additional extraction operations, as heapify produces sorted output."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q5_opt1", "ch_viva_1_q5_opt2", "ch_viva_1_q5_opt3"],
      "explanationText": "A Min-Heap naturally extracts elements in ascending order. To achieve descending order, you must either use a Max-Heap and extract from front to back, or reverse the output of the Min-Heap by filling the array backwards from the last index, or by using an auxiliary Stack to reverse the extraction order. All valid methods result in $O(N \\log N)$ time complexity. Approaches that simply copy the heap array directly fail because the heap property only guarantees parent-child relationships, not full sorted order. Extracting to index 0 upwards from a Min-Heap produces ascending order, not descending."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 5,
      "questionId": "ch_viva_1_q6",
      "questionText": "Given a Graph (Adjacency List) and a starting vertex `S`, sketch an algorithm to find the **shortest path** (number of edges) from `S` to a target `T`.",
      "options": [
        {
          "optionId": "ch_viva_1_q6_opt1",
          "optionText": "I will use **BFS** with a Queue. I'll also maintain a `distance` Map (or array) initialized to -1. Set `distance[S] = 0`. Enqueue `S`. While Queue not empty: Dequeue `u`. If `u == T`, return `distance[u]`. For each neighbor `v` of `u`: If `v` is unvisited, set `distance[v] = distance[u] + 1` and Enqueue `v`."
        },
        {
          "optionId": "ch_viva_1_q6_opt2",
          "optionText": "I initialize a Queue for the traversal and a Set for visited nodes. I start a level-counter at 0. I process nodes level-by-level (using the queue size). If I encounter `T`, I return the current level count. If the queue empties, `T` is unreachable."
        },
        {
          "optionId": "ch_viva_1_q6_opt3",
          "optionText": "I employ a Breadth-First Search strategy. I enqueue the start node `S`. I keep track of `predecessor` pointers. When I find `T`, I backtrack using the predecessors to count the steps. This ensures the shortest path in an unweighted graph."
        },
        {
          "optionId": "ch_viva_1_q6_opt4",
          "optionText": "I will use a Depth-First Search approach with a Stack data structure. Initialize the Stack with vertex `S` and a visited Set. Pop vertices and explore neighbors by pushing them onto the Stack. When I find `T`, return the current depth as the shortest path length."
        },
        {
          "optionId": "ch_viva_1_q6_opt5",
          "optionText": "I will perform a linear traversal through the adjacency list representation. Starting from index 0, I examine each entry sequentially until I find vertex `T`. The number of entries traversed gives the shortest path distance from `S` to `T`."
        },
        {
          "optionId": "ch_viva_1_q6_opt6",
          "optionText": "I will implement a recursive depth-first exploration starting from `S`. The function calls itself for each unvisited neighbor, incrementing a depth counter. When `T` is found, I return the current recursion depth as the shortest path length."
        },
        {
          "optionId": "ch_viva_1_q6_opt7",
          "optionText": "I will traverse the graph starting from `S` using a Queue-based approach. Since the adjacency list structure prevents cycles by design, I don't need to track visited nodes. I simply enqueue neighbors and dequeue until finding `T`."
        },
        {
          "optionId": "ch_viva_1_q6_opt8",
          "optionText": "I will apply Dijkstra's Algorithm with a Priority Queue ordered by edge weights. Initialize distances to infinity except `distance[S] = 0`. Extract minimum distance vertex, relax edges to neighbors. Continue until `T` is extracted from the Priority Queue."
        },
        {
          "optionId": "ch_viva_1_q6_opt9",
          "optionText": "I will first sort all edges in the graph by their source vertex identifier. Then I iterate through the sorted edge list starting from edges originating at `S`. Following sorted edges leads to `T` via the shortest path due to the ordering."
        },
        {
          "optionId": "ch_viva_1_q6_opt10",
          "optionText": "I will use a modified graph search that returns a boolean `true` when the target vertex `T` is found. Starting from `S`, I explore neighbors systematically. Upon finding `T`, I return `true` to indicate a path exists between the vertices."
        },
        {
          "optionId": "ch_viva_1_q6_opt11",
          "optionText": "I will use a Queue data structure and enqueue vertex `S` to begin. While the Queue is not empty, I dequeue a vertex and check if it equals `T`. If the target is found, return success. Otherwise, enqueue all neighbors and continue the search process."
        },
        {
          "optionId": "ch_viva_1_q6_opt12",
          "optionText": "I will implement a traversal with time complexity $O(N^2)$ where N is the vertex count. For each vertex, I examine all other vertices to find connections. This exhaustive pairwise comparison guarantees finding the shortest path to target `T`."
        },
        {
          "optionId": "ch_viva_1_q6_opt13",
          "optionText": "I will simplify the problem by assuming the graph has tree structure with no cycles. Starting from root `S`, I traverse downward following parent-to-child edges. The unique path in a tree guarantees I find the shortest (and only) path to `T`."
        },
        {
          "optionId": "ch_viva_1_q6_opt14",
          "optionText": "I will treat the graph vertices as a linked list structure. Starting at `S`, I follow the `next` pointer of each vertex sequentially. I count the number of `next` traversals until reaching vertex `T`, which gives the shortest path length."
        },
        {
          "optionId": "ch_viva_1_q6_opt15",
          "optionText": "I will use a Priority Queue data structure ordered by vertex identifiers. Initialize by inserting `S` with priority 0. Extract vertices in priority order and insert neighbors with incremented priority. The extraction order determines shortest paths."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q6_opt1", "ch_viva_1_q6_opt2", "ch_viva_1_q6_opt3"],
      "explanationText": "For unweighted graphs, Breadth-First Search (BFS) guarantees finding the shortest path in terms of the number of edges because it explores all vertices at distance k before any vertex at distance k+1. DFS finds *a* path but not necessarily the shortest one since it explores depth-first. The complexity is $O(V+E)$ for adjacency list representation. Tracking distance values or predecessor pointers is necessary to return the path length or reconstruct the actual path. Dijkstra's algorithm is designed for weighted graphs and adds unnecessary complexity for unweighted shortest paths. Approaches that don't track visited nodes will loop infinitely on cyclic graphs."
    }
  ]
}
