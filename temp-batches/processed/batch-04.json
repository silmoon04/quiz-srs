{
  "batchIndex": 4,
  "questions": [
    {
      "chapterIndex": 1,
      "questionIndex": 2,
      "questionId": "ch_viva_2_q13",
      "questionText": "Sketch an algorithm to merge two **Sorted Arrays** into a single **Sorted Array**.",
      "options": [
        {
          "optionId": "ch_viva_2_q13_opt1",
          "optionText": "I initialize a new array of size `A+B` and two pointers `i=0, j=0`. While both pointers are valid, I compare `A[i]` and `B[j]`. I add the smaller one to the new array and increment its pointer. Once one array is exhausted, I copy the remaining elements of the other array."
        },
        {
          "optionId": "ch_viva_2_q13_opt2",
          "optionText": "I use the 'Two Finger' method. I point to the start of both arrays. I repeatedly select the minimum of the two pointed values, append it to my result list, and advance that specific pointer. Finally, I append any 'tail' remaining in the non-empty array."
        },
        {
          "optionId": "ch_viva_2_q13_opt3",
          "optionText": "I iterate both arrays. If `A[i] \\le B[j]`, push `A[i]`. Else push `B[j]`. This linear scan merges them in $O(N)$ time."
        },
        {
          "optionId": "ch_viva_2_q13_opt4",
          "optionText": "I concatenate Array B to the end of Array A to form a combined array, then I apply QuickSort to the entire combined array. This guarantees the final result is sorted. The time complexity is $O((N+M) \\log (N+M))$ which is optimal for sorting."
        },
        {
          "optionId": "ch_viva_2_q13_opt5",
          "optionText": "I iterate through Array B element by element. For each element `B[j]`, I perform a binary search in Array A to find the correct insertion position, then shift all elements after that position to make room and insert `B[j]`. This maintains sorted order throughout."
        },
        {
          "optionId": "ch_viva_2_q13_opt6",
          "optionText": "I use nested loops: an outer loop iterating through Array A with index `i`, and an inner loop iterating through Array B with index `j`. For each pair `(A[i], B[j])`, I compare them and append the smaller one to my result array, building the merged output."
        },
        {
          "optionId": "ch_viva_2_q13_opt7",
          "optionText": "I create a Hash Set and add all elements from both Array A and Array B into it. Since Hash Sets maintain unique elements, I then convert the Hash Set back to an array and sort it. This handles duplicates automatically and produces a merged sorted result."
        },
        {
          "optionId": "ch_viva_2_q13_opt8",
          "optionText": "I use a single index variable `i` to iterate through both arrays simultaneously. At each step, I compare `A[i]` and `B[i]` at the same index position, adding the smaller value to my result array. I continue until `i` reaches the length of the shorter array."
        },
        {
          "optionId": "ch_viva_2_q13_opt9",
          "optionText": "I interleave the two arrays by alternating elements: first `A[0]`, then `B[0]`, then `A[1]`, then `B[1]`, and so on. This creates a merged array with elements from both sources evenly distributed. I continue until both arrays are fully consumed."
        },
        {
          "optionId": "ch_viva_2_q13_opt10",
          "optionText": "I push all elements from both Array A and Array B onto a Stack data structure. Then I repeatedly pop elements from the Stack, which naturally reverses the order. This gives me a sorted merged array since the Stack provides LIFO access to the combined elements."
        },
        {
          "optionId": "ch_viva_2_q13_opt11",
          "optionText": "I create a new result array with size equal to `A.length` only (the length of the first array). I then iterate through Array A, copying each element to the result. For Array B elements, I only add them if there is remaining space in the result array."
        },
        {
          "optionId": "ch_viva_2_q13_opt12",
          "optionText": "I initialize pointers `i=0` and `j=0`, then iterate with a while loop that continues only while `i < A.length` AND `j < B.length`. I compare and add elements during this loop. When either pointer reaches its limit, I stop the algorithm and return my partial result."
        },
        {
          "optionId": "ch_viva_2_q13_opt13",
          "optionText": "I insert all elements from both arrays into a Max-Heap data structure. The Max-Heap maintains the largest element at the root. I then repeatedly extract the maximum and prepend it to my result array, building the merged sorted output from largest to smallest."
        },
        {
          "optionId": "ch_viva_2_q13_opt14",
          "optionText": "I iterate through Array A with pointer `i`. For each element `A[i]` that I move to the result array, I delete it from Array A to free up memory. I do the same for Array B. This in-place deletion approach minimizes memory usage during the merge operation."
        },
        {
          "optionId": "ch_viva_2_q13_opt15",
          "optionText": "I start with pointers at the end of both arrays: `i = A.length - 1` and `j = B.length - 1`. I compare `A[i]` and `B[j]`, taking the larger element and placing it at the end of my result array, then decrementing the corresponding pointer. This builds the result from right to left."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q13_opt1", "ch_viva_2_q13_opt2", "ch_viva_2_q13_opt3"],
      "explanationText": "Since both input arrays are already sorted, the merge operation can be done in linear time, $O(N+M)$, using the 'Two Finger' approach. The correct approach uses two independent pointers (one for each array), compares elements at the current positions, appends the smaller one to the result, advances that pointer, and finally copies any remaining elements from the non-exhausted array. This is the core step of Merge Sort and is significantly faster than concatenating and re-sorting ($O((N+M) \\log (N+M))$). Approaches that use the same index for both arrays, interleave without comparison, or ignore remaining elements after one array is exhausted will not produce a correctly sorted result."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 3,
      "questionId": "ch_viva_2_q14",
      "questionText": "Sketch an algorithm to implement a **Queue** (FIFO) using only **two Stacks**.",
      "options": [
        {
          "optionId": "ch_viva_2_q14_opt1",
          "optionText": "I maintain an `InStack` and an `OutStack`. For `enqueue`, I simply push to `InStack`. For `dequeue`, I check if `OutStack` is empty. If it is, I pop *all* elements from `InStack` and push them to `OutStack` (reversing order). Then I pop from `OutStack`."
        },
        {
          "optionId": "ch_viva_2_q14_opt2",
          "optionText": "I separate concerns: Stack A is for writing, Stack B is for reading. When the user asks to read (dequeue) and Stack B is empty, I 'pour' the entire contents of A into B. This reverses the LIFO order to FIFO. I then pop from B."
        },
        {
          "optionId": "ch_viva_2_q14_opt3",
          "optionText": "I define `push` as `s1.push(x)`. I define `pop`: If `s2` is empty, transfer `s1` to `s2`. Return `s2.pop()`. This provides amortized $O(1)$ time complexity."
        },
        {
          "optionId": "ch_viva_2_q14_opt4",
          "optionText": "I partition elements by their value: even-numbered elements go to Stack 1, and odd-numbered elements go to Stack 2. For dequeue operations, I alternate between popping from Stack 1 and Stack 2 to maintain the original insertion order across both stacks."
        },
        {
          "optionId": "ch_viva_2_q14_opt5",
          "optionText": "For the enqueue operation, I push the new element onto Stack 1. For the dequeue operation, I pop directly from Stack 1 and return that element. This approach uses only one stack actively while keeping Stack 2 reserved for overflow situations."
        },
        {
          "optionId": "ch_viva_2_q14_opt6",
          "optionText": "For enqueue, I push to Stack 1. For each dequeue operation, I pop all elements from Stack 1 and push them to Stack 2, then pop the top of Stack 2. After returning this element, I pop all elements from Stack 2 and push them back to Stack 1 to restore the original order."
        },
        {
          "optionId": "ch_viva_2_q14_opt7",
          "optionText": "I designate Stack 1 as the 'Head' pointer representing the front of the queue, and Stack 2 as the 'Tail' pointer representing the back. Enqueue operations push to the Tail stack, while dequeue operations pop from the Head stack, with periodic synchronization between them."
        },
        {
          "optionId": "ch_viva_2_q14_opt8",
          "optionText": "For enqueue, I push the new element to Stack 1. For dequeue, I pop a single element from Stack 1 and push it to Stack 2, then immediately pop from Stack 2 and return that value. This single-element transfer happens on every dequeue operation."
        },
        {
          "optionId": "ch_viva_2_q14_opt9",
          "optionText": "I alternate my push operations between Stack 1 and Stack 2 based on an internal counter. Even-indexed enqueue operations go to Stack 1, odd-indexed ones to Stack 2. For dequeue, I similarly alternate between popping from Stack 1 and Stack 2."
        },
        {
          "optionId": "ch_viva_2_q14_opt10",
          "optionText": "I use recursion to simulate the behavior of the second stack. For each dequeue, I recursively pop elements from Stack 1 until I reach the bottom element, return it, then recursively push the other elements back. The call stack serves as my implicit second stack."
        },
        {
          "optionId": "ch_viva_2_q14_opt11",
          "optionText": "I maintain Stack 1 for input operations. Stack 2 is kept sorted at all times: whenever I transfer from Stack 1 to Stack 2, I insert each element in its correct sorted position. Dequeue always returns the minimum element from the sorted Stack 2."
        },
        {
          "optionId": "ch_viva_2_q14_opt12",
          "optionText": "I define a maximum capacity for Stack 1. Elements are pushed to Stack 1 for enqueue. Only when Stack 1 reaches its maximum capacity do I transfer all elements to Stack 2. Dequeue pops from Stack 2 if non-empty, otherwise from Stack 1."
        },
        {
          "optionId": "ch_viva_2_q14_opt13",
          "optionText": "For each enqueue operation, I first pop all existing elements from Stack 1 and push them onto Stack 2. Then I push the new element onto the now-empty Stack 1. Finally, I pop all elements from Stack 2 and push them back onto Stack 1, placing the new element at the bottom."
        },
        {
          "optionId": "ch_viva_2_q14_opt14",
          "optionText": "For every enqueue operation, I push the new element to both Stack 1 and Stack 2 simultaneously to maintain a backup copy. For dequeue, I pop from Stack 1 and discard the corresponding element from Stack 2 to keep them synchronized."
        },
        {
          "optionId": "ch_viva_2_q14_opt15",
          "optionText": "For the dequeue operation, I simply call `Stack1.pop()` and return the result directly. The second stack is maintained as a backup that mirrors Stack 1, used only for recovery in case of errors or for peek operations without modifying the primary stack."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q14_opt1", "ch_viva_2_q14_opt2", "ch_viva_2_q14_opt3"],
      "explanationText": "The core idea is that transferring elements from one stack to another reverses their order. By using one stack for input (enqueue) and one for output (dequeue), we achieve FIFO behavior. The correct approach pushes to the input stack on enqueue, and on dequeue, transfers all elements to the output stack only when the output stack is empty, then pops from the output stack. The transfer operation is $O(N)$, but since each element is transferred only once, the amortized time complexity for both push and pop is $O(1)$. Approaches that transfer elements back and forth on every operation, pop directly from the input stack, or alternate between stacks without proper reversal will not achieve correct FIFO behavior or efficient performance."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 4,
      "questionId": "ch_viva_2_q15",
      "questionText": "Sketch an algorithm using a **Stack** to check if a string of parentheses `()[]{}` is balanced.",
      "options": [
        {
          "optionId": "ch_viva_2_q15_opt1",
          "optionText": "I initialize an empty Stack. I loop through chars. If '(', '[', '{', I push it. If ')', ']', '}', I check if stack is empty (return false). Else, I pop. If the popped char doesn't match the current closing bracket type, return False. Finally, return `stack.isEmpty()`."
        },
        {
          "optionId": "ch_viva_2_q15_opt2",
          "optionText": "I use a Stack to store expected closing brackets. If I see `(`, I push `)`. If I see `[`, push `]`. If I see a closing bracket, I pop and compare. If they differ or stack is empty, it's invalid. At end, stack must be empty."
        },
        {
          "optionId": "ch_viva_2_q15_opt3",
          "optionText": "I iterate through the string. Open brackets go onto the Stack. For a closing bracket, I pop the top. If the pair is not a valid match (like `(` and `]`), I fail immediately. Also, if I finish the string and the stack still has items, it's invalid."
        },
        {
          "optionId": "ch_viva_2_q15_opt4",
          "optionText": "I maintain separate counters for each bracket type: `openParens`, `closeParens`, `openBrackets`, `closeBrackets`, `openBraces`, `closeBraces`. I iterate through the string incrementing the appropriate counter for each character. At the end, I verify that open counts equal close counts for each type."
        },
        {
          "optionId": "ch_viva_2_q15_opt5",
          "optionText": "I use a Queue data structure instead of a Stack. I enqueue opening brackets as I encounter them. When I see a closing bracket, I dequeue from the front and check if it matches. The FIFO property ensures brackets are matched in the order they were opened."
        },
        {
          "optionId": "ch_viva_2_q15_opt6",
          "optionText": "I push every character in the string onto a Stack, including both opening and closing brackets. Then I pop all elements and check if the sequence forms a palindrome. A balanced string should read the same forwards and backwards when considering bracket symmetry."
        },
        {
          "optionId": "ch_viva_2_q15_opt7",
          "optionText": "I iterate through the string character by character. When I encounter an opening bracket, I push it onto the Stack. When I encounter a closing bracket, I pop from the Stack. At the end, if the Stack is not empty, I return False; otherwise True."
        },
        {
          "optionId": "ch_viva_2_q15_opt8",
          "optionText": "I split the string into two halves at the midpoint. I push the first half onto a Stack, then iterate through the second half. For each character in the second half, I pop from the Stack and verify they form matching pairs. This works because balanced strings are symmetric."
        },
        {
          "optionId": "ch_viva_2_q15_opt9",
          "optionText": "I maintain two separate Stacks: one dedicated to storing opening brackets and another for storing closing brackets. As I iterate, opening brackets go to Stack 1 and closing brackets go to Stack 2. At the end, I compare the two stacks element by element for matches."
        },
        {
          "optionId": "ch_viva_2_q15_opt10",
          "optionText": "I push closing brackets onto the Stack when I encounter them, rather than opening brackets. When I see an opening bracket, I pop from the Stack and check if it's the corresponding closing bracket. I return True if all opening brackets find their matching closers on the Stack."
        },
        {
          "optionId": "ch_viva_2_q15_opt11",
          "optionText": "I iterate through the string and push opening brackets to the Stack. When encountering a closing bracket, I call `stack.pop()`. If pop returns null or undefined (indicating empty stack), I ignore this case and continue processing the remaining characters without returning false."
        },
        {
          "optionId": "ch_viva_2_q15_opt12",
          "optionText": "I use two pointers starting at opposite ends of the string: one at the beginning and one at the end. I move them inward, comparing characters at each position. If the left pointer sees an opening bracket, the right pointer should see its corresponding closing bracket."
        },
        {
          "optionId": "ch_viva_2_q15_opt13",
          "optionText": "I repeatedly search for adjacent matching pairs like `()`, `[]`, or `{}` in the string and replace them with an empty string. I continue this process in a loop until no more replacements can be made. If the final string is empty, the original was balanced."
        },
        {
          "optionId": "ch_viva_2_q15_opt14",
          "optionText": "I construct a regular expression pattern that matches balanced parentheses, such as `/^(\\((?:[^()]*|(?1))*\\))*$/`. I apply this regex to the input string using a pattern matching library. If the regex matches the entire string, the parentheses are balanced."
        },
        {
          "optionId": "ch_viva_2_q15_opt15",
          "optionText": "I iterate through the string and push opening brackets onto the Stack. When I encounter a closing bracket, I first peek at the top of the Stack. If the peek value matches the expected opening bracket for this closer, I pop it. Otherwise, I continue without popping."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q15_opt1", "ch_viva_2_q15_opt2", "ch_viva_2_q15_opt3"],
      "explanationText": "A Stack is ideal for checking nested structures because of its LIFO property (the last bracket opened must be the first one closed). The correct approach pushes opening brackets onto the stack, and for each closing bracket, pops from the stack and verifies the popped bracket matches the expected type. The algorithm must handle three failure conditions: 1) Trying to pop from an empty stack (e.g., unmatched closing bracket `)`), 2) Mismatched bracket types (e.g., `([)]` where `[` is popped but `)` is encountered), and 3) Stack not empty at the end (e.g., unclosed opening brackets `((`). Simply counting brackets, using a Queue, ignoring empty stack pops, or skipping the type-matching check will all fail to detect certain invalid cases."
    }
  ]
}
