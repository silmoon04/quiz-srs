{
  "batchIndex": 3,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 9,
      "questionId": "ch_viva_1_q10",
      "questionText": "Sketch an algorithm to **delete** a specific node `P` from a **Doubly Linked List**, given only the pointer to `P`.",
      "options": [
        {
          "optionId": "ch_viva_1_q10_opt1",
          "optionText": "I check if `P.prev` exists. If so, `P.prev.next = P.next`. If not, `P` was head (update head). Then check if `P.next` exists. If so, `P.next.prev = P.prev`. If not, `P` was tail. Finally, nullify `P`'s pointers."
        },
        {
          "optionId": "ch_viva_1_q10_opt2",
          "optionText": "Since I have access to neighbors, I link the node *before* `P` directly to the node *after* `P`, and vice versa. This effectively bypasses `P`. This is an $O(1)$ operation."
        },
        {
          "optionId": "ch_viva_1_q10_opt3",
          "optionText": "I identify `left = P.prev` and `right = P.next`. If `left` is not null, `left.next = right`. If `right` is not null, `right.prev = left`. The node is now detached."
        },
        {
          "optionId": "ch_viva_1_q10_opt4",
          "optionText": "I will traverse from Head to find `P` by iterating through each node sequentially. Once found, I store the previous node reference and update `previous.next = P.next`. This approach requires $O(N)$ time complexity for the search phase."
        },
        {
          "optionId": "ch_viva_1_q10_opt5",
          "optionText": "I will set `P = null` directly to remove the node from memory. This deallocates the node and the garbage collector will handle cleanup. The list structure automatically adjusts to bypass the deleted node."
        },
        {
          "optionId": "ch_viva_1_q10_opt6",
          "optionText": "I will set `P.next.prev = P.prev` to update only the backward pointer of the successor node. This creates a partial link that allows traversal in the reverse direction while maintaining the original forward chain intact."
        },
        {
          "optionId": "ch_viva_1_q10_opt7",
          "optionText": "I will copy the data from `P.next` into `P`, then delete the next node by setting `P.next = P.next.next` and updating the prev pointer. This technique works for singly linked lists and avoids needing access to the previous node."
        },
        {
          "optionId": "ch_viva_1_q10_opt8",
          "optionText": "I will delete the entire list by traversing from head to tail, freeing each node sequentially. After complete traversal, I set head and tail to null, then recreate the list without node `P` from saved backup data."
        },
        {
          "optionId": "ch_viva_1_q10_opt9",
          "optionText": "I will use a Stack to track all previous nodes during traversal from head. When I reach `P`, I pop from the stack to get the predecessor, update its next pointer, and then update `P.next.prev` accordingly."
        },
        {
          "optionId": "ch_viva_1_q10_opt10",
          "optionText": "I will swap `P` with the Tail node by exchanging their data values, then delete the tail by setting the second-to-last node's next pointer to null and updating the tail reference. This maintains $O(1)$ deletion."
        },
        {
          "optionId": "ch_viva_1_q10_opt11",
          "optionText": "I will return the value stored in `P` after storing it in a temporary variable, then let the garbage collector handle the node. The calling function can use this returned value to verify the deletion was successful."
        },
        {
          "optionId": "ch_viva_1_q10_opt12",
          "optionText": "The deletion requires $O(N)$ complexity because I must first traverse the list to locate node `P` before performing any pointer updates. Without traversal, we cannot determine P's position relative to head and tail."
        },
        {
          "optionId": "ch_viva_1_q10_opt13",
          "optionText": "I assume `P` is always in the middle of the list, so I can safely perform `P.prev.next = P.next` and `P.next.prev = P.prev` without any null checks. Edge cases for head and tail are handled separately."
        },
        {
          "optionId": "ch_viva_1_q10_opt14",
          "optionText": "I will link `P.prev` to `P.prev.prev` by setting `P.prev.next = P.prev.prev`, effectively removing the node before `P` from the chain. Then I update `P.prev = P.prev.prev` to maintain the doubly linked structure."
        },
        {
          "optionId": "ch_viva_1_q10_opt15",
          "optionText": "I will check if `P` is null at the start and return immediately if so. If `P` is not null, I proceed to traverse the list from the head to find P's position before performing any pointer manipulation operations."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q10_opt1", "ch_viva_1_q10_opt2", "ch_viva_1_q10_opt3"],
      "explanationText": "Since a Doubly Linked List provides access to both `prev` and `next` pointers, deletion can be performed in $O(1)$ time by simply updating the neighbors' pointers to bypass the node `P`. The correct approach checks if `P.prev` exists and updates `P.prev.next = P.next`, then checks if `P.next` exists and updates `P.next.prev = P.prev`. Edge cases (deleting head or tail) must be handled by checking for null pointers. Traversal from head is unnecessary since we already have a direct pointer to `P`."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 0,
      "questionId": "ch_viva_2_q11",
      "questionText": "Sketch an algorithm to determine if a **Singly Linked List** contains a cycle (a loop). You cannot modify the list structure.",
      "options": [
        {
          "optionId": "ch_viva_2_q11_opt1",
          "optionText": "I will use **Floyd's Cycle-Finding Algorithm** (Tortoise and Hare). I initialize two pointers, `slow` and `fast`, both at the head. I loop while `fast` and `fast.next` are not null. `slow` moves 1 step; `fast` moves 2 steps. If `slow == fast`, I return True. If the loop ends, I return False."
        },
        {
          "optionId": "ch_viva_2_q11_opt2",
          "optionText": "I will use a **Hash Set** of Node References (not values). I traverse the list. For every node, I check if the *pointer address* is already in the Set. If yes, cycle detected. If no, add it. If I hit null, return False. (Note: This uses $O(N)$ space)."
        },
        {
          "optionId": "ch_viva_2_q11_opt3",
          "optionText": "I will use two pointers. `Fast` moves twice as fast as `Slow`. If there is a cycle, `Fast` will eventually 'lap' (catch up to) `Slow` inside the loop. If `Fast` reaches null, the list is linear."
        },
        {
          "optionId": "ch_viva_2_q11_opt4",
          "optionText": "I will traverse the list starting from head and check if `current.next == head` at each step. If this condition becomes true at any point, the list contains a cycle that loops back to the beginning. This detects circular linked lists specifically."
        },
        {
          "optionId": "ch_viva_2_q11_opt5",
          "optionText": "I will iterate through the list using a timeout mechanism (e.g., 5 seconds). If the traversal does not complete within the allotted time, I conclude there is a cycle. If it terminates normally, the list is acyclic."
        },
        {
          "optionId": "ch_viva_2_q11_opt6",
          "optionText": "I will traverse the list and mark each node as 'visited' by adding a boolean flag field to the node structure. If I encounter a node with the flag already set to true, a cycle exists. This requires modifying the node structure."
        },
        {
          "optionId": "ch_viva_2_q11_opt7",
          "optionText": "I will check if the memory addresses of `next` pointers are strictly increasing as I traverse the list. If addresses ever decrease or repeat, this indicates the list loops back to a previously visited memory location, confirming a cycle."
        },
        {
          "optionId": "ch_viva_2_q11_opt8",
          "optionText": "I will use recursion to traverse the list, passing the current node to each recursive call. If the recursion causes a stack overflow exception, this indicates an infinite loop and therefore a cycle exists in the list structure."
        },
        {
          "optionId": "ch_viva_2_q11_opt9",
          "optionText": "I will compare each current node with all previously visited nodes by maintaining a previous pointer. At each step, I traverse backwards through my recorded path to check for duplicates, detecting cycles through repeated encounters."
        },
        {
          "optionId": "ch_viva_2_q11_opt10",
          "optionText": "I will reverse the entire linked list using the standard three-pointer technique. After reversal, if I end up back at the original head node, the list must contain a cycle. This works because reversal in a cyclic list returns to the start."
        },
        {
          "optionId": "ch_viva_2_q11_opt11",
          "optionText": "I will use two pointers starting from opposite ends of the list, one from head moving forward and one from tail moving backward. If these pointers meet in the middle without passing each other, a cycle exists."
        },
        {
          "optionId": "ch_viva_2_q11_opt12",
          "optionText": "I will calculate the length of the list by counting nodes during traversal. If the count exceeds a predetermined maximum threshold or continues indefinitely, I conclude that the list contains a cycle and return true."
        },
        {
          "optionId": "ch_viva_2_q11_opt13",
          "optionText": "I will traverse to the end of the list and check if the last node's next pointer is null. If the final node points to null, the list is acyclic. If it points to any other node, the list contains a cycle."
        },
        {
          "optionId": "ch_viva_2_q11_opt14",
          "optionText": "I will use a Hash Map to store the data values of each visited node as keys. During traversal, if I encounter a value that already exists in the map, this indicates a repeated node and therefore a cycle in the list."
        },
        {
          "optionId": "ch_viva_2_q11_opt15",
          "optionText": "I will delete nodes as I traverse through the list by setting each visited node to null. If I eventually hit a null pointer naturally, no cycle exists. This approach modifies the list but guarantees cycle detection."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q11_opt1", "ch_viva_2_q11_opt2", "ch_viva_2_q11_opt3"],
      "explanationText": "The Tortoise and Hare algorithm (Floyd's Cycle Detection) is the optimal solution, providing $O(N)$ time complexity and $O(1)$ space complexity. It uses two pointers moving at different speeds—if a cycle exists, the fast pointer will eventually catch up to the slow pointer. Using a Hash Set of node references is also valid with $O(N)$ time but requires $O(N)$ space to store visited node addresses. Approaches that modify the list structure violate the constraint, and checking only if the last node points to head misses cycles that don't include the head."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 1,
      "questionId": "ch_viva_2_q12",
      "questionText": "Sketch an algorithm to **reverse** a **Singly Linked List** in-place (without creating a new list).",
      "options": [
        {
          "optionId": "ch_viva_2_q12_opt1",
          "optionText": "I initialize three pointers: `prev` (null), `curr` (head), and `next` (null). I loop while `curr` is not null. Inside: 1. Save `next = curr.next`. 2. Reverse link `curr.next = prev`. 3. Move `prev = curr`. 4. Move `curr = next`. Finally, update `head = prev`."
        },
        {
          "optionId": "ch_viva_2_q12_opt2",
          "optionText": "I utilize a standard iterative pointer reversal. I maintain a `previous` pointer. As I traverse with `current`, I temporarily store the `future` node. I redirect `current` to point to `previous`, then shift our window of three pointers one step forward."
        },
        {
          "optionId": "ch_viva_2_q12_opt3",
          "optionText": "I use recursion. Base case: if head is empty or single, return it. Recursive step: `newHead = reverse(head.next)`. Then perform the surgery: `head.next.next = head` and `head.next = null`. Return `newHead`."
        },
        {
          "optionId": "ch_viva_2_q12_opt4",
          "optionText": "I will swap the `head` and `tail` pointers directly by exchanging their references. After the swap, head points to the last node and tail points to the first node. The intermediate links remain unchanged, achieving an $O(1)$ reversal."
        },
        {
          "optionId": "ch_viva_2_q12_opt5",
          "optionText": "I will traverse the list and at each node, I set `node.next = node.prev` to reverse the link direction. Since singly linked lists have a prev pointer, I can access the previous node directly and redirect the next pointer backward."
        },
        {
          "optionId": "ch_viva_2_q12_opt6",
          "optionText": "I will use a Stack data structure to store all node values during a forward traversal. Then I traverse the list again, popping values from the stack and overwriting each node's data. This reverses the values while keeping pointers intact."
        },
        {
          "optionId": "ch_viva_2_q12_opt7",
          "optionText": "I will iterate through using the pattern: `curr.next = prev; prev = curr; curr = curr.next` executed in that exact order. Each iteration reverses one link. After the loop completes, prev holds the new head of the reversed list."
        },
        {
          "optionId": "ch_viva_2_q12_opt8",
          "optionText": "I will swap the first node with the last, the second with the second-last, and continue toward the middle. I use two pointers from both ends, swapping data values at each pair until the pointers meet or cross in the center."
        },
        {
          "optionId": "ch_viva_2_q12_opt9",
          "optionText": "I will use recursion with the pattern `head.next = reverse(head)` where the recursive call reverses all nodes starting from head. The base case returns null, and each recursive frame links the current node to the reversed sublist."
        },
        {
          "optionId": "ch_viva_2_q12_opt10",
          "optionText": "I will create a new linked list and add each traversed node to the head of this new list. Since each insertion happens at the head, the final new list is the reverse of the original. Then I free the original list nodes."
        },
        {
          "optionId": "ch_viva_2_q12_opt11",
          "optionText": "I will apply Doubly Linked List reversal logic by treating the singly linked list as if it had prev pointers. I simulate the backward traversal using a stack, then update all next pointers based on the simulated prev information."
        },
        {
          "optionId": "ch_viva_2_q12_opt12",
          "optionText": "I will iterate using index `i` from 0 to N, and at each position I swap the `next` pointers of nodes at position i and N-i. This symmetric swapping continues until i reaches the midpoint, completing the reversal in N/2 iterations."
        },
        {
          "optionId": "ch_viva_2_q12_opt13",
          "optionText": "I will point the head's next to null to terminate it, then set the tail's reference equal to the former head. This creates a reversed list where the old tail becomes the new starting point and the old head becomes the terminal node."
        },
        {
          "optionId": "ch_viva_2_q12_opt14",
          "optionText": "I will traverse to the end of the list first, storing all node references in an array. Then I work backwards through the array, updating each node's next pointer to point to the previous array element, reversing all links."
        },
        {
          "optionId": "ch_viva_2_q12_opt15",
          "optionText": "I will use a temporary variable to swap `node` and `node.next` at each position. The swap operation exchanges the two node positions, and repeating this for all consecutive pairs bubbles the first element to the end, reversing the list."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q12_opt1", "ch_viva_2_q12_opt2", "ch_viva_2_q12_opt3"],
      "explanationText": "The iterative three-pointer solution is the most common and efficient approach, using $O(N)$ time and $O(1)$ space by maintaining `prev`, `curr`, and `next` pointers. At each step, you save the next node, reverse the current link, and advance all pointers. The recursive solution is also valid—it recurses to the end, then on the way back, each node links its successor back to itself. The recursive approach uses $O(N)$ stack space. Approaches using stacks to store values or creating new lists violate the in-place constraint, and swapping head/tail pointers alone doesn't reverse intermediate links."
    }
  ]
}
