{
  "batchIndex": 1,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 3,
      "questionId": "ch_viva_1_q4",
      "questionText": "Sketch an **iterative** (non-recursive) algorithm to find the **sum** of all keys in a **Binary Tree**.",
      "options": [
        {
          "optionId": "ch_viva_1_q4_opt1",
          "optionText": "I will use a **Queue** for Level-Order Traversal. Initialize `sum = 0`. Enqueue `root`. While Queue is not empty: Dequeue a node, add its key to `sum`. If `node.left` exists, Enqueue it. If `node.right` exists, Enqueue it. Return `sum`."
        },
        {
          "optionId": "ch_viva_1_q4_opt2",
          "optionText": "I will use a **Stack** for Depth-First Traversal. Initialize `sum = 0`. Push `root`. While Stack has items: Pop `current`. `sum += current.key`. Push `current.right` and `current.left` if they are not null. Return `sum`."
        },
        {
          "optionId": "ch_viva_1_q4_opt3",
          "optionText": "I will initialize a `total` variable. Using a standard iterative traversal (like BFS with a Queue), I visit every node exactly once. At each visit, I accumulate the value into `total`. Finally, I return `total`."
        },
        {
          "optionId": "ch_viva_1_q4_opt4",
          "optionText": "I will simply loop through the tree `for node in tree`..."
        },
        {
          "optionId": "ch_viva_1_q4_opt5",
          "optionText": "I will use `return sum(left) + sum(right)`."
        },
        {
          "optionId": "ch_viva_1_q4_opt6",
          "optionText": "I will use a Stack. Push root. Pop, add to sum. Push left child, Push right child. Return sum."
        },
        {
          "optionId": "ch_viva_1_q4_opt7",
          "optionText": "I will use a Binary Search to sum the nodes."
        },
        {
          "optionId": "ch_viva_1_q4_opt8",
          "optionText": "I will traverse the tree using pointers `current = current.left`."
        },
        {
          "optionId": "ch_viva_1_q4_opt9",
          "optionText": "I will convert the tree to an array using `tree.toArray()`."
        },
        {
          "optionId": "ch_viva_1_q4_opt10",
          "optionText": "Complexity is $O(\\log N)$."
        },
        {
          "optionId": "ch_viva_1_q4_opt11",
          "optionText": "I will use a Queue to perform DFS."
        },
        {
          "optionId": "ch_viva_1_q4_opt12",
          "optionText": "I initialize sum to 0. While root is not null, add root, root = root.next."
        },
        {
          "optionId": "ch_viva_1_q4_opt13",
          "optionText": "I will use a Hash Map to store visited nodes."
        },
        {
          "optionId": "ch_viva_1_q4_opt14",
          "optionText": "I will delete nodes as I sum them to save space."
        },
        {
          "optionId": "ch_viva_1_q4_opt15",
          "optionText": "I will start at the root and keep adding `node.key` until `node` is null."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q4_opt1", "ch_viva_1_q4_opt2", "ch_viva_1_q4_opt3"],
      "explanationText": "Iterative traversal requires an auxiliary data structure (Stack for DFS or Queue for BFS) to store unvisited nodes. Since summing requires visiting every node, the time complexity is $O(N)$. Option 6 is logically correct but lacks the necessary null checks for children."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 4,
      "questionId": "ch_viva_1_q5",
      "questionText": "Sketch an algorithm to **sort** an array of integers in **descending** order using a **Min-Heap**.",
      "options": [
        {
          "optionId": "ch_viva_1_q5_opt1",
          "optionText": "I will create an empty Min-Heap. I insert all array elements into it. Then, I iterate an index `i` starting from the array's **length - 1 down to 0**. At each step, I call `extractMin()` and place the result at `array[i]`. This fills the array with the largest elements at the start and smallest at the end."
        },
        {
          "optionId": "ch_viva_1_q5_opt2",
          "optionText": "Alternatively, I could use a **Max-Heap**. I insert all elements. Then I call `extractMax()` repeatedly and fill the array from index 0 upwards. This results in descending order."
        },
        {
          "optionId": "ch_viva_1_q5_opt3",
          "optionText": "I will Heapify the array into a Min-Heap. Then, I will continuously extract the minimum element. Since I need descending order, I will use a Stack to store the extracted elements temporarily, then pop them back into the array."
        },
        {
          "optionId": "ch_viva_1_q5_opt4",
          "optionText": "I insert everything into the Min-Heap, then `extractMin` and put them in the array from index 0 upwards."
        },
        {
          "optionId": "ch_viva_1_q5_opt5",
          "optionText": "I use `binarySearch` on the Heap to find the largest element."
        },
        {
          "optionId": "ch_viva_1_q5_opt6",
          "optionText": "I simply traverse the Heap array and copy elements."
        },
        {
          "optionId": "ch_viva_1_q5_opt7",
          "optionText": "I insert into the Heap, then use Bubble Sort."
        },
        {
          "optionId": "ch_viva_1_q5_opt8",
          "optionText": "I extract elements and push them onto a Stack, then pop to array."
        },
        {
          "optionId": "ch_viva_1_q5_opt9",
          "optionText": "Time complexity is $O(N)$."
        },
        {
          "optionId": "ch_viva_1_q5_opt10",
          "optionText": "I check the leaf nodes for the maximum value."
        },
        {
          "optionId": "ch_viva_1_q5_opt11",
          "optionText": "I use a Min-Heap but negate the numbers before inserting."
        },
        {
          "optionId": "ch_viva_1_q5_opt12",
          "optionText": "I extract root, then swap root with random element."
        },
        {
          "optionId": "ch_viva_1_q5_opt13",
          "optionText": "I delete the heap and create a sorted list."
        },
        {
          "optionId": "ch_viva_1_q5_opt14",
          "optionText": "I assume the Heap is already sorted."
        },
        {
          "optionId": "ch_viva_1_q5_opt15",
          "optionText": "I return the underlying array of the Heap."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q5_opt1", "ch_viva_1_q5_opt2", "ch_viva_1_q5_opt3"],
      "explanationText": "A Min-Heap naturally extracts elements in ascending order. To achieve descending order, you must either use a Max-Heap (Option 2) or reverse the output of the Min-Heap, either by filling the array backwards (Option 1) or using an auxiliary Stack (Option 3). All methods result in $O(N \\log N)$ time complexity."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 5,
      "questionId": "ch_viva_1_q6",
      "questionText": "Given a Graph (Adjacency List) and a starting vertex `S`, sketch an algorithm to find the **shortest path** (number of edges) from `S` to a target `T`.",
      "options": [
        {
          "optionId": "ch_viva_1_q6_opt1",
          "optionText": "I will use **BFS** with a Queue. I'll also maintain a `distance` Map (or array) initialized to -1. Set `distance[S] = 0`. Enqueue `S`. While Queue not empty: Dequeue `u`. If `u == T`, return `distance[u]`. For each neighbor `v` of `u`: If `v` is unvisited, set `distance[v] = distance[u] + 1` and Enqueue `v`."
        },
        {
          "optionId": "ch_viva_1_q6_opt2",
          "optionText": "I initialize a Queue for the traversal and a Set for visited nodes. I start a level-counter at 0. I process nodes level-by-level (using the queue size). If I encounter `T`, I return the current level count. If the queue empties, `T` is unreachable."
        },
        {
          "optionId": "ch_viva_1_q6_opt3",
          "optionText": "I employ a Breadth-First Search strategy. I enqueue the start node `S`. I keep track of `predecessor` pointers. When I find `T`, I backtrack using the predecessors to count the steps. This ensures the shortest path in an unweighted graph."
        },
        {
          "optionId": "ch_viva_1_q6_opt4",
          "optionText": "I will use DFS (Stack) to search for the node."
        },
        {
          "optionId": "ch_viva_1_q6_opt5",
          "optionText": "I will traverse the adjacency list linearly."
        },
        {
          "optionId": "ch_viva_1_q6_opt6",
          "optionText": "I will use recursion."
        },
        {
          "optionId": "ch_viva_1_q6_opt7",
          "optionText": "I don't need to mark visited nodes because it's a list."
        },
        {
          "optionId": "ch_viva_1_q6_opt8",
          "optionText": "I will use Dijkstra's Algorithm."
        },
        {
          "optionId": "ch_viva_1_q6_opt9",
          "optionText": "I will sort the edges."
        },
        {
          "optionId": "ch_viva_1_q6_opt10",
          "optionText": "I will return `true` if found."
        },
        {
          "optionId": "ch_viva_1_q6_opt11",
          "optionText": "I use a Queue, enqueue S. While queue not empty, dequeue, check if T. If yes, return. Else enqueue neighbors."
        },
        {
          "optionId": "ch_viva_1_q6_opt12",
          "optionText": "Time complexity is $O(N^2)$."
        },
        {
          "optionId": "ch_viva_1_q6_opt13",
          "optionText": "I assume the graph is a tree."
        },
        {
          "optionId": "ch_viva_1_q6_opt14",
          "optionText": "I check `S.next` until I find `T`."
        },
        {
          "optionId": "ch_viva_1_q6_opt15",
          "optionText": "I use a Priority Queue."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q6_opt1", "ch_viva_1_q6_opt2", "ch_viva_1_q6_opt3"],
      "explanationText": "For unweighted graphs, Breadth-First Search (BFS) guarantees finding the shortest path in terms of the number of edges. DFS only finds *a* path. The complexity is $O(V+E)$. Tracking distance or predecessors is necessary to return the path length or the path itself."
    }
  ]
}
