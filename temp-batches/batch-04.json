{
  "batchIndex": 4,
  "questions": [
    {
      "chapterIndex": 1,
      "questionIndex": 2,
      "questionId": "ch_viva_2_q13",
      "questionText": "Sketch an algorithm to merge two **Sorted Arrays** into a single **Sorted Array**.",
      "options": [
        {
          "optionId": "ch_viva_2_q13_opt1",
          "optionText": "I initialize a new array of size `A+B` and two pointers `i=0, j=0`. While both pointers are valid, I compare `A[i]` and `B[j]`. I add the smaller one to the new array and increment its pointer. Once one array is exhausted, I copy the remaining elements of the other array."
        },
        {
          "optionId": "ch_viva_2_q13_opt2",
          "optionText": "I use the 'Two Finger' method. I point to the start of both arrays. I repeatedly select the minimum of the two pointed values, append it to my result list, and advance that specific pointer. Finally, I append any 'tail' remaining in the non-empty array."
        },
        {
          "optionId": "ch_viva_2_q13_opt3",
          "optionText": "I iterate both arrays. If `A[i] \\le B[j]`, push `A[i]`. Else push `B[j]`. This linear scan merges them in $O(N)$ time."
        },
        {
          "optionId": "ch_viva_2_q13_opt4",
          "optionText": "I will append Array B to Array A and call `QuickSort`."
        },
        {
          "optionId": "ch_viva_2_q13_opt5",
          "optionText": "I will insert elements of Array B into Array A one by one."
        },
        {
          "optionId": "ch_viva_2_q13_opt6",
          "optionText": "I will use two loops: `for i in A` and `for j in B`."
        },
        {
          "optionId": "ch_viva_2_q13_opt7",
          "optionText": "I will use a Hash Set to merge them."
        },
        {
          "optionId": "ch_viva_2_q13_opt8",
          "optionText": "I will compare `A[i]` and `B[i]` and add the smaller one."
        },
        {
          "optionId": "ch_viva_2_q13_opt9",
          "optionText": "I will zip them together `A[0], B[0], A[1], B[1]`..."
        },
        {
          "optionId": "ch_viva_2_q13_opt10",
          "optionText": "I will use a Stack to sort them."
        },
        {
          "optionId": "ch_viva_2_q13_opt11",
          "optionText": "I will create a new array of size `A.length`."
        },
        {
          "optionId": "ch_viva_2_q13_opt12",
          "optionText": "I will iterate until `i < A.length` AND `j < B.length`, then stop."
        },
        {
          "optionId": "ch_viva_2_q13_opt13",
          "optionText": "I will use a Max-Heap."
        },
        {
          "optionId": "ch_viva_2_q13_opt14",
          "optionText": "I will delete elements from A as I move them."
        },
        {
          "optionId": "ch_viva_2_q13_opt15",
          "optionText": "I will start from the end of both arrays."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q13_opt1", "ch_viva_2_q13_opt2", "ch_viva_2_q13_opt3"],
      "explanationText": "Since both input arrays are already sorted, the merge operation can be done in linear time, $O(N+M)$, using the 'Two Finger' approach. This is the core step of Merge Sort and is significantly faster than sorting the combined array ($O((N+M) \\log (N+M))$)."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 3,
      "questionId": "ch_viva_2_q14",
      "questionText": "Sketch an algorithm to implement a **Queue** (FIFO) using only **two Stacks**.",
      "options": [
        {
          "optionId": "ch_viva_2_q14_opt1",
          "optionText": "I maintain an `InStack` and an `OutStack`. For `enqueue`, I simply push to `InStack`. For `dequeue`, I check if `OutStack` is empty. If it is, I pop *all* elements from `InStack` and push them to `OutStack` (reversing order). Then I pop from `OutStack`."
        },
        {
          "optionId": "ch_viva_2_q14_opt2",
          "optionText": "I separate concerns: Stack A is for writing, Stack B is for reading. When the user asks to read (dequeue) and Stack B is empty, I 'pour' the entire contents of A into B. This reverses the LIFO order to FIFO. I then pop from B."
        },
        {
          "optionId": "ch_viva_2_q14_opt3",
          "optionText": "I define `push` as `s1.push(x)`. I define `pop`: If `s2` is empty, transfer `s1` to `s2`. Return `s2.pop()`. This provides amortized $O(1)$ time complexity."
        },
        {
          "optionId": "ch_viva_2_q14_opt4",
          "optionText": "I will use one stack for evens and one for odds."
        },
        {
          "optionId": "ch_viva_2_q14_opt5",
          "optionText": "To enqueue, I push to Stack 1. To dequeue, I pop from Stack 1."
        },
        {
          "optionId": "ch_viva_2_q14_opt6",
          "optionText": "I will push to Stack 1. When I need to dequeue, I move *everything* to Stack 2, pop, then move *everything* back to Stack 1."
        },
        {
          "optionId": "ch_viva_2_q14_opt7",
          "optionText": "I will use Stack 1 as the Head and Stack 2 as the Tail."
        },
        {
          "optionId": "ch_viva_2_q14_opt8",
          "optionText": "I push to S1. To dequeue, I pop S1 and push to S2, then pop S2."
        },
        {
          "optionId": "ch_viva_2_q14_opt9",
          "optionText": "I alternate pushing between S1 and S2."
        },
        {
          "optionId": "ch_viva_2_q14_opt10",
          "optionText": "I use recursion to simulate the second stack."
        },
        {
          "optionId": "ch_viva_2_q14_opt11",
          "optionText": "I keep Stack 2 sorted."
        },
        {
          "optionId": "ch_viva_2_q14_opt12",
          "optionText": "I copy S1 to S2 only if S1 is full."
        },
        {
          "optionId": "ch_viva_2_q14_opt13",
          "optionText": "To enqueue, I empty S1 into S2, push new item to S1, move S2 back."
        },
        {
          "optionId": "ch_viva_2_q14_opt14",
          "optionText": "I push to both stacks to keep a backup."
        },
        {
          "optionId": "ch_viva_2_q14_opt15",
          "optionText": "I return `Stack1.pop()`."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q14_opt1", "ch_viva_2_q14_opt2", "ch_viva_2_q14_opt3"],
      "explanationText": "The core idea is that transferring elements from one stack to another reverses their order. By using one stack for input (`InStack`) and one for output (`OutStack`), we achieve FIFO behavior. The transfer operation is $O(N)$, but since each element is transferred only once, the amortized time complexity for both push and pop is $O(1)$."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 4,
      "questionId": "ch_viva_2_q15",
      "questionText": "Sketch an algorithm using a **Stack** to check if a string of parentheses `()[]{}` is balanced.",
      "options": [
        {
          "optionId": "ch_viva_2_q15_opt1",
          "optionText": "I initialize an empty Stack. I loop through chars. If '(', '[', '{', I push it. If ')', ']', '}', I check if stack is empty (return false). Else, I pop. If the popped char doesn't match the current closing bracket type, return False. Finally, return `stack.isEmpty()`."
        },
        {
          "optionId": "ch_viva_2_q15_opt2",
          "optionText": "I use a Stack to store expected closing brackets. If I see `(`, I push `)`. If I see `[`, push `]`. If I see a closing bracket, I pop and compare. If they differ or stack is empty, it's invalid. At end, stack must be empty."
        },
        {
          "optionId": "ch_viva_2_q15_opt3",
          "optionText": "I iterate through the string. Open brackets go onto the Stack. For a closing bracket, I pop the top. If the pair is not a valid match (like `(` and `]`), I fail immediately. Also, if I finish the string and the stack still has items, it's invalid."
        },
        {
          "optionId": "ch_viva_2_q15_opt4",
          "optionText": "I will count the number of open and closed brackets. If counts match, it's valid."
        },
        {
          "optionId": "ch_viva_2_q15_opt5",
          "optionText": "I will use a Queue to match them."
        },
        {
          "optionId": "ch_viva_2_q15_opt6",
          "optionText": "I push everything to the stack and then check if it's a palindrome."
        },
        {
          "optionId": "ch_viva_2_q15_opt7",
          "optionText": "I iterate. If I see an open bracket, push. If closed, pop. If stack is not empty at end, return False."
        },
        {
          "optionId": "ch_viva_2_q15_opt8",
          "optionText": "I split the string in half and compare."
        },
        {
          "optionId": "ch_viva_2_q15_opt9",
          "optionText": "I use two stacks, one for open, one for closed."
        },
        {
          "optionId": "ch_viva_2_q15_opt10",
          "optionText": "I push closed brackets and pop open ones."
        },
        {
          "optionId": "ch_viva_2_q15_opt11",
          "optionText": "If `stack.pop()` returns null, ignore it."
        },
        {
          "optionId": "ch_viva_2_q15_opt12",
          "optionText": "I traverse from both ends inward."
        },
        {
          "optionId": "ch_viva_2_q15_opt13",
          "optionText": "I replace `()` with empty string until string is empty."
        },
        {
          "optionId": "ch_viva_2_q15_opt14",
          "optionText": "I use Regex."
        },
        {
          "optionId": "ch_viva_2_q15_opt15",
          "optionText": "I iterate. If I see open, push. If closed, peek. If peek matches, pop."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q15_opt1", "ch_viva_2_q15_opt2", "ch_viva_2_q15_opt3"],
      "explanationText": "A Stack is ideal for checking nested structures because of its LIFO property (the last bracket opened must be the first one closed). The algorithm must handle three failure conditions: 1) Trying to pop from an empty stack (e.g., `))`), 2) Mismatched types (e.g., `([)]`), and 3) Stack not empty at the end (e.g., `((`)."
    }
  ]
}
