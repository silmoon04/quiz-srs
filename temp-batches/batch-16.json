{
  "batchIndex": 16,
  "questions": [
    {
      "chapterIndex": 8,
      "questionIndex": 3,
      "questionId": "ch_viva_9_q49",
      "questionText": "Sketch an algorithm to check if a string is a **palindrome**, ignoring non-alphanumeric characters.",
      "options": [
        {
          "optionId": "ch_viva_9_q49_opt1",
          "optionText": "I use **Two Pointers** (Head, Tail). Loop `Head < Tail`. Inside, I run small while loops: `while Head is symbol, Head++` and `while Tail is symbol, Tail--`. Then compare characters (case-insensitive). If match, advance both. Else return False."
        },
        {
          "optionId": "ch_viva_9_q49_opt2",
          "optionText": "I scan from both ends. If I encounter a non-letter, I skip it. When both pointers rest on valid letters, I compare them. Mismatch implies false. Meeting in the middle implies true."
        },
        {
          "optionId": "ch_viva_9_q49_opt3",
          "optionText": "I iterate inwards. I effectively ignore any character that isn't a digit or letter by advancing my pointers past them dynamically. This allows me to verify the palindrome property in-place."
        },
        {
          "optionId": "ch_viva_9_q49_opt4",
          "optionText": "I will replace all symbols using Regex."
        },
        {
          "optionId": "ch_viva_9_q49_opt5",
          "optionText": "I will create a new clean string."
        },
        {
          "optionId": "ch_viva_9_q49_opt6",
          "optionText": "I will skip only spaces."
        },
        {
          "optionId": "ch_viva_9_q49_opt7",
          "optionText": "I will check char codes."
        },
        {
          "optionId": "ch_viva_9_q49_opt8",
          "optionText": "I will use a Stack."
        },
        {
          "optionId": "ch_viva_9_q49_opt9",
          "optionText": "I will compare index `i` and `N-i`."
        },
        {
          "optionId": "ch_viva_9_q49_opt10",
          "optionText": "I will reverse and compare."
        },
        {
          "optionId": "ch_viva_9_q49_opt11",
          "optionText": "I will use hashing."
        },
        {
          "optionId": "ch_viva_9_q49_opt12",
          "optionText": "I will use recursion."
        },
        {
          "optionId": "ch_viva_9_q49_opt13",
          "optionText": "I will sort it."
        },
        {
          "optionId": "ch_viva_9_q49_opt14",
          "optionText": "I will delete symbols."
        },
        {
          "optionId": "ch_viva_9_q49_opt15",
          "optionText": "I will assume clean input."
        }
      ],
      "correctOptionIds": ["ch_viva_9_q49_opt1", "ch_viva_9_q49_opt2", "ch_viva_9_q49_opt3"],
      "explanationText": "The optimal solution uses the Two-Pointer technique, running in $O(N)$ time and $O(1)$ space. The key is to use inner loops to advance the pointers past any non-alphanumeric characters before performing the comparison."
    },
    {
      "chapterIndex": 8,
      "questionIndex": 4,
      "questionId": "ch_viva_9_q50",
      "questionText": "Sketch an algorithm to **evaluate** a mathematical **Expression Tree** (Leafs are numbers, Internal nodes are operators `+ - * /`).",
      "options": [
        {
          "optionId": "ch_viva_9_q50_opt1",
          "optionText": "I use **Recursion**. Base case: If node is Leaf, return its value. Recursive step: `leftVal = eval(node.left)`, `rightVal = eval(node.right)`. Then apply `node.operator` to `leftVal` and `rightVal`. Return the result."
        },
        {
          "optionId": "ch_viva_9_q50_opt2",
          "optionText": "I perform a Post-Order traversal. I compute the result of the left subtree and the right subtree first. Once I have those two numbers, I combine them using the operation stored in the current node."
        },
        {
          "optionId": "ch_viva_9_q50_opt3",
          "optionText": "I collapse the tree from bottom up. Leaves return numbers. Operator nodes wait for their children to return numbers, then perform the math and return the result up to *their* parent."
        },
        {
          "optionId": "ch_viva_9_q50_opt4",
          "optionText": "I will use In-Order traversal."
        },
        {
          "optionId": "ch_viva_9_q50_opt5",
          "optionText": "I will use BFS."
        },
        {
          "optionId": "ch_viva_9_q50_opt6",
          "optionText": "I will return the root value."
        },
        {
          "optionId": "ch_viva_9_q50_opt7",
          "optionText": "I will use a Stack."
        },
        {
          "optionId": "ch_viva_9_q50_opt8",
          "optionText": "I will add all leaves."
        },
        {
          "optionId": "ch_viva_9_q50_opt9",
          "optionText": "I will assume the tree is a heap."
        },
        {
          "optionId": "ch_viva_9_q50_opt10",
          "optionText": "I will multiply the height."
        },
        {
          "optionId": "ch_viva_9_q50_opt11",
          "optionText": "I will swap operands."
        },
        {
          "optionId": "ch_viva_9_q50_opt12",
          "optionText": "I will flatten to a list."
        },
        {
          "optionId": "ch_viva_9_q50_opt13",
          "optionText": "I will check for cycles."
        },
        {
          "optionId": "ch_viva_9_q50_opt14",
          "optionText": "I will use Dijkstra."
        },
        {
          "optionId": "ch_viva_9_q50_opt15",
          "optionText": "I will return 0."
        }
      ],
      "correctOptionIds": ["ch_viva_9_q50_opt1", "ch_viva_9_q50_opt2", "ch_viva_9_q50_opt3"],
      "explanationText": "Evaluating an expression tree requires a Post-Order traversal (Left, Right, Root). This ensures that the operands (numbers in the leaves) are evaluated before the operator (in the internal node) is applied. Recursion is the most straightforward way to implement this, running in $O(N)$ time."
    }
  ]
}
