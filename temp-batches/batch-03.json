{
  "batchIndex": 3,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 9,
      "questionId": "ch_viva_1_q10",
      "questionText": "Sketch an algorithm to **delete** a specific node `P` from a **Doubly Linked List**, given only the pointer to `P`.",
      "options": [
        {
          "optionId": "ch_viva_1_q10_opt1",
          "optionText": "I check if `P.prev` exists. If so, `P.prev.next = P.next`. If not, `P` was head (update head). Then check if `P.next` exists. If so, `P.next.prev = P.prev`. If not, `P` was tail. Finally, nullify `P`'s pointers."
        },
        {
          "optionId": "ch_viva_1_q10_opt2",
          "optionText": "Since I have access to neighbors, I link the node *before* `P` directly to the node *after* `P`, and vice versa. This effectively bypasses `P`. This is an $O(1)$ operation."
        },
        {
          "optionId": "ch_viva_1_q10_opt3",
          "optionText": "I identify `left = P.prev` and `right = P.next`. If `left` is not null, `left.next = right`. If `right` is not null, `right.prev = left`. The node is now detached."
        },
        {
          "optionId": "ch_viva_1_q10_opt4",
          "optionText": "I will traverse from Head to find `P`..."
        },
        {
          "optionId": "ch_viva_1_q10_opt5",
          "optionText": "I will set `P = null`."
        },
        {
          "optionId": "ch_viva_1_q10_opt6",
          "optionText": "I will set `P.next.prev = P.prev` only."
        },
        {
          "optionId": "ch_viva_1_q10_opt7",
          "optionText": "I will copy the data from the next node into `P` and delete the next node."
        },
        {
          "optionId": "ch_viva_1_q10_opt8",
          "optionText": "I will delete the whole list."
        },
        {
          "optionId": "ch_viva_1_q10_opt9",
          "optionText": "I will use a Stack to track previous nodes."
        },
        {
          "optionId": "ch_viva_1_q10_opt10",
          "optionText": "I will swap `P` with the Tail and delete Tail."
        },
        {
          "optionId": "ch_viva_1_q10_opt11",
          "optionText": "I will return the value of `P`."
        },
        {
          "optionId": "ch_viva_1_q10_opt12",
          "optionText": "Complexity is $O(N)$."
        },
        {
          "optionId": "ch_viva_1_q10_opt13",
          "optionText": "I assume `P` is always in the middle."
        },
        {
          "optionId": "ch_viva_1_q10_opt14",
          "optionText": "I link `P.prev` to `P.prev.prev`."
        },
        {
          "optionId": "ch_viva_1_q10_opt15",
          "optionText": "I will check if `P` is null and return."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q10_opt1", "ch_viva_1_q10_opt2", "ch_viva_1_q10_opt3"],
      "explanationText": "Since a Doubly Linked List provides access to both `prev` and `next` pointers, deletion can be performed in $O(1)$ time by simply updating the neighbors' pointers to bypass the node `P`. Edge cases (deleting head or tail) must be handled by checking for null pointers."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 0,
      "questionId": "ch_viva_2_q11",
      "questionText": "Sketch an algorithm to determine if a **Singly Linked List** contains a cycle (a loop). You cannot modify the list structure.",
      "options": [
        {
          "optionId": "ch_viva_2_q11_opt1",
          "optionText": "I will use **Floydâ€™s Cycle-Finding Algorithm** (Tortoise and Hare). I initialize two pointers, `slow` and `fast`, both at the head. I loop while `fast` and `fast.next` are not null. `slow` moves 1 step; `fast` moves 2 steps. If `slow == fast`, I return True. If the loop ends, I return False."
        },
        {
          "optionId": "ch_viva_2_q11_opt2",
          "optionText": "I will use a **Hash Set** of Node References (not values). I traverse the list. For every node, I check if the *pointer address* is already in the Set. If yes, cycle detected. If no, add it. If I hit null, return False. (Note: This uses $O(N)$ space)."
        },
        {
          "optionId": "ch_viva_2_q11_opt3",
          "optionText": "I will use two pointers. `Fast` moves twice as fast as `Slow`. If there is a cycle, `Fast` will eventually 'lap' (catch up to) `Slow` inside the loop. If `Fast` reaches null, the list is linear."
        },
        {
          "optionId": "ch_viva_2_q11_opt4",
          "optionText": "I will traverse the list and check if `current.next == head`."
        },
        {
          "optionId": "ch_viva_2_q11_opt5",
          "optionText": "I will iterate for a set time (e.g., 5 seconds) and if it doesn't end, it's a cycle."
        },
        {
          "optionId": "ch_viva_2_q11_opt6",
          "optionText": "I will traverse the list and mark nodes as 'visited' by adding a boolean flag."
        },
        {
          "optionId": "ch_viva_2_q11_opt7",
          "optionText": "I will check if `next` pointers are increasing in memory address."
        },
        {
          "optionId": "ch_viva_2_q11_opt8",
          "optionText": "I will use recursion to traverse; if the stack overflows, there is a cycle."
        },
        {
          "optionId": "ch_viva_2_q11_opt9",
          "optionText": "I will compare the current node with the previous node."
        },
        {
          "optionId": "ch_viva_2_q11_opt10",
          "optionText": "I will reverse the list and see if I return to the start."
        },
        {
          "optionId": "ch_viva_2_q11_opt11",
          "optionText": "I will use two pointers moving at the same speed starting from opposite ends."
        },
        {
          "optionId": "ch_viva_2_q11_opt12",
          "optionText": "I will calculate the length of the list. If it's infinite, return true."
        },
        {
          "optionId": "ch_viva_2_q11_opt13",
          "optionText": "I will check if the last node points to null."
        },
        {
          "optionId": "ch_viva_2_q11_opt14",
          "optionText": "I will use a Hash Map to store values."
        },
        {
          "optionId": "ch_viva_2_q11_opt15",
          "optionText": "I will delete nodes as I go. If I hit a null, no cycle."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q11_opt1", "ch_viva_2_q11_opt2", "ch_viva_2_q11_opt3"],
      "explanationText": "The Tortoise and Hare algorithm (Floyd's) is the optimal solution, providing $O(N)$ time complexity and $O(1)$ space complexity. Using a Hash Set is also $O(N)$ time but requires $O(N)$ space to store node references."
    },
    {
      "chapterIndex": 1,
      "questionIndex": 1,
      "questionId": "ch_viva_2_q12",
      "questionText": "Sketch an algorithm to **reverse** a **Singly Linked List** in-place (without creating a new list).",
      "options": [
        {
          "optionId": "ch_viva_2_q12_opt1",
          "optionText": "I initialize three pointers: `prev` (null), `curr` (head), and `next` (null). I loop while `curr` is not null. Inside: 1. Save `next = curr.next`. 2. Reverse link `curr.next = prev`. 3. Move `prev = curr`. 4. Move `curr = next`. Finally, update `head = prev`."
        },
        {
          "optionId": "ch_viva_2_q12_opt2",
          "optionText": "I utilize a standard iterative pointer reversal. I maintain a `previous` pointer. As I traverse with `current`, I temporarily store the `future` node. I redirect `current` to point to `previous`, then shift our window of three pointers one step forward."
        },
        {
          "optionId": "ch_viva_2_q12_opt3",
          "optionText": "I use recursion. Base case: if head is empty or single, return it. Recursive step: `newHead = reverse(head.next)`. Then perform the surgery: `head.next.next = head` and `head.next = null`. Return `newHead`."
        },
        {
          "optionId": "ch_viva_2_q12_opt4",
          "optionText": "I will swap the `head` and `tail` pointers."
        },
        {
          "optionId": "ch_viva_2_q12_opt5",
          "optionText": "I will traverse the list and set `node.next = node.prev`."
        },
        {
          "optionId": "ch_viva_2_q12_opt6",
          "optionText": "I will use a Stack to store values, then overwrite the nodes."
        },
        {
          "optionId": "ch_viva_2_q12_opt7",
          "optionText": "I will iterate through: `curr.next = prev; prev = curr; curr = curr.next`."
        },
        {
          "optionId": "ch_viva_2_q12_opt8",
          "optionText": "I will swap the first node with the last, second with second-last..."
        },
        {
          "optionId": "ch_viva_2_q12_opt9",
          "optionText": "I will use Recursion: `head.next = reverse(head)`."
        },
        {
          "optionId": "ch_viva_2_q12_opt10",
          "optionText": "I will create a new List and add nodes to the head."
        },
        {
          "optionId": "ch_viva_2_q12_opt11",
          "optionText": "I will use Doubly Linked List logic."
        },
        {
          "optionId": "ch_viva_2_q12_opt12",
          "optionText": "I will iterate `i` from 0 to N and swap `next` pointers."
        },
        {
          "optionId": "ch_viva_2_q12_opt13",
          "optionText": "I will point the head to null and the tail to the head."
        },
        {
          "optionId": "ch_viva_2_q12_opt14",
          "optionText": "I will traverse to the end, then work backwards."
        },
        {
          "optionId": "ch_viva_2_q12_opt15",
          "optionText": "I will use a temporary variable to swap `node` and `node.next`."
        }
      ],
      "correctOptionIds": ["ch_viva_2_q12_opt1", "ch_viva_2_q12_opt2", "ch_viva_2_q12_opt3"],
      "explanationText": "The iterative solution (Options 1, 2) is the most common and efficient, using $O(N)$ time and $O(1)$ space by managing three pointers (`prev`, `curr`, `next`). The recursive solution (Option 3) is also $O(N)$ time but uses $O(N)$ space on the call stack."
    }
  ]
}
