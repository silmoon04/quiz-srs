{
  "batchIndex": 11,
  "questions": [
    {
      "chapterIndex": 5,
      "questionIndex": 3,
      "questionId": "ch_viva_6_q34",
      "questionText": "Sketch an algorithm to check if two Strings are **valid anagrams** of each other.",
      "options": [
        {
          "optionId": "ch_viva_6_q34_opt1",
          "optionText": "I use a **Frequency Map** (or integer array size 26). I iterate String A, incrementing counts for each char. I iterate String B, decrementing counts. Finally, I check if all counts are zero. If yes, True."
        },
        {
          "optionId": "ch_viva_6_q34_opt2",
          "optionText": "I create two Hash Maps. I populate them with character frequencies from String A and String B respectively. I then compare if `MapA.equals(MapB)`. Return the result."
        },
        {
          "optionId": "ch_viva_6_q34_opt3",
          "optionText": "I verify lengths match. Then I sort both strings alphabetically. I iterate through the sorted arrays comparing index `i`. If any mismatch found, return False. Else True."
        },
        {
          "optionId": "ch_viva_6_q34_opt4",
          "optionText": "I will sort both strings and compare."
        },
        {
          "optionId": "ch_viva_6_q34_opt5",
          "optionText": "I will check if they have the same length."
        },
        {
          "optionId": "ch_viva_6_q34_opt6",
          "optionText": "I will check if they contain the same characters."
        },
        {
          "optionId": "ch_viva_6_q34_opt7",
          "optionText": "I will sum the ASCII values."
        },
        {
          "optionId": "ch_viva_6_q34_opt8",
          "optionText": "I will multiply the ASCII values."
        },
        {
          "optionId": "ch_viva_6_q34_opt9",
          "optionText": "I will use a Set."
        },
        {
          "optionId": "ch_viva_6_q34_opt10",
          "optionText": "I will iterate nested loops."
        },
        {
          "optionId": "ch_viva_6_q34_opt11",
          "optionText": "I will reverse one string."
        },
        {
          "optionId": "ch_viva_6_q34_opt12",
          "optionText": "I will remove chars from String B as I find them in String A."
        },
        {
          "optionId": "ch_viva_6_q34_opt13",
          "optionText": "I will use recursion."
        },
        {
          "optionId": "ch_viva_6_q34_opt14",
          "optionText": "I will check first and last chars."
        },
        {
          "optionId": "ch_viva_6_q34_opt15",
          "optionText": "I will use a Stack."
        }
      ],
      "correctOptionIds": ["ch_viva_6_q34_opt1", "ch_viva_6_q34_opt2", "ch_viva_6_q34_opt3"],
      "explanationText": "Anagrams are permutations, meaning they must have the exact same character counts. The most efficient method is using a frequency map/array ($O(N)$ time). Sorting is also valid but slower ($O(N \\log N)$)."
    },
    {
      "chapterIndex": 5,
      "questionIndex": 4,
      "questionId": "ch_viva_6_q35",
      "questionText": "Sketch an algorithm to find the node where two **Singly Linked Lists intersect** (merge).",
      "options": [
        {
          "optionId": "ch_viva_6_q35_opt1",
          "optionText": "I calculate the **length** of List A and List B. I calculate the difference `d`. I advance the pointer of the longer list by `d` steps. Now both pointers are equidistant from the end. I move both forward until `ptrA == ptrB`. Return that node."
        },
        {
          "optionId": "ch_viva_6_q35_opt2",
          "optionText": "I traverse List A and insert all nodes (references) into a **Hash Set**. Then I traverse List B. The first node from B that already exists in the Set is the intersection point."
        },
        {
          "optionId": "ch_viva_6_q35_opt3",
          "optionText": "I use the **Two Pointer Switch** trick. Pointers `pA` and `pB`. Traverse. When `pA` reaches end, redirect it to Head B. When `pB` reaches end, redirect to Head A. They will meet at the intersection after 1 extra pass."
        },
        {
          "optionId": "ch_viva_6_q35_opt4",
          "optionText": "I will iterate both lists until values match."
        },
        {
          "optionId": "ch_viva_6_q35_opt5",
          "optionText": "I will use a hash map for values."
        },
        {
          "optionId": "ch_viva_6_q35_opt6",
          "optionText": "I will check if tails are different."
        },
        {
          "optionId": "ch_viva_6_q35_opt7",
          "optionText": "I will iterate `i` and `j`."
        },
        {
          "optionId": "ch_viva_6_q35_opt8",
          "optionText": "I will reverse both lists."
        },
        {
          "optionId": "ch_viva_6_q35_opt9",
          "optionText": "I will traverse one list, then the other."
        },
        {
          "optionId": "ch_viva_6_q35_opt10",
          "optionText": "I will compare heads."
        },
        {
          "optionId": "ch_viva_6_q35_opt11",
          "optionText": "I will use a Stack."
        },
        {
          "optionId": "ch_viva_6_q35_opt12",
          "optionText": "I will assume same length."
        },
        {
          "optionId": "ch_viva_6_q35_opt13",
          "optionText": "I will use recursion."
        },
        {
          "optionId": "ch_viva_6_q35_opt14",
          "optionText": "I will add lists values together."
        },
        {
          "optionId": "ch_viva_6_q35_opt15",
          "optionText": "I will use Tortoise and Hare."
        }
      ],
      "correctOptionIds": ["ch_viva_6_q35_opt1", "ch_viva_6_q35_opt2", "ch_viva_6_q35_opt3"],
      "explanationText": "The intersection point is found by aligning the starting points of the two lists. The length difference method (Option 1) is $O(N)$ time and $O(1)$ space. The Hash Set method (Option 2) is $O(N)$ time but $O(N)$ space. The Two Pointer Switch (Option 3) is a clever $O(N)$ time, $O(1)$ space solution."
    },
    {
      "chapterIndex": 6,
      "questionIndex": 0,
      "questionId": "ch_viva_7_q36",
      "questionText": "Sketch an algorithm to **Deep Clone** a Graph (given a starting node).",
      "options": [
        {
          "optionId": "ch_viva_7_q36_opt1",
          "optionText": "I use **BFS** with a Queue and a **Hash Map** mapping `Original -> Clone`. Enqueue start. Create clone, put in Map. While queue not empty: Dequeue `u`. For each neighbor `v`: If `v` not in Map, clone it, map it, enqueue it. Link `Map[u].neighbors.add(Map[v])`."
        },
        {
          "optionId": "ch_viva_7_q36_opt2",
          "optionText": "I use **DFS** (Recursion). Function `clone(node)`: If `node` is in Map, return `Map[node]`. Else, create `newNode`, add to Map. For each neighbor, `newNode.neighbors.add(clone(neighbor))`. Return `newNode`."
        },
        {
          "optionId": "ch_viva_7_q36_opt3",
          "optionText": "I traverse the graph. I maintain a registry (Map) of copied nodes. For every node I encounter, I check the registry. If it exists, I use the existing copy. If not, I mint a fresh copy and register it before processing its edges."
        },
        {
          "optionId": "ch_viva_7_q36_opt4",
          "optionText": "I will just return the reference to the start node."
        },
        {
          "optionId": "ch_viva_7_q36_opt5",
          "optionText": "I will iterate and create new nodes."
        },
        {
          "optionId": "ch_viva_7_q36_opt6",
          "optionText": "I will use BFS but no map."
        },
        {
          "optionId": "ch_viva_7_q36_opt7",
          "optionText": "I will use recursion without visited set."
        },
        {
          "optionId": "ch_viva_7_q36_opt8",
          "optionText": "I will copy the adjacency matrix."
        },
        {
          "optionId": "ch_viva_7_q36_opt9",
          "optionText": "I will serialize and deserialize."
        },
        {
          "optionId": "ch_viva_7_q36_opt10",
          "optionText": "I will create a new graph object."
        },
        {
          "optionId": "ch_viva_7_q36_opt11",
          "optionText": "I will copy values only."
        },
        {
          "optionId": "ch_viva_7_q36_opt12",
          "optionText": "I will use Dijkstra."
        },
        {
          "optionId": "ch_viva_7_q36_opt13",
          "optionText": "I will assume it is a tree."
        },
        {
          "optionId": "ch_viva_7_q36_opt14",
          "optionText": "I will clone neighbors first."
        },
        {
          "optionId": "ch_viva_7_q36_opt15",
          "optionText": "I will use an array."
        }
      ],
      "correctOptionIds": ["ch_viva_7_q36_opt1", "ch_viva_7_q36_opt2", "ch_viva_7_q36_opt3"],
      "explanationText": "Deep cloning a graph requires two things: 1) Creating a new node for every original node, and 2) Using a Hash Map to link the original nodes to their clones. This map prevents infinite recursion/loops when cycles are encountered and ensures that shared nodes are only cloned once. Time complexity is $O(V+E)$."
    }
  ]
}
