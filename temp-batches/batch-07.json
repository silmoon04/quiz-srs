{
  "batchIndex": 7,
  "questions": [
    {
      "chapterIndex": 3,
      "questionIndex": 1,
      "questionId": "ch_viva_4_q22",
      "questionText": "Sketch an algorithm to find the **In-Order Successor** of a given node `N` in a **Binary Search Tree**.",
      "options": [
        {
          "optionId": "ch_viva_4_q22_opt1",
          "optionText": "Case 1: If `N` has a right child, I go to the right child, then traverse strictly **left** until I hit null. That node is the successor. Case 2: If `N` has no right child, I start from the **root** and traverse down. I keep a variable `successor`. If `root.val > N.val`, I update `successor = root` and go left. If `root.val < N.val`, I go right. Return `successor`."
        },
        {
          "optionId": "ch_viva_4_q22_opt2",
          "optionText": "I check for a right subtree. If present, the minimum value in that subtree is the answer. If not, I utilize the property that the successor is the lowest ancestor for which the given node falls in the left subtree."
        },
        {
          "optionId": "ch_viva_4_q22_opt3",
          "optionText": "If right child exists: `goRight()`, then `goLeftUntilNull()`. If not: Walk down from root. Every time I go *left*, I save the current node as a potential candidate. The last saved candidate is the successor."
        },
        {
          "optionId": "ch_viva_4_q22_opt4",
          "optionText": "The successor is `node.right`."
        },
        {
          "optionId": "ch_viva_4_q22_opt5",
          "optionText": "The successor is `node.left`."
        },
        {
          "optionId": "ch_viva_4_q22_opt6",
          "optionText": "I will just look at the parent."
        },
        {
          "optionId": "ch_viva_4_q22_opt7",
          "optionText": "I will search for `node.value + 1`."
        },
        {
          "optionId": "ch_viva_4_q22_opt8",
          "optionText": "I will traverse the whole tree and sort it."
        },
        {
          "optionId": "ch_viva_4_q22_opt9",
          "optionText": "I will use Level-Order traversal."
        },
        {
          "optionId": "ch_viva_4_q22_opt10",
          "optionText": "I will return the root."
        },
        {
          "optionId": "ch_viva_4_q22_opt11",
          "optionText": "If it has no right child, it has no successor."
        },
        {
          "optionId": "ch_viva_4_q22_opt12",
          "optionText": "I will check the left child of the right child."
        },
        {
          "optionId": "ch_viva_4_q22_opt13",
          "optionText": "I will use recursion to find the max value."
        },
        {
          "optionId": "ch_viva_4_q22_opt14",
          "optionText": "I will compare with `root` and go down."
        },
        {
          "optionId": "ch_viva_4_q22_opt15",
          "optionText": "I will use a Stack."
        }
      ],
      "correctOptionIds": ["ch_viva_4_q22_opt1", "ch_viva_4_q22_opt2", "ch_viva_4_q22_opt3"],
      "explanationText": "The In-Order Successor is the next largest value. If a right subtree exists, the successor is the minimum element in that subtree. If no right subtree exists, the successor is the lowest ancestor whose left child is the current node (or one of its ancestors). This is an $O(H)$ operation, where $H$ is the height of the tree."
    },
    {
      "chapterIndex": 3,
      "questionIndex": 2,
      "questionId": "ch_viva_4_q23",
      "questionText": "Sketch the algorithm for **deleting the root** (Extract-Max) from a **Max-Heap** implemented as an array.",
      "options": [
        {
          "optionId": "ch_viva_4_q23_opt1",
          "optionText": "First, I save the value at `array[0]` to return later. Then, I take the **last** element in the array (`array[size-1]`) and move it to `array[0]`. I decrement the size. Finally, I perform **'Bubble Down'**: compare the new root with its children, swap with the larger child, and repeat until the heap property is restored."
        },
        {
          "optionId": "ch_viva_4_q23_opt2",
          "optionText": "I replace the root with the last leaf node to maintain the 'Complete Tree' structure. Then, I check the new root against its children. If a child is larger, I swap. I continue this process down the tree until the node dominates its children or becomes a leaf."
        },
        {
          "optionId": "ch_viva_4_q23_opt3",
          "optionText": "I overwrite the root with the tail element. Then I 'sink' this element. I calculate indices of Left (`2i+1`) and Right (`2i+2`) children. I swap with the max of the two children if the parent is smaller. Repeat recursively."
        },
        {
          "optionId": "ch_viva_4_q23_opt4",
          "optionText": "I remove the root and move the second element to the top."
        },
        {
          "optionId": "ch_viva_4_q23_opt5",
          "optionText": "I remove the root and shift the array left by 1."
        },
        {
          "optionId": "ch_viva_4_q23_opt6",
          "optionText": "I swap the root with the left child."
        },
        {
          "optionId": "ch_viva_4_q23_opt7",
          "optionText": "I delete the last element."
        },
        {
          "optionId": "ch_viva_4_q23_opt8",
          "optionText": "I search for the max element."
        },
        {
          "optionId": "ch_viva_4_q23_opt9",
          "optionText": "I sort the array."
        },
        {
          "optionId": "ch_viva_4_q23_opt10",
          "optionText": "I swap root with a random leaf."
        },
        {
          "optionId": "ch_viva_4_q23_opt11",
          "optionText": "I recursively delete children."
        },
        {
          "optionId": "ch_viva_4_q23_opt12",
          "optionText": "I bubble up the root."
        },
        {
          "optionId": "ch_viva_4_q23_opt13",
          "optionText": "I insert the new root at the correct spot."
        },
        {
          "optionId": "ch_viva_4_q23_opt14",
          "optionText": "I use a second heap."
        },
        {
          "optionId": "ch_viva_4_q23_opt15",
          "optionText": "I return the root and do nothing else."
        }
      ],
      "correctOptionIds": ["ch_viva_4_q23_opt1", "ch_viva_4_q23_opt2", "ch_viva_4_q23_opt3"],
      "explanationText": "Extracting the root of a heap is an $O(\\log N)$ operation. It involves three steps: 1) Save the root value, 2) Replace the root with the last element (to maintain the complete tree property), and 3) Restore the heap property by 'bubbling down' (or sinking) the new root."
    },
    {
      "chapterIndex": 3,
      "questionIndex": 3,
      "questionId": "ch_viva_4_q24",
      "questionText": "Sketch an algorithm to **sort** a **Stack** using only recursion (and the stack itself, no auxiliary data structures like arrays).",
      "options": [
        {
          "optionId": "ch_viva_4_q24_opt1",
          "optionText": "I define `sort(stack)`: If not empty, `pop` element `x`, recursively call `sort(stack)`, then call `sortedInsert(stack, x)`. I define `sortedInsert(stack, x)`: If stack empty or `top < x`, push `x`. Else, `pop` `temp`, recurse `sortedInsert(stack, x)`, then push `temp` back."
        },
        {
          "optionId": "ch_viva_4_q24_opt2",
          "optionText": "I rely on the Call Stack. I strip the stack naked recursively holding values in the function frames. As the recursion unwinds, I re-insert each value into the stack, but I use a helper function to ensure each value is placed deeply enough to maintain order."
        },
        {
          "optionId": "ch_viva_4_q24_opt3",
          "optionText": "I use recursion to hold all values. Base case: Stack empty. Recursive step: Pop item, Sort remaining stack. Then, insert the popped item into the sorted stack at its correct position (which requires a second recursive lookup)."
        },
        {
          "optionId": "ch_viva_4_q24_opt4",
          "optionText": "I will use an array, sort it, and push back."
        },
        {
          "optionId": "ch_viva_4_q24_opt5",
          "optionText": "I will use Bubble Sort on the stack."
        },
        {
          "optionId": "ch_viva_4_q24_opt6",
          "optionText": "I will pop everything, find the min, and push it."
        },
        {
          "optionId": "ch_viva_4_q24_opt7",
          "optionText": "I will use a second stack."
        },
        {
          "optionId": "ch_viva_4_q24_opt8",
          "optionText": "I will swap the top two elements until sorted."
        },
        {
          "optionId": "ch_viva_4_q24_opt9",
          "optionText": "I will use a Priority Queue."
        },
        {
          "optionId": "ch_viva_4_q24_opt10",
          "optionText": "I will assume the stack is sorted."
        },
        {
          "optionId": "ch_viva_4_q24_opt11",
          "optionText": "I will pop elements and push them in sorted order."
        },
        {
          "optionId": "ch_viva_4_q24_opt12",
          "optionText": "I will use QuickSort."
        },
        {
          "optionId": "ch_viva_4_q24_opt13",
          "optionText": "I will reverse the stack."
        },
        {
          "optionId": "ch_viva_4_q24_opt14",
          "optionText": "I will use `Stack.sort()`."
        },
        {
          "optionId": "ch_viva_4_q24_opt15",
          "optionText": "I will print them in sorted order."
        }
      ],
      "correctOptionIds": ["ch_viva_4_q24_opt1", "ch_viva_4_q24_opt2", "ch_viva_4_q24_opt3"],
      "explanationText": "This is a classic recursive sorting problem. It requires two mutually recursive functions: one to empty the stack (`sort`) and one to insert the popped element back into the now-sorted stack while maintaining order (`sortedInsert`). The time complexity is $O(N^2)$ because `sortedInsert` can take $O(N)$ time, and it is called $N$ times."
    }
  ]
}
