{
  "batchIndex": 8,
  "questions": [
    {
      "chapterIndex": 3,
      "questionIndex": 4,
      "questionId": "ch_viva_4_q25",
      "questionText": "You are given an array containing $N-1$ distinct numbers taken from the range $1$ to $N$. Sketch an algorithm to find the **missing number**.",
      "options": [
        {
          "optionId": "ch_viva_4_q25_opt1",
          "optionText": "I calculate the **Expected Sum** of integers 1 to N using the formula $N(N+1)/2$. Then, I iterate through the array to calculate the **Actual Sum**. The difference `Expected - Actual` is the missing number."
        },
        {
          "optionId": "ch_viva_4_q25_opt2",
          "optionText": "I initialize `sum = 0$. I loop through the array adding values to `sum`. I also compute the mathematical sum of the range 1 to N. Subtracting my calculated array sum from the mathematical sum reveals the missing value in $O(N)$ time and $O(1)$ space."
        },
        {
          "optionId": "ch_viva_4_q25_opt3",
          "optionText": "Alternatively, I can use **XOR**. I XOR all numbers from 1 to N. Then I XOR that result with all elements in the array. The property $A \\oplus A = 0$ means all duplicates cancel out, leaving only the missing number."
        },
        {
          "optionId": "ch_viva_4_q25_opt4",
          "optionText": "I will sort the array and check for gaps."
        },
        {
          "optionId": "ch_viva_4_q25_opt5",
          "optionText": "I will use a boolean array of size N."
        },
        {
          "optionId": "ch_viva_4_q25_opt6",
          "optionText": "I will check if 1 exists, then 2, then 3..."
        },
        {
          "optionId": "ch_viva_4_q25_opt7",
          "optionText": "I will look for the number that isn't there."
        },
        {
          "optionId": "ch_viva_4_q25_opt8",
          "optionText": "I will traverse and see which index is empty."
        },
        {
          "optionId": "ch_viva_4_q25_opt9",
          "optionText": "I will use a Hash Map."
        },
        {
          "optionId": "ch_viva_4_q25_opt10",
          "optionText": "I will use Binary Search."
        },
        {
          "optionId": "ch_viva_4_q25_opt11",
          "optionText": "I will check if the last number is N."
        },
        {
          "optionId": "ch_viva_4_q25_opt12",
          "optionText": "I will add 1 to every element."
        },
        {
          "optionId": "ch_viva_4_q25_opt13",
          "optionText": "I will subtract the first from the last."
        },
        {
          "optionId": "ch_viva_4_q25_opt14",
          "optionText": "I will assume the array is `[1, 2, 3...]`."
        },
        {
          "optionId": "ch_viva_4_q25_opt15",
          "optionText": "I will check for duplicates."
        }
      ],
      "correctOptionIds": ["ch_viva_4_q25_opt1", "ch_viva_4_q25_opt2", "ch_viva_4_q25_opt3"],
      "explanationText": "The most efficient solution is to use the mathematical property of summation (Gauss's formula) or the XOR property. Both methods achieve $O(N)$ time complexity and $O(1)$ space complexity, avoiding the overhead of sorting or auxiliary data structures."
    },
    {
      "chapterIndex": 4,
      "questionIndex": 0,
      "questionId": "ch_viva_5_q26",
      "questionText": "Sketch an algorithm to determine if there is a **valid path** from Vertex A to Vertex B in a **Directed Graph**.",
      "options": [
        {
          "optionId": "ch_viva_5_q26_opt1",
          "optionText": "I will use **BFS** (Queue) or **DFS** (Stack). I initialize a `Visited` set. Enqueue `A` and mark it visited. While queue not empty: Dequeue `curr`. If `curr == B`, return True. Else, for each neighbor of `curr`, if not visited, Enqueue and mark visited. If queue empties, return False."
        },
        {
          "optionId": "ch_viva_5_q26_opt2",
          "optionText": "I maintain a Set of visited vertices to prevent cycles. Starting at A, I perform a traversal. If I encounter B during the traversal, I immediately return True. If the traversal finishes without seeing B, I return False."
        },
        {
          "optionId": "ch_viva_5_q26_opt3",
          "optionText": "I employ a standard Graph Traversal. I start at the Source. I explore all adjacent neighbors recursively (DFS). I flag every node I enter. If I step onto the Destination node, I propagate a 'True' signal back up the chain."
        },
        {
          "optionId": "ch_viva_5_q26_opt4",
          "optionText": "I will iterate the adjacency matrix rows."
        },
        {
          "optionId": "ch_viva_5_q26_opt5",
          "optionText": "I will check if A is connected to B directly."
        },
        {
          "optionId": "ch_viva_5_q26_opt6",
          "optionText": "I will use DFS without a visited set."
        },
        {
          "optionId": "ch_viva_5_q26_opt7",
          "optionText": "I will calculate the shortest path."
        },
        {
          "optionId": "ch_viva_5_q26_opt8",
          "optionText": "I will reverse the graph."
        },
        {
          "optionId": "ch_viva_5_q26_opt9",
          "optionText": "I will check if they are in the same component."
        },
        {
          "optionId": "ch_viva_5_q26_opt10",
          "optionText": "I will assume it's a tree."
        },
        {
          "optionId": "ch_viva_5_q26_opt11",
          "optionText": "I will check if `A.next == B`."
        },
        {
          "optionId": "ch_viva_5_q26_opt12",
          "optionText": "I will sort the edges."
        },
        {
          "optionId": "ch_viva_5_q26_opt13",
          "optionText": "I will use recursion with a base case."
        },
        {
          "optionId": "ch_viva_5_q26_opt14",
          "optionText": "I will use Union-Find."
        },
        {
          "optionId": "ch_viva_5_q26_opt15",
          "optionText": "I will check the degree of the nodes."
        }
      ],
      "correctOptionIds": ["ch_viva_5_q26_opt1", "ch_viva_5_q26_opt2", "ch_viva_5_q26_opt3"],
      "explanationText": "Path existence (reachability) is solved using standard graph traversal algorithms, BFS or DFS. The critical component is the `Visited` set to prevent infinite loops in the presence of cycles. Time complexity is $O(V+E)$."
    },
    {
      "chapterIndex": 4,
      "questionIndex": 1,
      "questionId": "ch_viva_5_q27",
      "questionText": "Sketch an algorithm to convert a **Doubly Linked List** into a **Circular Doubly Linked List**.",
      "options": [
        {
          "optionId": "ch_viva_5_q27_opt1",
          "optionText": "I take the `head` and `tail` pointers. I set `tail.next = head` (closing the forward loop). I set `head.prev = tail` (closing the backward loop). I return the `head`. Complexity $O(1)$."
        },
        {
          "optionId": "ch_viva_5_q27_opt2",
          "optionText": "I eliminate the null terminations. The last node's 'Next' pointer is updated to point to the first node. The first node's 'Previous' pointer is updated to point to the last node. This creates a bidirectional ring."
        },
        {
          "optionId": "ch_viva_5_q27_opt3",
          "optionText": "If the list is empty, return. If not, I bridge the gap: Link Tail to Head, Link Head to Tail. The list is now circular."
        },
        {
          "optionId": "ch_viva_5_q27_opt4",
          "optionText": "I will set `tail.next = head`."
        },
        {
          "optionId": "ch_viva_5_q27_opt5",
          "optionText": "I will set `head.prev = tail`."
        },
        {
          "optionId": "ch_viva_5_q27_opt6",
          "optionText": "I will create a new circular list and copy nodes."
        },
        {
          "optionId": "ch_viva_5_q27_opt7",
          "optionText": "I will use a loop to connect them."
        },
        {
          "optionId": "ch_viva_5_q27_opt8",
          "optionText": "I will traverse to find the middle."
        },
        {
          "optionId": "ch_viva_5_q27_opt9",
          "optionText": "I will set `head = tail`."
        },
        {
          "optionId": "ch_viva_5_q27_opt10",
          "optionText": "I will delete the null pointers."
        },
        {
          "optionId": "ch_viva_5_q27_opt11",
          "optionText": "I will swap head and tail."
        },
        {
          "optionId": "ch_viva_5_q27_opt12",
          "optionText": "I will use a sentinel node."
        },
        {
          "optionId": "ch_viva_5_q27_opt13",
          "optionText": "I will assume it's already circular."
        },
        {
          "optionId": "ch_viva_5_q27_opt14",
          "optionText": "I will set `node.next = node`."
        },
        {
          "optionId": "ch_viva_5_q27_opt15",
          "optionText": "I will use recursion."
        }
      ],
      "correctOptionIds": ["ch_viva_5_q27_opt1", "ch_viva_5_q27_opt2", "ch_viva_5_q27_opt3"],
      "explanationText": "Converting a Doubly Linked List to a Circular Doubly Linked List is an $O(1)$ operation. It requires two pointer updates: the tail's `next` must point to the head, and the head's `prev` must point to the tail."
    }
  ]
}
