{
  "batchIndex": 5,
  "questions": [
    {
      "chapterIndex": 2,
      "questionIndex": 0,
      "questionId": "ch_viva_3_q16",
      "questionText": "Sketch an algorithm to convert a Graph represented as an **Adjacency Matrix** into an **Adjacency List**.",
      "options": [
        {
          "optionId": "ch_viva_3_q16_opt1",
          "optionText": "I initialize an array of empty Linked Lists, size V. I iterate `i` from 0 to V-1 (rows). Inside, I iterate `j` from 0 to V-1 (cols). If `matrix[i][j] \\ne 0` (edge exists), I add `j` to `List[i]`. Return the array of lists."
        },
        {
          "optionId": "ch_viva_3_q16_opt2",
          "optionText": "I create an `AdjacencyList` structure. I loop through every cell of the matrix. Whenever I encounter a '1' at `[row][col]`, I access the list for `row` and append `col` to it. This filters out the non-edges."
        },
        {
          "optionId": "ch_viva_3_q16_opt3",
          "optionText": "I construct a Map where Key is Vertex ID and Value is a List. I scan the matrix. For every non-zero entry at `(u, v)`, I append `v` to `Map.get(u)`. This efficiently compresses the sparse data."
        },
        {
          "optionId": "ch_viva_3_q16_opt4",
          "optionText": "I will flatten the matrix into a single array."
        },
        {
          "optionId": "ch_viva_3_q16_opt5",
          "optionText": "I will assume the matrix is sparse and use a Hash Map."
        },
        {
          "optionId": "ch_viva_3_q16_opt6",
          "optionText": "I will loop `i` from 0 to N. `List[i] = Matrix[i]`."
        },
        {
          "optionId": "ch_viva_3_q16_opt7",
          "optionText": "I will use BFS to traverse the matrix."
        },
        {
          "optionId": "ch_viva_3_q16_opt8",
          "optionText": "I will swap rows and columns."
        },
        {
          "optionId": "ch_viva_3_q16_opt9",
          "optionText": "I will store the weights in a stack."
        },
        {
          "optionId": "ch_viva_3_q16_opt10",
          "optionText": "I iterate `matrix[i][j]`. If it is 0, I add it to the list."
        },
        {
          "optionId": "ch_viva_3_q16_opt11",
          "optionText": "I create a Linked List for every entry in the matrix."
        },
        {
          "optionId": "ch_viva_3_q16_opt12",
          "optionText": "I iterate `i` and `j`. `List.add(matrix[i][j])`."
        },
        {
          "optionId": "ch_viva_3_q16_opt13",
          "optionText": "I only check the upper triangle of the matrix."
        },
        {
          "optionId": "ch_viva_3_q16_opt14",
          "optionText": "I use a Queue to store neighbors."
        },
        {
          "optionId": "ch_viva_3_q16_opt15",
          "optionText": "I return the matrix as is."
        }
      ],
      "correctOptionIds": ["ch_viva_3_q16_opt1", "ch_viva_3_q16_opt2", "ch_viva_3_q16_opt3"],
      "explanationText": "The conversion requires iterating through the $V \\times V$ matrix. For every non-zero entry at `matrix[i][j]`, an edge exists from vertex `i` to vertex `j`. This means `j` must be added to the adjacency list of `i`. The time complexity is $O(V^2)$."
    },
    {
      "chapterIndex": 2,
      "questionIndex": 1,
      "questionId": "ch_viva_3_q17",
      "questionText": "Sketch an algorithm to **count the number of leaf nodes** in a **Binary Tree**.",
      "options": [
        {
          "optionId": "ch_viva_3_q17_opt1",
          "optionText": "I will use **DFS** (recursion or stack). If `root` is null, return 0. If `root.left` and `root.right` are BOTH null, it is a leaf, return 1. Otherwise, return `count(left) + count(right)`."
        },
        {
          "optionId": "ch_viva_3_q17_opt2",
          "optionText": "I will perform a **Level Order Traversal** using a Queue. I initialize `count = 0`. As I dequeue each node, I check: does it have NO children? If yes, `count++`. If no, enqueue existing children. Return `count`."
        },
        {
          "optionId": "ch_viva_3_q17_opt3",
          "optionText": "I traverse the tree. For every node, I check the 'Leaf Condition': is it childless? If so, I increment my counter. I ensure I visit every node using a standard Stack-based traversal."
        },
        {
          "optionId": "ch_viva_3_q17_opt4",
          "optionText": "I will count all nodes and divide by 2."
        },
        {
          "optionId": "ch_viva_3_q17_opt5",
          "optionText": "I will traverse and count nodes where `next == null`."
        },
        {
          "optionId": "ch_viva_3_q17_opt6",
          "optionText": "I will return the size of the last level."
        },
        {
          "optionId": "ch_viva_3_q17_opt7",
          "optionText": "I will use In-Order traversal and count the first and last node."
        },
        {
          "optionId": "ch_viva_3_q17_opt8",
          "optionText": "I will count nodes that have 1 child."
        },
        {
          "optionId": "ch_viva_3_q17_opt9",
          "optionText": "I will use the height of the tree."
        },
        {
          "optionId": "ch_viva_3_q17_opt10",
          "optionText": "I will check if `node == null`."
        },
        {
          "optionId": "ch_viva_3_q17_opt11",
          "optionText": "I will count nodes where `left \\ne null` OR `right \\ne null`."
        },
        {
          "optionId": "ch_viva_3_q17_opt12",
          "optionText": "I will use an array to store the tree and count empty indices."
        },
        {
          "optionId": "ch_viva_3_q17_opt13",
          "optionText": "I will delete the root until only leaves remain."
        },
        {
          "optionId": "ch_viva_3_q17_opt14",
          "optionText": "I will assume the tree is a Heap."
        },
        {
          "optionId": "ch_viva_3_q17_opt15",
          "optionText": "I will count how many null pointers exist."
        }
      ],
      "correctOptionIds": ["ch_viva_3_q17_opt1", "ch_viva_3_q17_opt2", "ch_viva_3_q17_opt3"],
      "explanationText": "A leaf node is defined as a node where both the left and right children are null. Any full traversal (DFS or BFS) can be used, provided the leaf condition is checked at every node. Time complexity is $O(N)$."
    },
    {
      "chapterIndex": 2,
      "questionIndex": 2,
      "questionId": "ch_viva_3_q18",
      "questionText": "Sketch an algorithm to find the **height** (max depth) of a **Binary Tree**.",
      "options": [
        {
          "optionId": "ch_viva_3_q18_opt1",
          "optionText": "I will use **Recursion**. Base case: if node is null, return -1 (or 0). Recursive step: `leftH = height(node.left)`, `rightH = height(node.right)`. Return `1 + max(leftH, rightH)`."
        },
        {
          "optionId": "ch_viva_3_q18_opt2",
          "optionText": "I will use **BFS** with a Queue. I initialize `height = 0`. Inside the loop, I record `size = queue.size()`. I process exactly `size` nodes (this clears one level). Then I increment `height`. Repeat until queue empty."
        },
        {
          "optionId": "ch_viva_3_q18_opt3",
          "optionText": "I will use a Stack for DFS, but I will store pairs `(Node, Depth)`. I track a variable `maxDepth`. As I push nodes, I increment their depth. `maxDepth = max(maxDepth, currentDepth)`."
        },
        {
          "optionId": "ch_viva_3_q18_opt4",
          "optionText": "I will count the total number of nodes."
        },
        {
          "optionId": "ch_viva_3_q18_opt5",
          "optionText": "I will go strictly down the left branch."
        },
        {
          "optionId": "ch_viva_3_q18_opt6",
          "optionText": "I will use `height = left.height + right.height`."
        },
        {
          "optionId": "ch_viva_3_q18_opt7",
          "optionText": "I will use In-Order traversal."
        },
        {
          "optionId": "ch_viva_3_q18_opt8",
          "optionText": "I will return `node.value`."
        },
        {
          "optionId": "ch_viva_3_q18_opt9",
          "optionText": "I will subtract min depth from max depth."
        },
        {
          "optionId": "ch_viva_3_q18_opt10",
          "optionText": "I will use a Stack and return stack size."
        },
        {
          "optionId": "ch_viva_3_q18_opt11",
          "optionText": "I will count how many nulls there are."
        },
        {
          "optionId": "ch_viva_3_q18_opt12",
          "optionText": "I will traverse and increment height for every node."
        },
        {
          "optionId": "ch_viva_3_q18_opt13",
          "optionText": "I will check if the tree is AVL."
        },
        {
          "optionId": "ch_viva_3_q18_opt14",
          "optionText": "I will use a fast pointer and slow pointer."
        },
        {
          "optionId": "ch_viva_3_q18_opt15",
          "optionText": "I will use `1 + min(left, right)`."
        }
      ],
      "correctOptionIds": ["ch_viva_3_q18_opt1", "ch_viva_3_q18_opt2", "ch_viva_3_q18_opt3"],
      "explanationText": "Height is the longest path from the root to a leaf. This requires finding the maximum depth among all paths. Both recursive DFS (Option 1) and iterative BFS (Option 2) are $O(N)$ time solutions. BFS is often preferred for finding depth iteratively as it naturally processes level by level."
    }
  ]
}
