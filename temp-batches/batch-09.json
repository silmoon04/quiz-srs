{
  "batchIndex": 9,
  "questions": [
    {
      "chapterIndex": 4,
      "questionIndex": 2,
      "questionId": "ch_viva_5_q28",
      "questionText": "Sketch an algorithm to **count the number of nodes** in a **Circular Linked List**.",
      "options": [
        {
          "optionId": "ch_viva_5_q28_opt1",
          "optionText": "I handle the empty case (return 0). Else, I initialize `count = 1` and `curr = head.next`. I loop while `curr \\ne head`. Inside, `count++` and `curr = curr.next`. Return `count`."
        },
        {
          "optionId": "ch_viva_5_q28_opt2",
          "optionText": "I mark the starting point (`head`). I traverse the list, incrementing a counter for each step. I stop the traversal exactly when my pointer lands back on the `head` reference."
        },
        {
          "optionId": "ch_viva_5_q28_opt3",
          "optionText": "I initialize `temp = head`. Do-While loop: move `temp` forward, increment count. Condition: `while temp \\ne head`. This ensures I count the list exactly once."
        },
        {
          "optionId": "ch_viva_5_q28_opt4",
          "optionText": "I loop until `curr == null`."
        },
        {
          "optionId": "ch_viva_5_q28_opt5",
          "optionText": "I loop until `curr.next == null`."
        },
        {
          "optionId": "ch_viva_5_q28_opt6",
          "optionText": "I count for 100 iterations."
        },
        {
          "optionId": "ch_viva_5_q28_opt7",
          "optionText": "I use a Hash Set to count unique nodes."
        },
        {
          "optionId": "ch_viva_5_q28_opt8",
          "optionText": "I start at head and loop. `count++`."
        },
        {
          "optionId": "ch_viva_5_q28_opt9",
          "optionText": "I check if `head == tail`."
        },
        {
          "optionId": "ch_viva_5_q28_opt10",
          "optionText": "I use recursion."
        },
        {
          "optionId": "ch_viva_5_q28_opt11",
          "optionText": "I break the circle then count."
        },
        {
          "optionId": "ch_viva_5_q28_opt12",
          "optionText": "I return `list.size`."
        },
        {
          "optionId": "ch_viva_5_q28_opt13",
          "optionText": "I use two pointers."
        },
        {
          "optionId": "ch_viva_5_q28_opt14",
          "optionText": "I assume size is stored in head."
        },
        {
          "optionId": "ch_viva_5_q28_opt15",
          "optionText": "I count until `curr.value` repeats."
        }
      ],
      "correctOptionIds": ["ch_viva_5_q28_opt1", "ch_viva_5_q28_opt2", "ch_viva_5_q28_opt3"],
      "explanationText": "Since a circular list has no null termination, the traversal must stop when the pointer returns to the starting node (`head`). The `do-while` loop (Option 3) is often the most elegant way to ensure the loop executes at least once for a non-empty list. Time complexity is $O(N)$."
    },
    {
      "chapterIndex": 4,
      "questionIndex": 3,
      "questionId": "ch_viva_5_q29",
      "questionText": "Sketch an algorithm to **reverse a string** using a **Stack**.",
      "options": [
        {
          "optionId": "ch_viva_5_q29_opt1",
          "optionText": "I create an empty Stack. I iterate over the string, pushing each **character** onto the Stack. Then, I create a StringBuilder (or char array). While Stack is not empty, I `pop` the character and append it to the builder. Return the built string."
        },
        {
          "optionId": "ch_viva_5_q29_opt2",
          "optionText": "I exploit the LIFO property. First pass: read string left-to-right, pushing characters. Second pass: pop characters (which come out right-to-left) and construct the new string."
        },
        {
          "optionId": "ch_viva_5_q29_opt3",
          "optionText": "I transfer the string data into a Stack. Since the last character entered is the first one retrieved, simply emptying the Stack into a new buffer produces the reversed string."
        },
        {
          "optionId": "ch_viva_5_q29_opt4",
          "optionText": "I push the string, then pop the string."
        },
        {
          "optionId": "ch_viva_5_q29_opt5",
          "optionText": "I use a Queue."
        },
        {
          "optionId": "ch_viva_5_q29_opt6",
          "optionText": "I swap the first and last characters."
        },
        {
          "optionId": "ch_viva_5_q29_opt7",
          "optionText": "I use recursion."
        },
        {
          "optionId": "ch_viva_5_q29_opt8",
          "optionText": "I push half the string."
        },
        {
          "optionId": "ch_viva_5_q29_opt9",
          "optionText": "I use an array."
        },
        {
          "optionId": "ch_viva_5_q29_opt10",
          "optionText": "I traverse backwards."
        },
        {
          "optionId": "ch_viva_5_q29_opt11",
          "optionText": "I push chars, then peek."
        },
        {
          "optionId": "ch_viva_5_q29_opt12",
          "optionText": "I push words, not chars."
        },
        {
          "optionId": "ch_viva_5_q29_opt13",
          "optionText": "I use `string.reverse()`."
        },
        {
          "optionId": "ch_viva_5_q29_opt14",
          "optionText": "I pop before pushing."
        },
        {
          "optionId": "ch_viva_5_q29_opt15",
          "optionText": "I use two stacks."
        }
      ],
      "correctOptionIds": ["ch_viva_5_q29_opt1", "ch_viva_5_q29_opt2", "ch_viva_5_q29_opt3"],
      "explanationText": "The LIFO property of a Stack is perfectly suited for reversal. By pushing characters in order and popping them out, the order is naturally inverted. This is an $O(N)$ time and $O(N)$ space operation."
    },
    {
      "chapterIndex": 4,
      "questionIndex": 4,
      "questionId": "ch_viva_5_q30",
      "questionText": "Sketch an algorithm to find the **minimum element** in a **Sorted Array that has been Rotated** (e.g., `[4, 5, 1, 2, 3]`).",
      "options": [
        {
          "optionId": "ch_viva_5_q30_opt1",
          "optionText": "I use **Binary Search**. `Lo=0`, `Hi=len-1`. Loop while `Lo < Hi`. `Mid = (Lo+Hi)/2`. If `arr[mid] > arr[Hi]`, the min is in the **right** half (`Lo = Mid + 1`). Else, min is in **left** half or is mid (`Hi = Mid`). Return `arr[Lo]`."
        },
        {
          "optionId": "ch_viva_5_q30_opt2",
          "optionText": "I perform a logarithmic search. I compare the middle element to the right-most element. If the middle is larger, the 'reset point' (minimum) must be to the right. Otherwise, it's to the left. I narrow the range until one element remains."
        },
        {
          "optionId": "ch_viva_5_q30_opt3",
          "optionText": "I detect the inflection point using Binary Search. The inflection point is the only place where `Element(i) > Element(i+1)`. I adjust my bounds to hone in on this drop."
        },
        {
          "optionId": "ch_viva_5_q30_opt4",
          "optionText": "I will iterate and find the min."
        },
        {
          "optionId": "ch_viva_5_q30_opt5",
          "optionText": "I will sort the array."
        },
        {
          "optionId": "ch_viva_5_q30_opt6",
          "optionText": "I will use standard Binary Search looking for 0."
        },
        {
          "optionId": "ch_viva_5_q30_opt7",
          "optionText": "I will check if `arr[0] < arr[last]`."
        },
        {
          "optionId": "ch_viva_5_q30_opt8",
          "optionText": "I will split the array in half and check mins recursively."
        },
        {
          "optionId": "ch_viva_5_q30_opt9",
          "optionText": "I will use a Hash Set."
        },
        {
          "optionId": "ch_viva_5_q30_opt10",
          "optionText": "I will compare `mid` with `left`."
        },
        {
          "optionId": "ch_viva_5_q30_opt11",
          "optionText": "I will stop when `mid == target`."
        },
        {
          "optionId": "ch_viva_5_q30_opt12",
          "optionText": "I will use a Stack."
        },
        {
          "optionId": "ch_viva_5_q30_opt13",
          "optionText": "I will swap elements back to sorted."
        },
        {
          "optionId": "ch_viva_5_q30_opt14",
          "optionText": "I will return `arr[0]`."
        },
        {
          "optionId": "ch_viva_5_q30_opt15",
          "optionText": "I will check neighbors of mid only."
        }
      ],
      "correctOptionIds": ["ch_viva_5_q30_opt1", "ch_viva_5_q30_opt2", "ch_viva_5_q30_opt3"],
      "explanationText": "Since the array is partially sorted, we can use a modified Binary Search to find the minimum element in $O(\\log N)$ time. The key is comparing the middle element with the rightmost element to determine which half contains the 'dip' (the minimum)."
    }
  ]
}
