{
  "batchIndex": 0,
  "questions": [
    {
      "chapterIndex": 0,
      "questionIndex": 0,
      "questionId": "ch_viva_1_q1",
      "questionText": "Sketch an algorithm to check if a **Stack** and a **Queue** contain the exact same set of integer elements (order does not matter). You may use auxiliary data structures.",
      "options": [
        {
          "optionId": "ch_viva_1_q1_opt1",
          "optionText": "I will iterate through the stack using an index `i` from 0 to size..."
        },
        {
          "optionId": "ch_viva_1_q1_opt2",
          "optionText": "I will use two pointers, one at the top of the stack and one at the front of the queue, and compare them."
        },
        {
          "optionId": "ch_viva_1_q1_opt3",
          "optionText": "I will sort the Stack in place."
        },
        {
          "optionId": "ch_viva_1_q1_opt4",
          "optionText": "I will pop from the stack and dequeue from the queue simultaneously. If they don't match, return false."
        },
        {
          "optionId": "ch_viva_1_q1_opt5",
          "optionText": "I will use Binary Search on the Stack to find the Queue elements."
        },
        {
          "optionId": "ch_viva_1_q1_opt6",
          "optionText": "Time complexity is $O(1)$ because I'm just comparing elements."
        },
        {
          "optionId": "ch_viva_1_q1_opt7",
          "optionText": "I will check `stack.contains(queue.front())`."
        },
        {
          "optionId": "ch_viva_1_q1_opt8",
          "optionText": "I will pop everything from the Stack into the Queue and check for duplicates."
        },
        {
          "optionId": "ch_viva_1_q1_opt9",
          "optionText": "I will use a Hash Map to count frequencies. First, I pop all elements from the Stack, incrementing their counts in the Map. Then, I dequeue all elements from the Queue, decrementing their counts. Finally, I check if the Map is empty or all counts are zero. Return true if so."
        },
        {
          "optionId": "ch_viva_1_q1_opt10",
          "optionText": "I will initialize two empty auxiliary arrays. I will pop the Stack into Array A and dequeue the Queue into Array B. I will then Sort both arrays. Finally, I will iterate through both arrays simultaneously to check if they are identical. Return True if the loop finishes successfully."
        },
        {
          "optionId": "ch_viva_1_q1_opt11",
          "optionText": "I will use a Hash Set. I pop elements from the Stack and add them to the Set. Then, I dequeue from the Queue and check if each element exists in the Set."
        },
        {
          "optionId": "ch_viva_1_q1_opt12",
          "optionText": "I will simply return `stack.equals(queue)`."
        },
        {
          "optionId": "ch_viva_1_q1_opt13",
          "optionText": "I will peek at the top of the stack and the front of the queue loop until empty."
        },
        {
          "optionId": "ch_viva_1_q1_opt14",
          "optionText": "I will convert both to arrays and compare `array1 == array2`."
        },
        {
          "optionId": "ch_viva_1_q1_opt15",
          "optionText": "I will use a Frequency Map. I loop through the Stack and Queue, updating counts. If all counts are zero, they are equal."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q1_opt9", "ch_viva_1_q1_opt10", "ch_viva_1_q1_opt15"],
      "explanationText": "The key is handling duplicates and order independence efficiently. \n\n1. **Hash Map (O(N) Time, O(N) Space):** This is the most efficient method as it handles duplicates and order in a single pass.\n2. **Sorting (O(N log N) Time, O(N) Space):** This is also valid, but slower than the Hash Map approach.\n\nIncorrect answers fail because they assume order matters, use inefficient $O(N^2)$ search, or rely on non-existent methods."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 1,
      "questionId": "ch_viva_1_q2",
      "questionText": "Sketch an algorithm to move all elements from a **Queue** into a **Stack** such that the order of elements is **reversed** compared to the original Queue.",
      "options": [
        {
          "optionId": "ch_viva_1_q2_opt1",
          "optionText": "I will initialize an empty Stack. While the Queue is not empty, I will `dequeue` an element and immediately `push` it onto the Stack. Finally, I return the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt2",
          "optionText": "I'll create a function taking the Queue. I'll create a Stack. I loop until `queue.isEmpty()`. Inside the loop: `val = queue.dequeue()`, `stack.push(val)`. Return the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt3",
          "optionText": "I will transfer elements directly. Since the Queue removes from the front (1st item) and the Stack adds to the top, the first item out of the Queue becomes the bottom of the Stack. The last item out becomes the top. This naturally reverses the access order."
        },
        {
          "optionId": "ch_viva_1_q2_opt4",
          "optionText": "I will use two auxiliary stacks to flip the order twice."
        },
        {
          "optionId": "ch_viva_1_q2_opt5",
          "optionText": "I will swap the head and tail pointers of the Queue."
        },
        {
          "optionId": "ch_viva_1_q2_opt6",
          "optionText": "I will iterate backwards through the Queue."
        },
        {
          "optionId": "ch_viva_1_q2_opt7",
          "optionText": "I will push the whole Queue object onto the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt8",
          "optionText": "I will dequeue elements and add them to the *bottom* of the Stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt9",
          "optionText": "I will use an array, fill it with the queue, reverse the array, then push to stack."
        },
        {
          "optionId": "ch_viva_1_q2_opt10",
          "optionText": "I will use recursion to reach the end of the queue first."
        },
        {
          "optionId": "ch_viva_1_q2_opt11",
          "optionText": "Time complexity is $O(N^2)$ because push is expensive."
        },
        {
          "optionId": "ch_viva_1_q2_opt12",
          "optionText": "I will use a Doubly Linked List to traverse the Queue in reverse."
        },
        {
          "optionId": "ch_viva_1_q2_opt13",
          "optionText": "I will delete the Queue and create a new Stack with the same values."
        },
        {
          "optionId": "ch_viva_1_q2_opt14",
          "optionText": "I will peek at the queue, push to stack, then dequeue."
        },
        {
          "optionId": "ch_viva_1_q2_opt15",
          "optionText": "I will return the Queue as a Stack."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q2_opt1", "ch_viva_1_q2_opt2", "ch_viva_1_q2_opt3"],
      "explanationText": "Moving elements from a FIFO structure (Queue) directly into a LIFO structure (Stack) naturally reverses the order of retrieval. The first element dequeued becomes the deepest element in the stack, and the last element dequeued becomes the top element. This is an $O(N)$ operation."
    },
    {
      "chapterIndex": 0,
      "questionIndex": 2,
      "questionId": "ch_viva_1_q3",
      "questionText": "Sketch an algorithm to insert a new node with value `K` at the **Head** of a **Circular Linked List**, given a pointer to the `tail`.",
      "options": [
        {
          "optionId": "ch_viva_1_q3_opt1",
          "optionText": "First, I check if the list is empty. If so, create the node and point it to itself. If not, I create `newNode`. I set `newNode.next = tail.next` (current head). Then, I update `tail.next = newNode`. I return the original `tail` pointer."
        },
        {
          "optionId": "ch_viva_1_q3_opt2",
          "optionText": "I will initialize a `newNode` with data `K`. I link `newNode.next` to the current `head` (which is `tail.next`). Then I simply update the `tail`'s next pointer to point to my `newNode`. This effectively places it at the start without moving the tail."
        },
        {
          "optionId": "ch_viva_1_q3_opt3",
          "optionText": "I handle the empty case by making the node point to itself. For the non-empty case, I perform a standard insertion after `tail`, but I strictly *do not* update the `tail` reference itself, leaving the new node as the new head."
        },
        {
          "optionId": "ch_viva_1_q3_opt4",
          "optionText": "I will create a node and set `head.prev = new node`."
        },
        {
          "optionId": "ch_viva_1_q3_opt5",
          "optionText": "I will set `tail.next = new node` and `new node.next = null`."
        },
        {
          "optionId": "ch_viva_1_q3_opt6",
          "optionText": "I will traverse to the end of the list."
        },
        {
          "optionId": "ch_viva_1_q3_opt7",
          "optionText": "I will set `tail = new node`."
        },
        {
          "optionId": "ch_viva_1_q3_opt8",
          "optionText": "I will update `head` pointer to `new node`."
        },
        {
          "optionId": "ch_viva_1_q3_opt9",
          "optionText": "Complexity is $O(N)$ because I have to find the head."
        },
        {
          "optionId": "ch_viva_1_q3_opt10",
          "optionText": "I will swap the values of the tail and the new node."
        },
        {
          "optionId": "ch_viva_1_q3_opt11",
          "optionText": "I will create a node, link it to `tail`, and link `tail` to it."
        },
        {
          "optionId": "ch_viva_1_q3_opt12",
          "optionText": "If the list is empty, I just set `tail = new node`."
        },
        {
          "optionId": "ch_viva_1_q3_opt13",
          "optionText": "I will use a temporary pointer to traverse the circle."
        },
        {
          "optionId": "ch_viva_1_q3_opt14",
          "optionText": "I will insert it after the tail and move the tail pointer forward."
        },
        {
          "optionId": "ch_viva_1_q3_opt15",
          "optionText": "I will check if `tail.next` is null."
        }
      ],
      "correctOptionIds": ["ch_viva_1_q3_opt1", "ch_viva_1_q3_opt2", "ch_viva_1_q3_opt3"],
      "explanationText": "In a circular list managed by a `tail` pointer, the head is always `tail.next`. Insertion at the head is an $O(1)$ operation: link the new node to the current head, then update the tail's next pointer to the new node."
    }
  ]
}
