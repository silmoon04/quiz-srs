
====================================================================================================
QUIZ-SRS COMPLETE CODEBASE EXTRACTION
Generated: 2025-09-24 17:16:01
Total Files: 143
====================================================================================================


PROJECT: my-v0-project
VERSION: 0.1.0
DESCRIPTION: No description
SCRIPTS: 24 scripts
DEPENDENCIES: 65 runtime, 35 dev


====================================================================================================
DIRECTORY STRUCTURE
====================================================================================================
📁 /
├── 📁 app/
├── ├── 📁 test/
├── ├── └── 📄 page.tsx
├── ├── 📄 globals.css
├── ├── 📄 layout.tsx
├── └── 📄 page.tsx
├── 📁 components/
├── ├── 📁 a11y/
├── ├── ├── 📄 AccessibleOptionList.tsx
├── ├── ├── 📄 AccessibleQuestionGrid.tsx
├── ├── ├── 📄 DashboardWithInlineErrors.tsx
├── ├── ├── 📄 InlineErrorHandler.tsx
├── ├── └── 📄 ScreenReaderAnnouncer.tsx
├── ├── 📁 rendering/
├── ├── └── 📄 MarkdownRenderer.tsx
├── ├── 📁 ui/
├── ├── ├── 📄 accordion.tsx
├── ├── ├── 📄 alert-dialog.tsx
├── ├── ├── 📄 alert.tsx
├── ├── ├── 📄 aspect-ratio.tsx
├── ├── ├── 📄 avatar.tsx
├── ├── ├── 📄 badge.tsx
├── ├── ├── 📄 breadcrumb.tsx
├── ├── ├── 📄 button.tsx
├── ├── ├── 📄 calendar.tsx
├── ├── ├── 📄 card.tsx
├── ├── ├── 📄 carousel.tsx
├── ├── ├── 📄 checkbox.tsx
├── ├── ├── 📄 circular-progress.tsx
├── ├── ├── 📄 collapsible.tsx
├── ├── ├── 📄 command.tsx
├── ├── ├── 📄 context-menu.tsx
├── ├── ├── 📄 dialog.tsx
├── ├── ├── 📄 dropdown-menu.tsx
├── ├── ├── 📄 form.tsx
├── ├── ├── 📄 hover-card.tsx
├── ├── ├── 📄 input-otp.tsx
├── ├── ├── 📄 input.tsx
├── ├── ├── 📄 label.tsx
├── ├── ├── 📄 menubar.tsx
├── ├── ├── 📄 navigation-menu.tsx
├── ├── ├── 📄 pagination.tsx
├── ├── ├── 📄 popover.tsx
├── ├── ├── 📄 progress.tsx
├── ├── ├── 📄 radio-group.tsx
├── ├── ├── 📄 resizable.tsx
├── ├── ├── 📄 scroll-area.tsx
├── ├── ├── 📄 select.tsx
├── ├── ├── 📄 separator.tsx
├── ├── ├── 📄 sheet.tsx
├── ├── ├── 📄 sidebar.tsx
├── ├── ├── 📄 skeleton.tsx
├── ├── ├── 📄 slider.tsx
├── ├── ├── 📄 sonner.tsx
├── ├── ├── 📄 switch.tsx
├── ├── ├── 📄 table.tsx
├── ├── ├── 📄 tabs.tsx
├── ├── ├── 📄 textarea.tsx
├── ├── ├── 📄 toast.tsx
├── ├── ├── 📄 toaster.tsx
├── ├── ├── 📄 toggle-group.tsx
├── ├── ├── 📄 toggle.tsx
├── ├── ├── 📄 tooltip.tsx
├── ├── ├── 📄 use-mobile.tsx
├── ├── └── 📄 use-toast.ts
├── ├── 📄 all-questions-view.tsx
├── ├── 📄 chapter-card.tsx
├── ├── 📄 confirmation-modal-radix.tsx
├── ├── 📄 dashboard.tsx
├── ├── 📄 option-card.tsx
├── ├── 📄 progress-bar.tsx
├── ├── 📄 question-editor.tsx
├── ├── 📄 question-navigation-menu.tsx
├── ├── 📄 question-review-modal.tsx
├── ├── 📄 quiz-complete.tsx
├── ├── 📄 quiz-session.tsx
├── ├── 📄 theme-provider.tsx
├── ├── 📄 toast-notification.tsx
├── └── 📄 welcome-screen.tsx
├── 📁 docs/
├── ├── 📄 SecureTextRenderer.md
├── └── 📄 TESTING.md
├── 📁 hooks/
├── ├── 📄 use-mobile.tsx
├── └── 📄 use-toast.ts
├── 📁 lib/
├── ├── 📁 markdown/
├── ├── ├── 📄 latex-processor.ts
├── ├── ├── 📄 pipeline.ts
├── ├── ├── 📄 sync-pipeline.ts
├── ├── └── 📄 working-pipeline.ts
├── ├── 📁 schema/
├── ├── └── 📄 quiz.ts
├── └── 📄 utils.ts
├── 📁 public/
├── ├── 📄 advanced-test-quiz.md
├── ├── 📄 default-quiz.json
├── ├── 📄 dsa-comprehensive-quiz.md
├── └── 📄 xss-test-quiz.md
├── 📁 reports/
├── 📁 scripts/
├── └── 📄 audit-snapshot.mjs
├── 📁 tests/
├── ├── 📁 a11y/
├── ├── ├── 📄 announce.smoke.test.tsx
├── ├── ├── 📄 announcer.test.tsx
├── ├── ├── 📄 inline-errors.test.tsx
├── ├── ├── 📄 keyboard-access.test.tsx
├── ├── ├── 📄 modal.focus.test.tsx
├── ├── ├── 📄 modal.trap.smoke.test.tsx
├── ├── └── 📄 reduced-motion.test.tsx
├── ├── 📁 access/
├── ├── └── 📄 accessibility.test.tsx
├── ├── 📁 e2e/
├── ├── └── 📄 quiz-flow.spec.ts
├── ├── 📁 fixtures/
├── ├── ├── 📄 json-bad-latex.json
├── ├── ├── 📄 json-bad-refs.json
├── ├── ├── 📄 json-dup-ids.json
├── ├── ├── 📄 json-katex.json
├── ├── ├── 📄 json-missing-fields.json
├── ├── ├── 📄 md-code-stoppers.md
├── ├── ├── 📄 md-duplicate-ids.md
├── ├── ├── 📄 md-mcq-aliases.md
├── ├── ├── 📄 md-mcq-basic.md
├── ├── ├── 📄 md-missing-ids.md
├── ├── └── 📄 md-tf.md
├── ├── 📁 int/
├── ├── 📁 meta/
├── ├── └── 📄 static.audits.test.ts
├── ├── 📁 renderer/
├── ├── └── 📄 sanitize.contract.test.tsx
├── ├── 📁 unit/
├── └── 📄 setup.ts
├── 📁 types/
├── └── 📄 quiz-types.ts
├── 📁 utils/
├── ├── 📁 quiz-validation/
├── ├── └── 📄 index.ts
├── └── 📄 quiz-validation-refactored.ts
├── 📄 CHANGELOG.md
├── 📄 components.json
├── 📄 eslint.config.js
├── 📄 next-env.d.ts
├── 📄 next.config.mjs
├── 📄 package.json
├── 📄 playwright.config.ts
├── 📄 postcss.config.mjs
├── 📄 README.md
├── 📄 tailwind.config.ts
├── 📄 tsconfig.json
├── 📄 tsconfig.strict.json
├── 📄 vitest.config.accessibility.ts
├── 📄 vitest.config.integration.ts
└── 📄 vitest.config.ts


====================================================================================================
FILE CONTENTS
====================================================================================================

================================================================================
FILE: package.json
SIZE: 4,667 bytes | LINES: 151
================================================================================
{
  "name": "my-v0-project",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "build": "next build",
    "dev": "next dev",
    "lint": "next lint",
    "start": "next start",
    "typecheck": "tsc --noEmit",
    "typecheck:strict": "tsc -p tsconfig.strict.json --noEmit",
    "test:unit": "vitest run",
    "test:unit:watch": "vitest",
    "test:int": "vitest run --config vitest.config.integration.ts",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:access": "vitest run --config vitest.config.accessibility.ts",
    "test": "npm run test:unit && npm run test:int && npm run test:access",
    "coverage": "vitest run --coverage",
    "mutation": "echo 'Mutation testing not implemented yet'",
    "analyze": "ANALYZE=true next build",
    "depcheck": "depcheck",
    "prune:exports": "ts-prune",
    "prepare": "husky install",
    "graph": "madge --ts-config ./tsconfig.json --extensions ts,tsx --image graph.png .",
    "unused": "knip",
    "test:ui": "vitest",
    "size": "size-limit",
    "format": "prettier --write ."
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-accordion": "1.2.2",
    "@radix-ui/react-alert-dialog": "1.1.4",
    "@radix-ui/react-aspect-ratio": "1.1.1",
    "@radix-ui/react-avatar": "1.1.2",
    "@radix-ui/react-checkbox": "1.1.3",
    "@radix-ui/react-collapsible": "1.1.2",
    "@radix-ui/react-context-menu": "2.2.4",
    "@radix-ui/react-dialog": "1.1.4",
    "@radix-ui/react-dropdown-menu": "2.1.4",
    "@radix-ui/react-hover-card": "1.1.4",
    "@radix-ui/react-label": "2.1.1",
    "@radix-ui/react-menubar": "1.1.4",
    "@radix-ui/react-navigation-menu": "1.2.3",
    "@radix-ui/react-popover": "1.1.4",
    "@radix-ui/react-progress": "1.1.1",
    "@radix-ui/react-radio-group": "1.2.2",
    "@radix-ui/react-scroll-area": "1.2.2",
    "@radix-ui/react-select": "2.1.4",
    "@radix-ui/react-separator": "1.1.1",
    "@radix-ui/react-slider": "1.2.2",
    "@radix-ui/react-slot": "1.1.1",
    "@radix-ui/react-switch": "1.1.2",
    "@radix-ui/react-tabs": "1.1.2",
    "@radix-ui/react-toast": "1.2.4",
    "@radix-ui/react-toggle": "1.1.1",
    "@radix-ui/react-toggle-group": "1.1.1",
    "@radix-ui/react-tooltip": "1.1.6",
    "@vercel/analytics": "1.3.1",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "1.0.4",
    "date-fns": "4.1.0",
    "embla-carousel-react": "8.5.1",
    "geist": "^1.3.1",
    "input-otp": "1.4.1",
    "katex": "latest",
    "lucide-react": "^0.454.0",
    "mermaid": "latest",
    "next": "15.2.4",
    "next-themes": "^0.4.4",
    "react": "^19",
    "react-day-picker": "9.8.0",
    "react-dom": "^19",
    "react-hook-form": "^7.54.1",
    "react-resizable-panels": "^2.1.7",
    "recharts": "2.15.0",
    "rehype": "^13.0.2",
    "rehype-katex": "^7.0.1",
    "rehype-parse": "^9.0.1",
    "rehype-raw": "^7.0.0",
    "rehype-sanitize": "^6.0.0",
    "rehype-stringify": "^10.0.1",
    "remark": "^15.0.1",
    "remark-gfm": "^4.0.1",
    "remark-html": "^16.0.1",
    "remark-math": "^6.0.0",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "unified": "^11.0.5",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@axe-core/react": "^4.10.2",
    "@eslint/js": "^9.35.0",
    "@next/bundle-analyzer": "^15.5.3",
    "@playwright/test": "^1.55.0",
    "@size-limit/file": "^11.2.0",
    "@testing-library/jest-dom": "^6.8.0",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^22",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@vitejs/plugin-react": "^5.0.2",
    "axe-core": "^4.10.3",
    "depcheck": "^1.4.7",
    "eslint": "^9.35.0",
    "eslint-plugin-jsx-a11y": "^6",
    "fast-check": "^4.3.0",
    "globals": "^16.4.0",
    "husky": "^9.1.7",
    "jest-axe": "^10.0.0",
    "jsdom": "^27.0.0",
    "knip": "^5",
    "lint-staged": "^16.1.6",
    "madge": "^6",
    "playwright": "^1.55.0",
    "postcss": "^8.5",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6",
    "size-limit": "^11.2.0",
    "tailwindcss": "^3.4.17",
    "ts-prune": "^0.10.3",
    "typescript": "^5",
    "typescript-eslint": "^8.44.0",
    "vitest": "^3.2.4",
    "vitest-axe": "^0.1.0"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  },
  "size-limit": [
    {
      "path": ".next/static/chunks/**/*.js",
      "limit": "500 KB"
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tsconfig.json
SIZE: 596 bytes | LINES: 28
================================================================================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "target": "ES6",
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: next.config.mjs
SIZE: 473 bytes | LINES: 22
================================================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: false,
  },
  typescript: {
    ignoreBuildErrors: false,
  },
  images: {
    unoptimized: true,
  },
  webpack: (config, { isServer }) => {
    if (process.env.ANALYZE === 'true') {
      const { BundleAnalyzerPlugin } = require('@next/bundle-analyzer')();
      config.plugins.push(new BundleAnalyzerPlugin());
    }
    return config;
  },
};

export default nextConfig;


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tailwind.config.ts
SIZE: 3,005 bytes | LINES: 102
================================================================================
import type { Config } from 'tailwindcss';

// all in fixtures is set to tailwind v3 as interims solutions

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    '*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        chart: {
          '1': 'hsl(var(--chart-1))',
          '2': 'hsl(var(--chart-2))',
          '3': 'hsl(var(--chart-3))',
          '4': 'hsl(var(--chart-4))',
          '5': 'hsl(var(--chart-5))',
        },
        sidebar: {
          DEFAULT: 'hsl(var(--sidebar-background))',
          foreground: 'hsl(var(--sidebar-foreground))',
          primary: 'hsl(var(--sidebar-primary))',
          'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
          accent: 'hsl(var(--sidebar-accent))',
          'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
          border: 'hsl(var(--sidebar-border))',
          ring: 'hsl(var(--sidebar-ring))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0',
          },
          to: {
            height: 'var(--radix-accordion-content-height)',
          },
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)',
          },
          to: {
            height: '0',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    require('tailwindcss-animate'),
  ],
};
export default config;


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: eslint.config.js
SIZE: 1,355 bytes | LINES: 59
================================================================================
import js from '@eslint/js';
import globals from 'globals';
import tseslint from 'typescript-eslint';
import jsxA11y from 'eslint-plugin-jsx-a11y';

export default tseslint.config(
  {
    ignores: [
      '**/node_modules/**',
      '**/dist/**',
      '**/.next/**',
      '**/coverage/**',
      '**/test-results/**',
      '**/playwright-report/**',
    ],
  },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2022,
      globals: {
        ...globals.browser,
        ...globals.node,
        ...globals.es2022,
      },
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-unused-vars': 'warn',
      'no-console': 'off',
      'prefer-const': 'warn',
      'no-var': 'error',
    },
  },
  ...tseslint.configs.recommended,
  {
    files: ['**/*.{ts,tsx}'],
    plugins: {
      'jsx-a11y': jsxA11y,
    },
    rules: {
      'no-unused-vars': 'off', // TypeScript handles this
      'no-console': 'off',
      'prefer-const': 'warn',
      'no-var': 'error',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/no-explicit-any': 'off', // Temporarily disable to fix build
      'jsx-a11y/anchor-is-valid': 'error',
    },
  },
);


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: vitest.config.ts
SIZE: 1,041 bytes | LINES: 51
================================================================================
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/coverage/**',
        '**/.next/**',
        '**/public/**',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80,
        },
        'lib/schema/': {
          branches: 90,
          functions: 90,
          lines: 90,
          statements: 90,
        },
        'components/': {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80,
        },
      },
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: playwright.config.ts
SIZE: 996 bytes | LINES: 43
================================================================================
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [['html'], ['json', { outputFile: 'test-results/results.json' }]],
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: CHANGELOG.md
SIZE: 9,115 bytes | LINES: 214
================================================================================
# Changelog

All notable changes to the MCQ Quiz Forge project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- **SecureTextRenderer Component**: New secure text renderer with complete XSS protection
- **Rich Markdown Support**: Headers, lists, tables, code blocks, images, links, blockquotes, horizontal rules
- **LaTeX Math Rendering**: Both inline and display math with KaTeX integration
- **Comprehensive Test Suite**: 41 comprehensive tests covering all features
- **Security Features**: Complete XSS protection with dangerous content sanitization
- **URL Validation**: Safe URL handling with protocol validation
- **Attribute Sanitization**: Removal of dangerous HTML attributes and event handlers
- **Content Detection**: Intelligent HTML vs markdown content detection
- **Error Handling**: Graceful handling of malformed content and LaTeX errors
- **Unicode Support**: Full support for special characters and emojis
- **Performance Optimization**: Lightweight regex-based processing for optimal speed
- **Consolidated Documentation**: Comprehensive testing guide with AI agent instructions
- **API Documentation**: Complete SecureTextRenderer API documentation and migration guide

### Changed

- **Text Rendering**: Migrated from basic TextRenderer to comprehensive SecureTextRenderer
- **Security Model**: Changed from escaping to removal of dangerous content
- **Markdown Processing**: Enhanced from basic support to comprehensive markdown features
- **LaTeX Integration**: Improved from basic support to full KaTeX integration
- **Test Coverage**: Increased from basic tests to comprehensive test suite
- **Documentation Structure**: Consolidated 14 documentation files into 4 focused files
- **Code Organization**: Removed 67+ redundant files and ~6,600 lines of duplicate content
- **Validation System**: Simplified to use only refactored validation implementation
- **Modal Components**: Consolidated confirmation modals to use Radix UI version

### Fixed

- **XSS Vulnerabilities**: Complete protection against cross-site scripting attacks
- **Content Sanitization**: Proper handling of dangerous HTML content
- **URL Security**: Prevention of malicious URL execution
- **LaTeX Rendering**: Proper math expression rendering with error handling
- **Markdown Parsing**: Correct handling of complex markdown syntax
- **Text Splitting**: Improved handling of line breaks and text formatting
- **Code Duplication**: Removed legacy validation files and duplicate components
- **Documentation Redundancy**: Eliminated duplicate documentation files
- **Test Artifacts**: Cleaned up 40+ test failure artifacts and debug files

### Removed

- **Redundant Documentation**: 7 outdated documentation files (~2,806 lines)
- **Test Artifacts**: 40+ test failure artifacts and screenshots
- **Debug Files**: 5 debug scripts and generated files
- **Legacy Code**: 5 duplicate/legacy files including old validation implementations
- **Empty Directories**: Removed empty styles directory and unused folders
- **Template Files**: Removed test result template and analysis files

### Security

- **XSS Protection**: Complete sanitization of script tags, event handlers, and dangerous attributes
- **URL Validation**: Rejection of javascript:, data:, and other dangerous protocols
- **Content Filtering**: Removal of iframe, form, and other dangerous HTML elements
- **Attribute Sanitization**: Stripping of onclick, onload, and other event handlers

## [1.0.0] - 2024-01-XX

### Added

- **Initial Release**: Basic MCQ quiz application with Next.js and TypeScript
- **Markdown Parser**: Resilient markdown parser for quiz content import
- **LaTeX Support**: Basic LaTeX rendering with KaTeX
- **Quiz Session**: Interactive quiz taking with navigation and progress tracking
- **Spaced Repetition System**: Basic SRS concepts for future enhancements
- **UI Components**: Dashboard, quiz interface, and navigation components
- **Data Validation**: Comprehensive validation and normalization system
- **Import/Export**: JSON and markdown file support
- **Responsive Design**: Mobile-first responsive design with Tailwind CSS

### Features

- **Dynamic Quiz Loading**: Quizzes loaded from JSON files
- **Interactive Sessions**: Question navigation, answer selection, and progress tracking
- **Markdown Import**: Convert markdown files to quiz modules
- **LaTeX Correction**: Automated LaTeX formatting error correction
- **Comprehensive UI**: Progress bars, completion screens, and toast notifications
- **Validation**: Data integrity and format validation
- **True/False Questions**: Support for T/F question type
- **Error Recovery**: Graceful handling of malformed content

## [0.9.0] - 2024-01-XX

### Added

- **Refactored Parser**: Enhanced markdown parser with better error handling
- **Block Content Parser**: Multi-line content parsing with code block support
- **Error Recovery**: Graceful handling of malformed questions
- **ID Uniqueness**: Enforcement of unique chapter and question IDs
- **LaTeX Correction**: Improved LaTeX correction utility
- **True/False Support**: Added T/F question type support
- **Backward Compatibility**: Maintained compatibility with existing formats

### Changed

- **Parser Architecture**: Improved parser structure and error handling
- **Content Processing**: Better handling of complex embedded content
- **Error Reporting**: More detailed error messages and line numbers
- **Validation**: Enhanced validation with duplicate ID detection

### Fixed

- **Code Block Parsing**: Fixed premature termination in code blocks
- **Error Handling**: Improved error recovery and continuation
- **ID Generation**: Better handling of missing and duplicate IDs
- **LaTeX Processing**: More conservative LaTeX correction patterns

## [0.8.0] - 2024-01-XX

### Added

- **Basic Markdown Support**: Headers, bold, italic, and basic formatting
- **LaTeX Integration**: Basic LaTeX math rendering
- **Quiz Interface**: Basic quiz taking functionality
- **Navigation**: Question navigation and progress tracking
- **Data Management**: JSON import/export functionality

### Changed

- **Component Structure**: Organized React components
- **State Management**: Improved state handling and data flow
- **UI Design**: Enhanced user interface with Tailwind CSS

### Fixed

- **Rendering Issues**: Fixed text rendering problems
- **Navigation Bugs**: Corrected navigation and progress tracking
- **Data Validation**: Improved data validation and error handling

## [0.7.0] - 2024-01-XX

### Added

- **Project Setup**: Initial Next.js project structure
- **TypeScript Configuration**: Type safety and development setup
- **Basic Components**: Initial React component structure
- **Tailwind CSS**: Utility-first CSS framework integration
- **Development Tools**: ESLint, Prettier, and development scripts

### Changed

- **Architecture**: Established project architecture and patterns
- **Code Organization**: Organized code structure and file organization
- **Development Workflow**: Set up development and build processes

## [0.6.0] - 2024-01-XX

### Added

- **Initial Concept**: Basic quiz application concept
- **Requirements**: Project requirements and specifications
- **Design**: Initial UI/UX design and wireframes
- **Technology Stack**: Technology selection and justification

---

## Legend

- **Added**: New features
- **Changed**: Changes in existing functionality
- **Deprecated**: Soon-to-be removed features
- **Removed**: Removed features
- **Fixed**: Bug fixes
- **Security**: Security improvements

## Version Format

- **Major**: Incompatible API changes
- **Minor**: New functionality in a backwards compatible manner
- **Patch**: Backwards compatible bug fixes

## Release Notes

### Security Updates

- **XSS Protection**: Complete protection against cross-site scripting
- **Content Sanitization**: Safe rendering of user-generated content
- **URL Validation**: Prevention of malicious URL execution
- **Attribute Filtering**: Removal of dangerous HTML attributes

### Performance Improvements

- **Rendering Speed**: Optimized text processing and rendering
- **Memory Usage**: Efficient memory management and cleanup
- **Bundle Size**: Optimized build output and code splitting
- **Load Time**: Faster initial load and content rendering

### Feature Enhancements

- **Markdown Support**: Comprehensive markdown syntax support
- **LaTeX Math**: Full LaTeX math rendering with KaTeX
- **Error Handling**: Graceful handling of malformed content
- **Unicode Support**: Full support for special characters and emojis

### Testing Improvements

- **Test Coverage**: Comprehensive test suite with 78% coverage
- **Security Testing**: Complete XSS protection testing
- **Edge Case Testing**: Testing of malformed content and edge cases
- **Performance Testing**: Rendering performance and memory usage testing

---

**MCQ Quiz Forge** - Secure, rich text rendering for educational applications! 🚀


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: README.md
SIZE: 41,085 bytes | LINES: 1,239
================================================================================
# MCQ Quiz Forge - Project README

This project implements a robust MCQ (Multiple Choice Question) quiz application using Next.js and TypeScript. It features a sophisticated Markdown parser for importing quiz content, a LaTeX correction utility, and a user-friendly interface for taking quizzes.

## Key Features

- **Dynamic Quiz Loading:** Quizzes are loaded from JSON files, which can be generated from Markdown.
- **Interactive Quiz Session:** Users can navigate questions, select answers, view explanations, and track their progress.
- **Markdown Importer:** A resilient Markdown parser converts specially formatted `.md` files into quiz modules. Supports Multiple-Choice (MCQ) and True/False (T/F) questions.
- **LaTeX Support:** Question and explanation text can include LaTeX, rendered using KaTeX.
- **Secure Text Rendering:** Advanced `SecureTextRenderer` component with complete XSS protection and rich markdown support.
- **LaTeX Correction Utility:** An automated tool to fix common LaTeX formatting errors in JSON content before parsing.
- **Spaced Repetition System (SRS) Concepts:** Basic SRS fields are included in the data model for future enhancements.
- **Comprehensive UI:** Includes components for question display, navigation, progress bars, completion screens, and toast notifications.
- **Validation & Normalization:** Ensures data integrity of quiz modules.

## 📚 Documentation

### Core Documentation

- **[SecureTextRenderer](docs/SecureTextRenderer.md)** - Complete API documentation and migration guide
- **[Testing Guide](docs/TESTING.md)** - Comprehensive testing documentation and AI agent instructions
- **[Changelog](CHANGELOG.md)** - Project history and version changes

### Quick Links

- **Getting Started**: Follow the installation and setup instructions below
- **Quiz Creation**: Use the [Markdown Quiz Format](#markdown-quiz-format-specification) to create quizzes
- **Import/Export**: Manage quiz data with the [Import/Export System](#importexport-system)
- **Customization**: Configure the application with [Customization Options](#customization)

## Refactoring Updates (June 2025)

The Markdown parser and related utilities have undergone a significant refactoring to enhance robustness, resilience, and data integrity for production readiness. Key improvements include:

- **Robust Block-Content Parser:**
  - A new internal helper function, `parseBlockContent`, has been implemented.
  - This function correctly handles multi-line content, including Markdown code blocks (e.g., \`\`\`python ... \`\`\`), ensuring that stoppers or special Markdown syntax within code blocks do not prematurely terminate content parsing.
  - This is now used for parsing question text, option text (for MCQs), and explanation text, making the parser resilient to complex embedded content.

- **Granular Error Handling and Recovery:**
  - Parsing for individual questions is now wrapped in `try...catch` blocks.
  - If a single question is malformed and causes a parsing error, a detailed error message (including the approximate line number) is logged.
  - A recovery mechanism (`recoverAndSkipToNextEntry`) attempts to advance the parser to the next valid question or chapter separator (`### Q:`, `### T/F:`, `## `, `---`), allowing the rest of the file to be processed.
  - This ensures that one bad question does not prevent the entire quiz module from being parsed.

- **Strict ID Uniqueness Enforcement:**
  - The parser now tracks all chapter IDs and question IDs encountered.
  - If a duplicate ID is found, a non-fatal `[Warning]` message is added to the error report. Parsing continues, but the user is alerted to potential data integrity issues.
  - If an ID is missing, a unique default ID is generated, and a warning is issued.

- **Hardened LaTeX Correction Utility:**
  - The `correctLatexInJsonContent` utility now uses a more conservative regular expression (`/"(?:[^"\\]|\\.)*(?:\${1,2})[^$]*?(?:\${1,2})(?:[^"\\]|\\.)*"/g`) to detect potential LaTeX content within JSON strings.
  - This pattern specifically targets strings that contain LaTeX math delimiters (`$...$` or `$$...$$`).
  - This change significantly reduces the risk of the utility incorrectly modifying valid non-LaTeX data (e.g., file paths, code snippets) that might have coincidentally contained backslashes or other LaTeX-like sequences. The trade-off is that LaTeX commands not enclosed in `$...$` or `$$...$$` within a JSON string value might not be automatically corrected by this specific utility.

- **Support for True/False Questions:**
  - The parser now supports a new True/False question type, identified by the `### T/F:` prefix.
  - These questions automatically generate "True" and "False" options and expect the correct answer to be specified as `True` or `False`.
  - T/F questions cannot have an `**Options:**` block.
  - The `QuizQuestion` type now includes an optional `type` field (`'mcq' | 'true_false'`), defaulting to `'mcq'` for backward compatibility.

- **Backward Compatibility:**
  - All refactoring changes, including the addition of T/F questions, have been implemented while maintaining backward compatibility with existing, valid Markdown quiz formats for MCQs. Features like alternate description formats (`_description_`), option prefixes (`**A1:**` vs. `- **A1:**`), and answer section headers (`**Correct:**` vs. `**Ans:**`) continue to be supported for MCQs.

These changes make the Markdown import process significantly more reliable, versatile, and suitable for production environments.

## Markdown Quiz Format Specification

The parser expects Markdown files to follow a specific structure:

\\`\`\`markdown

# Module Name

Description: Optional module description.
_Alternatively, descriptions can be like this._

---

## Chapter Name <!-- CH_ID: unique_chapter_id (Optional, but recommended) -->

Description: Optional chapter description.
_Or this format for chapter description._

---

### Q: This is an MCQ question. <!-- Q_ID: mcq_example_id -->

Question text can span multiple lines.

**Options:** (or **Opt:**)
**A1:** Option 1 text.

- **A2:** Option 2 text.

**Correct:** A1 (or **Ans:** A1)

**Exp:**
Explanation for the MCQ.

---

### T/F: This is a True/False question. <!-- Q_ID: tf_example_id -->

The earth is flat.

**Correct:** False (or **Ans:** False)

**Exp:**
The Earth is an oblate spheroid.

---

\\`\`\`

**Key Points:**

- **Module Header:** Starts with `# Module Name`. Description is optional. Separated by `---`.
- **Chapter Header:** Starts with `## Chapter Name`. Optional `<!-- CH_ID: your_id -->` comment for a stable ID. Description is optional. Separated by `---`.
- **Question Block (General):**
  - Optional `<!-- Q_ID: your_id -->` comment for a stable ID on the same line as the question header.
  - Question text can span multiple lines and include Markdown code blocks.
  - `**Correct:** {answer}` or `**Ans:** {answer}` section.
  - `**Exp:**` section for the explanation. Explanation text can be multi-line and include code blocks.
- **MCQ Specific (`### Q:`):**
  - Must have an `**Options:**` or `**Opt:**` section.
  - Options are prefixed with `**A{number}:**` (e.g., `**A1:**`) or `- **A{number}:**`. Option text can be multi-line and include code blocks.
  - Correct answer labels refer to the `A{number}` part (e.g., `A1, A3`).
- **True/False Specific (`### T/F:`):**
  - **Must NOT** have an `**Options:**` or `**Opt:**` section. Options are implicitly "True" and "False".
  - Correct answer must be the literal word `True` or `False` (case-insensitive).
- **Separators:** `---` can be used to visually separate questions, but is only strictly required after module and chapter headers.
- **IDs:** Providing explicit `CH_ID` and `Q_ID` in HTML comments is highly recommended for stable linking and data management. If missing, defaults will be generated. Duplicate IDs will now generate warnings.

## Project Structure (Illustrative)

- `app/`: Next.js App Router pages.
  - `page.tsx`: Main entry point for the quiz.
  - `test/page.tsx`: Page for testing parser or components.
- `components/`: React components.
  - `ui/`: Shadcn/ui components.
  - `quiz-session.tsx`: Core component for managing an active quiz.
  - `dashboard.tsx`: Displays chapter selection.
  - `text-renderer.tsx`: Legacy text renderer (being replaced by SecureTextRenderer).
- `secure-text-renderer.tsx`: Advanced secure text renderer with XSS protection and rich markdown support.
  - ... other UI components.
- `hooks/`: Custom React hooks (e.g., `use-toast.ts`).
- `lib/`: Utility functions (e.g., `utils.ts`).
- `public/`: Static assets, including `default-quiz.json`.
- `types/`: TypeScript type definitions (e.g., `quiz-types.ts`).
- `utils/`: Core utilities like `quiz-validation-refactored.ts` (contains the parser and validators).

## Getting Started

1.  Clone the repository.
2.  Install dependencies: \`npm install\`
3.  Run the development server: \`npm run dev\`
4.  Open your browser to \`http://localhost:3000\`.

The default quiz is loaded from \`public/default-quiz.json\`. You can create your own Markdown files and use a script or a UI feature (if implemented) to parse them into JSON format for the application.

## 🚀 Getting Started

### Prerequisites

- Node.js 18+
- npm, yarn, or pnpm

### Installation

1. **Clone the repository**
   \`\`\`bash
   git clone https://github.com/your-username/mcq-master.git
   cd mcq-master
   \`\`\`

2. **Install dependencies**
   \`\`\`bash
   npm install

   # or

   yarn install

   # or

   pnpm install
   \`\`\`

3. **Run the development server**
   \`\`\`bash
   npm run dev

   # or

   yarn dev

   # or

   pnpm dev
   \`\`\`

4. **Open your browser**
   Navigate to [http://localhost:3000](http://localhost:3000)

## 📋 Quiz Format Specifications

### JSON Format

The JSON format provides the most comprehensive feature support:

\`\`\`json
{
"name": "Quiz Module Name",
"description": "Optional module description",
"chapters": [
{
"id": "unique_chapter_id",
"name": "Chapter Name",
"description": "Optional chapter description",
"questions": [
{
"questionId": "unique_question_id",
"type": "mcq", // or "true_false"
"questionText": "Question text with **markdown** and $$LaTeX$$ support",
"options": [ // For MCQ; For T/F, this would be auto-generated
{
"optionId": "unique_option_id", // For T/F, "true" or "false"
"optionText": "Option text with formatting support" // For T/F, "True" or "False"
}
],
"correctOptionIds": ["option_id_1"], // For T/F, ["true"] or ["false"]
"explanationText": "Detailed explanation with formatting",
"status": "not_attempted",
"timesAnsweredCorrectly": 0,
"timesAnsweredIncorrectly": 0,
"historyOfIncorrectSelections": [],
"srsLevel": 0,
"nextReviewAt": null,
"shownIncorrectOptionIds": []
}
]
}
]
}
\`\`\`

### Markdown Format

The Markdown format offers a more human-readable alternative:

**MCQ Example:**
\`\`\`markdown

# Quiz Module Name

## _Optional module description_

## Chapter Name <!-- ID:chapter_id -->

## Description: Optional chapter description

### Q: What is the time complexity of binary search? <!-- ID:q1 -->

**Options:**
**A1:** O(n)
**A2:** O(log n)
**A3:** O(n²)

**Correct:** A2

## **Exp:** Binary search divides the search space in half with each comparison, resulting in O(log n) time complexity.

\`\`\`

**True/False Example:**
\`\`\`markdown

### T/F: The sun rises in the west. <!-- ID:tf_sun_q -->

**Correct:** False

## **Exp:** The sun rises in the east due to the Earth's rotation.

\`\`\`

#### Markdown Format Variations

**Compact Format (MCQ):**
\`\`\`markdown
**Opt:**

- **A1:** Option 1
- **A2:** Option 2

**Ans:** A1

**Exp:** Explanation text
\`\`\`

**ID Comments:**

- Same line: \`<!-- ID:question_id -->\`
- Separate line:
  \`\`\`markdown
  ### Q: Question text
  <!-- ID:question_id -->
  \`\`\`

## 🎯 Core Features Deep Dive

### SecureTextRenderer Component

The `SecureTextRenderer` is a comprehensive text rendering component that provides secure, rich text display with complete XSS protection:

#### **Security Features**

- **XSS Protection**: Complete sanitization of dangerous content including script tags, event handlers, and malicious URLs
- **URL Validation**: Rejects dangerous protocols (`javascript:`, `data:`, `vbscript:`) while allowing safe URLs
- **Attribute Sanitization**: Removes dangerous HTML attributes and event handlers
- **Content Detection**: Intelligently detects raw HTML vs markdown content for appropriate processing

#### **Rich Markdown Support**

- **Headers**: All levels (h1-h6) with proper HTML structure
- **Text Formatting**: Bold (`**text**`, `__text__`), italic (`*text*`, `_text_`), strikethrough (`~~text~~`)
- **Code**: Inline code (`` `code` ``) and code blocks (`code`)
- **Lists**: Unordered (`- item`), ordered (`1. item`), and task lists (`- [x] completed`)
- **Links & Images**: `[text](url)` and `![alt](url)` with URL validation
- **Tables**: Full table support with proper HTML structure (`<table>`, `<thead>`, `<tbody>`)
- **Blockquotes**: `> text` support with proper nesting
- **Horizontal Rules**: `---`, `***`, `___` support

#### **LaTeX Math Rendering**

- **Inline Math**: `$math$` renders as inline math with KaTeX
- **Display Math**: `$$math$$` renders as centered display math
- **Error Handling**: Malformed LaTeX gracefully handled with error styling
- **Performance**: Optimized for quiz applications with frequent content updates

#### **Advanced Features**

- **Mixed Content**: Safely handles combinations of markdown, LaTeX, and HTML
- **Unicode Support**: Full support for special characters and emojis
- **Error Recovery**: Graceful handling of malformed content
- **Performance**: Lightweight regex-based processing for optimal speed

#### **Usage Example**

```tsx
import { SecureTextRenderer } from '@/components/secure-text-renderer'

const content = `
# Quiz Question

This is a **bold** question with *italic* text and $E = mc^2$ math.

## Code Example
\`\`\`javascript
function hello() {
  console.log("Hello, World!");
}
\`\`\`

## Task List
- [x] Completed task
- [ ] Incomplete task
`

<SecureTextRenderer content={content} className="my-custom-class" />
```

### Spaced Repetition System (SRS)

MCQ Master implements a sophisticated three-level SRS system:

#### **Level 0: New/Lapsing**

- **Status**: New questions or questions answered incorrectly
- **Scheduling**: 30-second quick retry for immediate reinforcement
- **Purpose**: Initial learning and immediate error correction

#### **Level 1: Learning**

- **Status**: Questions answered correctly once
- **Scheduling**: 10-minute review interval
- **Purpose**: Short-term retention verification

#### **Level 2: Mastered**

- **Status**: Questions answered correctly twice consecutively
- **Scheduling**: No further reviews (removed from queue)
- **Purpose**: Long-term retention achieved

#### **Smart Scheduling Features**

- **Recent Failure Priority**: Questions failed recently get slight priority
- **Dynamic Queue**: Review queue updates in real-time
- **Progress Visualization**: Anki-style progress bars show learning pipeline

### Question Editor

The built-in question editor provides comprehensive authoring capabilities:

#### **Live Preview**

- **Real-time Rendering**: See exactly how questions will appear
- **LaTeX Support**: Live preview of mathematical expressions
- **Markdown Rendering**: Rich text formatting preview
- **Option Validation**: Immediate feedback on option configuration

#### **Rich Text Support**

- **LaTeX Math**: Inline (\`$...$\`) and display (\`$$...$$\`) math
- **HTML Tags**: Support for \`<b>\`, \`<i>\`, \`<code>\`, etc.
- **Markdown**: Standard markdown formatting
- **Code Blocks**: Syntax highlighting for code examples

#### **Validation System**

- **Required Fields**: Ensures all necessary fields are completed
- **Option Validation**: Checks for valid option IDs and text
- **Correct Answer Validation**: Verifies correct answers reference valid options
- **Duplicate Detection**: Prevents duplicate option IDs

### Session History Navigation

Navigate through your quiz session with advanced history features:

#### **Historical View**

- **Answer Review**: Review previous answers within the session
- **Context Preservation**: See exactly what options were displayed
- **Performance Tracking**: View correct/incorrect status for each answer
- **Navigation Controls**: Previous/Next buttons for easy browsing

#### **Live vs Historical**

- **Live Questions**: Current unanswered questions
- **Historical Answers**: Previously answered questions in the session
- **Seamless Transition**: Switch between live and historical views
- **State Preservation**: Maintains context when switching views

### Import/Export System

Comprehensive data management capabilities:

#### **Quiz Module Management**

- **Full Export**: Complete quiz state with all progress data
- **Import with Validation**: Automatic validation and error reporting
- **LaTeX Correction**: Automatic fixing of common LaTeX issues
- **Progress Preservation**: Maintains learning progress across imports

#### **Question-Level Operations**

- **Individual Export**: Export single questions for sharing
- **Batch Import**: Import multiple questions with conflict resolution
- **Overwrite Protection**: Confirmation dialogs for destructive operations
- **Append Mode**: Add new questions without affecting existing ones

#### **Mistake Analysis**

- **Detailed Logs**: Export comprehensive incorrect answer history
- **Performance Metrics**: Include attempt counts and SRS levels
- **Chapter Context**: Maintain chapter and question relationships
- **Timestamp Tracking**: Record when mistakes were made

## 🎨 User Interface Features

### Dashboard

The main dashboard provides a comprehensive overview:

#### **Module Information**

- **Title and Description**: Clear module identification
- **Chapter Overview**: Grid layout of all chapters
- **Progress Indicators**: Visual progress bars for each chapter
- **Completion Status**: Clear indication of completed chapters

#### **Chapter Cards**

- **Progress Visualization**: Circular progress indicators
- **Statistics Display**: Questions answered, correct answers, accuracy
- **Status Badges**: Visual indicators for completion status
- **Quick Actions**: Start quiz or continue from last position

#### **Review System**

- **Review Queue Counter**: Number of questions due for review
- **Start Review Button**: One-click access to review sessions
- **SRS Statistics**: Overview of learning pipeline status

### Quiz Interface

The quiz interface is optimized for learning:

#### **Question Display**

- **Clean Layout**: Distraction-free question presentation
- **Rich Text Rendering**: Full support for LaTeX, HTML, and Markdown
- **Responsive Design**: Adapts to different screen sizes
- **Accessibility**: Keyboard navigation and screen reader support

#### **Option Selection**

- **Visual Feedback**: Clear indication of selected options
- **Hover Effects**: Interactive feedback for better UX
- **Keyboard Support**: Arrow keys and Enter for selection
- **Touch Friendly**: Optimized for mobile devices

#### **Answer Feedback**

- **Immediate Feedback**: Instant indication of correct/incorrect
- **Explanation Display**: Detailed explanations with rich formatting
- **Progress Indication**: Show position within chapter
- **Navigation Controls**: Easy movement between questions

### Question Navigation Menu

Advanced navigation system for quiz sessions:

#### **Visual Progress Map**

- **Question Grid**: Visual representation of all questions
- **Status Indicators**: Color-coded status for each question
- **Current Position**: Clear indication of current question
- **Click Navigation**: Direct navigation to any question

#### **Status Legend**

- **Not Attempted**: Questions not yet answered
- **Correct**: Questions answered correctly
- **Incorrect**: Questions answered incorrectly
- **Current**: Currently active question

#### **Session History Integration**

- **Historical Markers**: Show questions answered in current session
- **Live vs Historical**: Visual distinction between modes
- **Context Switching**: Easy switching between live and historical views

## 🔧 Technical Features

### LaTeX Support

Comprehensive mathematical expression support:

#### **Inline Math**

- **Syntax**: \`$expression$\`
- **Example**: \`$E = mc^2$\` renders as inline math
- **Use Cases**: Mathematical variables, simple expressions

#### **Display Math**

- **Syntax**: \`$$expression$$\`
- **Example**: \`$$\\sum_{i=1}^{n} i^2 = \\frac{n(n+1)(2n+1)}{6}$$\`
- **Use Cases**: Complex equations, formulas, proofs

#### **Supported Commands**

- **Greek Letters**: \`\\alpha\`, \`\\beta\`, \`\\gamma\`, etc.
- **Operators**: \`\\sum\`, \`\\int\`, \`\\prod\`, \`\\lim\`, etc.
- **Relations**: \`\\leq\`, \`\\geq\`, \`\\neq\`, \`\\approx\`, etc.
- **Functions**: \`\\sin\`, \`\\cos\`, \`\\log\`, \`\\ln\`, etc.
- **Structures**: \`\\frac{}{}\`, \`\\sqrt{}\`, \`\\binom{}{}\`, etc.

### Markdown Support

Rich text formatting capabilities:

#### **Basic Formatting**

- **Bold**: \`**text**\` or \`**text**\`
- **Italic**: \`_text_\` or \`_text_\`
- **Code**: \`\`code\`\` for inline code
- **Links**: \`[text](url)\` for hyperlinks

#### **Advanced Features**

- **Code Blocks**: Syntax highlighting for multiple languages
- **Lists**: Ordered and unordered lists
- **Tables**: Full table support with alignment
- **Blockquotes**: \`> quoted text\`

### HTML Support

Direct HTML integration for advanced formatting:

#### **Supported Tags**

- **Text Formatting**: \`<b>\`, \`<i>\`, \`<u>\`, \`<s>\`
- **Code**: \`<code>\` for inline code snippets
- **Structure**: \`<div>\`, \`<span>\`, \`<p>\`
- **Lists**: \`<ul>\`, \`<ol>\`, \`<li>\`

#### **Styling**

- **CSS Classes**: Support for Tailwind CSS classes
- **Inline Styles**: Direct style attribute support
- **Responsive**: Automatic responsive behavior

### Data Validation

Comprehensive validation system:

#### **JSON Validation**

- **Schema Validation**: Strict adherence to quiz module schema
- **Type Checking**: Ensures correct data types for all fields
- **Relationship Validation**: Verifies option IDs match correct answers
- **Completeness Checks**: Ensures all required fields are present

#### **Markdown Validation**

- **Structure Validation**: Checks for proper markdown structure
- **Content Validation**: Ensures all required sections are present
- **ID Validation**: Verifies unique IDs across questions and chapters
- **Format Compliance**: Checks adherence to supported formats

#### **LaTeX Correction**

- **Automatic Fixing**: Corrects common LaTeX formatting errors
- **Command Recognition**: Identifies and fixes LaTeX commands
- **Escape Sequence Handling**: Proper handling of backslashes
- **Error Reporting**: Detailed reports of corrections made

## 📱 Responsive Design

### Mobile Optimization

#### **Touch Interface**

- **Large Touch Targets**: Optimized button and option sizes
- **Gesture Support**: Swipe navigation where appropriate
- **Viewport Optimization**: Proper scaling and zoom behavior
- **Orientation Support**: Works in both portrait and landscape

#### **Layout Adaptation**

- **Flexible Grids**: Responsive grid layouts for different screen sizes
- **Collapsible Sections**: Expandable sections for better mobile UX
- **Optimized Typography**: Readable text sizes across devices
- **Efficient Scrolling**: Smooth scrolling with proper momentum

### Desktop Features

#### **Keyboard Navigation**

- **Tab Navigation**: Full keyboard accessibility
- **Shortcut Keys**: Ctrl+Enter to submit, Escape to cancel
- **Arrow Key Support**: Navigate between options
- **Focus Management**: Proper focus indication and management

#### **Advanced Interactions**

- **Hover Effects**: Rich hover states for better feedback
- **Context Menus**: Right-click context menus where appropriate
- **Drag and Drop**: File upload via drag and drop
- **Multi-window Support**: Proper behavior across multiple windows

## 🔒 Data Management

### Local Storage

#### **Automatic Saving**

- **Progress Persistence**: Automatic saving of quiz progress
- **Session Recovery**: Recover interrupted sessions
- **Settings Storage**: User preferences and settings
- **Cache Management**: Efficient caching of quiz data

#### **Data Security**

- **Local Only**: All data stored locally in browser
- **No Server Dependency**: Fully client-side application
- **Privacy Focused**: No data transmission to external servers
- **User Control**: Complete user control over data

### Import/Export Workflows

#### **File Format Support**

- **JSON Files**: Native format with full feature support
- **Markdown Files**: Human-readable format support
- **Automatic Detection**: Automatic format detection
- **Error Handling**: Graceful handling of invalid files

#### **Conflict Resolution**

- **Overwrite Protection**: Confirmation for destructive operations
- **Merge Options**: Smart merging of imported data
- **Backup Creation**: Automatic backups before imports
- **Rollback Support**: Ability to undo imports

## 🎓 Educational Features

### Learning Analytics

#### **Performance Tracking**

- **Accuracy Metrics**: Track accuracy over time
- **Attempt History**: Complete history of all attempts
- **Time Tracking**: Monitor time spent on questions
- **Difficulty Analysis**: Identify challenging topics

#### **Progress Visualization**

- **Progress Bars**: Visual progress indicators
- **Achievement Badges**: Milestone achievements
- **Streak Tracking**: Consecutive correct answers
- **Improvement Trends**: Visual trend analysis

### Study Modes

#### **Regular Quiz Mode**

- **Linear Progression**: Traditional question-by-question progression
- **Chapter-Based**: Organized by chapters and topics
- **Progress Tracking**: Comprehensive progress monitoring
- **Flexible Navigation**: Jump to any question within chapter

#### **Review Mode**

- **SRS-Based**: Spaced repetition scheduling
- **Priority Queue**: Most urgent questions first
- **Adaptive Scheduling**: Adjusts based on performance
- **Mastery Tracking**: Clear mastery progression

#### **Practice Mode**

- **Mistake Review**: Focus on previously incorrect answers
- **Weak Areas**: Target areas needing improvement
- **Custom Filters**: Filter by difficulty or topic
- **Unlimited Attempts**: No penalty for multiple attempts

## 🛠️ Development Features

### Code Quality

#### **TypeScript**

- **Full Type Safety**: Comprehensive type definitions
- **Interface Definitions**: Clear data structure definitions
- **Generic Types**: Reusable type definitions
- **Strict Mode**: Strict TypeScript configuration

#### **Code Organization**

- **Component Architecture**: Modular React components
- **Custom Hooks**: Reusable logic in custom hooks
- **Utility Functions**: Shared utility functions
- **Type Definitions**: Centralized type definitions

### Testing

#### **Built-in Tests**

- **Parser Testing**: Comprehensive markdown parser tests
- **Validation Testing**: Data validation test suites
- **Component Testing**: React component test coverage
- **Integration Testing**: End-to-end workflow testing

#### **Test Navigation**

- **Test Page**: Dedicated test page at \`/test\`
- **Interactive Testing**: Run tests directly in browser
- **Result Visualization**: Clear test result display
- **Debug Information**: Detailed debug output

## 🧪 Testing & CI

### Testing Framework

#### **Unit Testing**

- **Vitest**: Fast unit testing framework with Vite integration
- **@testing-library/react**: React component testing utilities
- **Coverage**: 90% coverage required for parser modules, 80% for components
- **Watch Mode**: Real-time test execution during development

#### **Integration Testing**

- **Component Integration**: Test component interactions and state management
- **Rendering Tests**: Verify component rendering with different props
- **State Management**: Test complex state transitions and data flow

#### **End-to-End Testing**

- **Playwright**: Cross-browser E2E testing with built-in browser automation
- **User Flows**: Complete user journey testing across the application
- **Cross-browser**: Chrome, Firefox, Safari, Mobile Chrome, Mobile Safari
- **Visual Testing**: Screenshot comparison and visual regression testing

#### **Accessibility Testing**

- **axe-core**: Automated accessibility testing with WCAG compliance
- **Keyboard Navigation**: Focus management and tab order testing
- **Screen Reader**: ARIA labels and landmarks validation
- **Color Contrast**: Automated contrast ratio verification

### Test Structure

#### **Test Organization**

```
tests/
├── unit/           # Unit tests for individual functions and components
├── int/            # Integration tests for component interactions
├── e2e/            # End-to-end tests for complete user flows
├── access/         # Accessibility tests for WCAG compliance
├── fixtures/       # Test data and mock files
└── setup.ts        # Test configuration and setup
```

#### **Test Fixtures**

- **Markdown Parser Tests**: Comprehensive test cases for markdown parsing
- **LaTeX Rendering Tests**: Math expression rendering validation
- **Validation Tests**: Schema validation and error handling
- **Edge Cases**: Boundary conditions and error scenarios

### Continuous Integration

#### **CI Pipeline**

1. **TypeScript Type Check**: Compile-time type validation
2. **ESLint**: Code quality and style enforcement
3. **Unit Tests**: Fast, isolated component and function tests
4. **Integration Tests**: Component interaction and state management
5. **Accessibility Tests**: WCAG compliance and screen reader support
6. **E2E Tests**: Cross-browser user journey validation
7. **Build**: Production build verification
8. **Coverage Check**: Coverage threshold enforcement
9. **Dependency Check**: Unused dependency and export analysis
10. **Bundle Analysis**: Size monitoring and optimization insights

#### **Coverage Thresholds**

- **Parser modules** (`lib/schema/`): 90% coverage required
- **Components**: 80% coverage required
- **Global**: 80% coverage required

#### **Quality Gates**

- **Type Safety**: All TypeScript errors must be resolved
- **Linting**: All ESLint warnings must be addressed
- **Test Coverage**: Coverage thresholds must be met
- **Accessibility**: No accessibility violations allowed
- **Build Success**: Production build must complete successfully

### Running Tests

#### **Local Development**

```bash
# Run all tests
npm run test

# Run specific test suites
npm run test:unit          # Unit tests
npm run test:int           # Integration tests
npm run test:e2e           # End-to-end tests
npm run test:access        # Accessibility tests

# Run tests in watch mode
npm run test:unit:watch

# Generate coverage report
npm run coverage
```

#### **CI Checks**

```bash
# Type checking
npm run typecheck

# Linting
npm run lint

# Dependency analysis
npm run depcheck

# Bundle analysis
npm run analyze
```

### Pre-commit Hooks

#### **Automated Quality Checks**

- **Lint-staged**: Runs ESLint and Prettier on staged files
- **Type Checking**: Ensures TypeScript compilation success
- **Test Execution**: Runs relevant tests for changed files
- **Formatting**: Automatically formats code before commit

#### **Git Hooks**

- **pre-commit**: Runs lint-staged before commit
- **prepare**: Installs husky hooks automatically

### Test Data Management

#### **Fixtures**

- **Realistic Data**: Test fixtures based on actual usage patterns
- **Edge Cases**: Boundary conditions and error scenarios
- **Performance Data**: Large datasets for performance testing
- **Accessibility Data**: Content with various accessibility requirements

#### **Mock Data**

- **API Responses**: Mock API responses for testing
- **User Interactions**: Simulated user behavior patterns
- **Error States**: Various error conditions and recovery
- **Loading States**: Different loading and async scenarios

### Performance Testing

#### **Bundle Analysis**

- **Size Monitoring**: Track bundle size changes over time
- **Dependency Analysis**: Identify unused dependencies
- **Code Splitting**: Verify optimal code splitting
- **Tree Shaking**: Ensure dead code elimination

#### **Runtime Performance**

- **Component Rendering**: Measure component render times
- **Memory Usage**: Monitor memory consumption patterns
- **User Interactions**: Test responsiveness of user interactions
- **Large Datasets**: Performance with large quiz modules

### Performance

#### **Optimization**

- **Code Splitting**: Automatic code splitting
- **Lazy Loading**: Lazy loading of components
- **Memoization**: React.memo and useMemo optimization
- **Bundle Optimization**: Optimized build output

#### **Caching**

- **Component Caching**: Efficient component re-rendering
- **Data Caching**: Smart data caching strategies
- **Asset Caching**: Optimized asset loading
- **Memory Management**: Efficient memory usage

## 🎨 Customization

### Theming

#### **Dark Theme**

- **Gradient Backgrounds**: Beautiful gradient backgrounds
- **Color Consistency**: Consistent color scheme throughout
- **Contrast Optimization**: High contrast for readability
- **Eye Strain Reduction**: Optimized for extended use

#### **Component Styling**

- **Tailwind CSS**: Utility-first CSS framework
- **Custom Components**: Styled component library
- **Responsive Utilities**: Mobile-first responsive design
- **Animation Support**: Smooth animations and transitions

### Configuration

#### **Quiz Settings**

- **SRS Configuration**: Customizable SRS intervals
- **Display Options**: Configurable display preferences
- **Navigation Settings**: Customizable navigation behavior
- **Accessibility Options**: Accessibility preference settings

#### **Editor Settings**

- **Preview Mode**: Toggle live preview
- **Validation Level**: Configurable validation strictness
- **Auto-save**: Automatic saving preferences
- **Keyboard Shortcuts**: Customizable keyboard shortcuts

## 📚 Usage Examples

### Creating a Quiz Module

#### **JSON Format Example**

\`\`\`json
{
"name": "Computer Science Fundamentals",
"description": "Basic concepts in computer science",
"chapters": [
{
"id": "algorithms",
"name": "Algorithm Analysis",
"description": "Big O notation and complexity analysis",
"questions": [
{
"questionId": "big_o_1",
"type": "mcq",
"questionText": "What is the time complexity of binary search?",
"options": [
{ "optionId": "big_o_1_a", "optionText": "O(n)" },
{ "optionId": "big_o_1_b", "optionText": "O(log n)" },
{ "optionId": "big_o_1_c", "optionText": "O(n²)" }
],
"correctOptionIds": ["big_o_1_b"],
"explanationText": "Binary search divides the search space in half with each comparison, resulting in O(log n) time complexity."
},
{
"questionId": "tf_stability_1",
"type": "true_false",
"questionText": "A stable sorting algorithm maintains the relative order of equal elements.",
"options": [
{ "optionId": "true", "optionText": "True" },
{ "optionId": "false", "optionText": "False" }
],
"correctOptionIds": ["true"],
"explanationText": "Stability is a key property where items with identical keys appear in the same order in the output as they did in the input."
}
]
}
]
}
\`\`\`

#### **Markdown Format Example**

\`\`\`markdown

# Computer Science Fundamentals

## _Basic concepts in computer science_

## Algorithm Analysis <!-- ID:algorithms -->

## Description: Big O notation and complexity analysis

### Q: What is the time complexity of binary search? <!-- ID:big_o_1 -->

**Options:**
**A1:** O(n)
**A2:** O(log n)
**A3:** O(n²)

**Correct:** A2

## **Exp:** Binary search divides the search space in half with each comparison, resulting in O(log n) time complexity.

### T/F: A stable sorting algorithm maintains the relative order of equal elements. <!-- ID:tf_stability_1 -->

**Correct:** True

## **Exp:** Stability is a key property where items with identical keys appear in the same order in the output as they did in the input.

\`\`\`

### Advanced LaTeX Examples

#### **Mathematical Expressions**

\`\`\`markdown

### Q: What is the sum formula for the first n natural numbers?

**Options:**
**A1:** $$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$
**A2:** $$\\sum_{i=1}^{n} i = n^2$$
**A3:** $$\\sum_{i=1}^{n} i = \\frac{n^2(n+1)^2}{4}$$

**Correct:** A1

**Exp:** The sum of the first n natural numbers is given by the formula $$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$, which can be proven by mathematical induction.
\`\`\`

#### **Complex Equations**

\`\`\`markdown

### Q: What is the quadratic formula?

**Exp:** For a quadratic equation $ax^2 + bx + c = 0$, the solutions are:
$$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$

The discriminant $\\Delta = b^2 - 4ac$ determines the nature of the roots:

- If $\\Delta > 0$: Two distinct real roots
- If $\\Delta = 0$: One repeated real root
- If $\\Delta < 0$: Two complex conjugate roots
  \`\`\`

### Code Examples in Questions

#### **Programming Questions**

\`\`\`markdown

### Q: What is the output of this Python code?

\`\`\`python
def fibonacci(n):
if n <= 1:
return n
return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))
\`\`\`

**Options:**
**A1:** 5
**A2:** 8
**A3:** 13

**Correct:** A2

**Exp:** The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, ...
So fibonacci(5) = 5 (the 5th Fibonacci number, 0-indexed).
\`\`\`

## 🔧 Troubleshooting

### Common Issues

#### **LaTeX Rendering Problems**

- **Issue**: LaTeX not rendering properly
- **Solution**: Check for proper escaping of backslashes in JSON
- **Auto-fix**: Use the built-in LaTeX correction feature

#### **Import Failures**

- **Issue**: Quiz file won't import
- **Solution**: Validate file format and check error messages
- **Debug**: Use the test page to validate markdown parsing

#### **Performance Issues**

- **Issue**: Slow loading or rendering
- **Solution**: Check for very large quiz files or complex LaTeX
- **Optimization**: Break large quizzes into smaller chapters

### File Format Issues

#### **JSON Validation Errors**

- **Missing Fields**: Ensure all required fields are present
- **Type Errors**: Check that field types match expected types
- **ID Conflicts**: Ensure all IDs are unique within their scope
- **Reference Errors**: Verify that correctOptionIds reference valid options

#### **Markdown Parsing Errors**

- **Structure Issues**: Check for proper heading hierarchy
- **Missing Sections**: Ensure all required sections are present
- **ID Format**: Verify ID comments are properly formatted
- **Option Format**: Check option formatting matches expected patterns

## 🤝 Contributing

### Development Setup

1. **Fork the repository**
2. **Create a feature branch**
   \`\`\`bash
   git checkout -b feature/amazing-feature
   \`\`\`
3. **Make your changes**
4. **Test thoroughly**
5. **Commit your changes**
   \`\`\`bash
   git commit -m 'Add amazing feature'
   \`\`\`
6. **Push to the branch**
   \`\`\`bash
   git push origin feature/amazing-feature
   \`\`\`
7. **Open a Pull Request**

### Code Style

- **TypeScript**: Use strict TypeScript with proper typing
- **React**: Follow React best practices and hooks patterns
- **Tailwind**: Use Tailwind CSS for styling
- **ESLint**: Follow the project's ESLint configuration
- **Prettier**: Use Prettier for code formatting

### Testing

- **Unit Tests**: Write unit tests for new functionality
- **Integration Tests**: Test component interactions
- **Manual Testing**: Test across different browsers and devices
- **Accessibility**: Ensure accessibility compliance

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **Next.js**: React framework for production
- **Tailwind CSS**: Utility-first CSS framework
- **Lucide React**: Beautiful icon library
- **KaTeX**: Fast math typesetting library
- **React**: JavaScript library for building user interfaces

## 📚 Documentation

### Core Documentation

- **[SecureTextRenderer Guide](docs/SecureTextRenderer.md)**: Complete component documentation
- **[API Reference](docs/API.md)**: Detailed API documentation
- **[Migration Guide](docs/MIGRATION.md)**: Migrating from TextRenderer to SecureTextRenderer
- **[Testing Guide](docs/TESTING.md)**: Comprehensive testing documentation

### Development Resources

- **[Progress Documentation](PROGRESS.md)**: Development progress and learnings
- **[Changelog](CHANGELOG.md)**: Version history and changes
- **[Documentation Index](docs/README.md)**: Complete documentation overview

## 📞 Support

For support, questions, or feature requests:

1. **GitHub Issues**: Open an issue on GitHub
2. **Documentation**: Check the comprehensive documentation above
3. **Test Page**: Use the built-in test page for debugging
4. **Community**: Join discussions in GitHub Discussions

---

**MCQ Master** - Transform your learning with interactive quizzes and spaced repetition! 🚀


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: app\globals.css
SIZE: 15,626 bytes | LINES: 810
================================================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom styles for better dark theme experience */
body {
  background-color: #000000;
  color: #f9fafb;
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}

/* Improved text handling */
.break-words {
  word-wrap: break-word;
  overflow-wrap: break-word;
  word-break: break-word;
}

.hyphens-auto {
  hyphens: auto;
}

/* Line clamping utility */
.line-clamp-3 {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Tabular numbers for consistent number alignment */
.tabular-nums {
  font-variant-numeric: tabular-nums;
}

/* Enhanced code block styling for proper indentation and dark theme */
pre {
  background-color: #1f2937 !important;
  border: 1px solid #374151;
  border-radius: 0.5rem;
  padding: 1rem;
  margin: 1rem 0;
  overflow-x: auto;
  white-space: pre;
  font-family: 'Fira Code', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Consolas', monospace;
  font-size: 0.875rem;
  line-height: 1.5;
  color: #f9fafb;
  box-shadow:
    0 1px 3px 0 rgba(0, 0, 0, 0.12),
    0 1px 2px -1px rgba(0, 0, 0, 0.1);
  position: relative;
}

pre code {
  background: none !important;
  border: none !important;
  padding: 0 !important;
  margin: 0 !important;
  font-size: inherit;
  color: inherit;
  white-space: pre;
  word-wrap: normal;
  overflow-wrap: normal;
  word-break: normal;
  font-family: inherit;
}

/* Inline code styling (different from pre code) */
:not(pre) > code {
  background-color: #374151 !important;
  color: #f9fafb !important;
  padding: 0.125rem 0.375rem !important;
  border-radius: 0.25rem !important;
  font-size: 0.875rem !important;
  font-family:
    'Fira Code', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Consolas', monospace !important;
  border: 1px solid #4b5563 !important;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Custom syntax highlighting classes */
.code-keyword {
  color: #569cd6;
  font-weight: 600;
}

.code-comment {
  color: #6a9955;
  font-style: italic;
}

.code-string {
  color: #ce9178;
}

.code-number {
  color: #b5cea8;
}

.code-class-name {
  color: #4ec9b0;
  font-weight: 500;
}

.code-function {
  color: #dcdcaa;
  font-weight: 500;
}

.code-operator {
  color: #d4d4d4;
}

.code-punctuation {
  color: #d4d4d4;
}

.code-variable {
  color: #9cdcfe;
}

.code-type {
  color: #4ec9b0;
}

/* Language-specific styling */
.language-java,
.language-pseudocode {
  position: relative;
}
.language-javascript,
.language-python {
  position: relative;
}

/* Enhanced KaTeX styling for dark theme - Fixed \neq rendering */
.katex {
  color: #f9fafb;
  font-size: 1.1em;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.katex * {
  color: #f9fafb;
}

.katex .base {
  color: #f9fafb;
}

.katex .mord,
.katex .mrel,
.katex .mbin,
.katex .mop,
.katex .mopen,
.katex .mclose,
.katex .mpunct,
.katex .minner {
  color: #f9fafb;
}

/* Specific fix for \neq and other relation symbols */
.katex .mrel {
  color: #f9fafb !important;
}

.katex-display {
  margin: 1.5rem 0;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 0.5rem 0;
  text-align: center;
}

.katex-display .katex {
  display: inline-block;
  text-align: center;
}

.katex-inline {
  padding: 0 0.15em;
}

/* Ensure proper scrolling for long code lines */
pre::-webkit-scrollbar {
  height: 8px;
}

pre::-webkit-scrollbar-track {
  background: #374151;
  border-radius: 4px;
}

pre::-webkit-scrollbar-thumb {
  background: #6b7280;
  border-radius: 4px;
}

pre::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}

/* Enhanced Markdown styling */
.prose strong {
  color: #f9fafb;
  font-weight: 700;
}

.prose em {
  color: #f9fafb;
  font-style: italic;
}

.prose ul {
  list-style-type: disc;
  margin-left: 1.5rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

.prose ol {
  list-style-type: decimal;
  margin-left: 1.5rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

.prose li {
  margin-bottom: 0.25rem;
  color: #f9fafb;
}

/* Enhanced interactive element feedback */
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 200ms;
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
  /* Disable all animations and transitions */
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }

  /* Specifically target Tailwind animation classes */
  .animate-bounce,
  .animate-pulse,
  .animate-ping,
  .animate-spin {
    animation: none !important;
  }

  /* Disable hover scale animations */
  .hover\:scale-105:hover {
    transform: none !important;
  }

  .hover\:scale-110:hover {
    transform: none !important;
  }

  .active\:scale-95:active {
    transform: none !important;
  }

  .active\:scale-\[0\.99\]:active {
    transform: none !important;
  }

  /* Disable transform transitions */
  .transition-transform {
    transition: none !important;
  }

  /* Keep color transitions for better UX */
  .transition-colors {
    transition-duration: 0.01ms !important;
  }

  /* Disable motion-based transitions but keep essential ones */
  .transition-all {
    transition-property:
      color, background-color, border-color, text-decoration-color, fill, stroke !important;
    transition-duration: 0.01ms !important;
  }

  /* Disable duration-based transitions */
  .duration-75,
  .duration-100,
  .duration-150,
  .duration-200,
  .duration-300,
  .duration-500,
  .duration-700,
  .duration-1000 {
    transition-duration: 0.01ms !important;
  }
}

/* Custom scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #1f2937;
}

::-webkit-scrollbar-thumb {
  background: #4b5563;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #6b7280;
}

/* Enhanced focus styles for accessibility */
button:focus-visible,
[role='button']:focus-visible {
  @apply outline-none ring-2 ring-blue-500 ring-offset-2 ring-offset-gray-900;
}

/* Enhanced button states */
button:active {
  transform: scale(0.98);
}

button:disabled {
  transform: none;
  cursor: not-allowed;
}

/* Card and container shadows - enhanced for depth */
.shadow-xl {
  box-shadow:
    0 10px 15px -3px rgba(0, 0, 0, 0.3),
    0 4px 6px -2px rgba(0, 0, 0, 0.2);
}

.shadow-lg {
  box-shadow:
    0 8px 12px -2px rgba(0, 0, 0, 0.25),
    0 3px 5px -3px rgba(0, 0, 0, 0.15);
}

.shadow-md {
  box-shadow:
    0 4px 6px -1px rgba(0, 0, 0, 0.2),
    0 2px 4px -1px rgba(0, 0, 0, 0.12);
}

.shadow-sm {
  box-shadow:
    0 1px 3px 0 rgba(0, 0, 0, 0.12),
    0 1px 2px -1px rgba(0, 0, 0, 0.1);
}

/* Improved responsive grid for chapters */
.auto-rows-fr {
  grid-auto-rows: 1fr;
}

/* Prose styling for better text rendering */
.prose {
  max-width: none;
}

.prose p {
  margin-bottom: 1rem;
  line-height: 1.7;
  color: #f9fafb;
}

.prose code {
  @apply rounded border border-gray-700/50 bg-gray-800 px-1.5 py-0.5 font-mono text-sm text-gray-100;
}

.prose pre {
  @apply overflow-x-auto rounded border border-gray-700/50 bg-gray-800 p-4 text-gray-100;
}

/* Ensure proper text wrapping in all contexts */
* {
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Prevent layout shift with consistent spacing */
.space-y-3 > * + * {
  margin-top: 0.75rem;
}

.space-y-4 > * + * {
  margin-top: 1rem;
}

.space-y-6 > * + * {
  margin-top: 1.5rem;
}

/* Improved button text handling */
button {
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Ensure flex items don't overflow */
.flex {
  min-width: 0;
}

.flex-1 {
  min-width: 0;
}

/* Grid improvements for better alignment */
.grid {
  gap: 1rem;
}

/* Responsive text sizing */
@media (max-width: 640px) {
  .text-2xl {
    font-size: 1.5rem;
    line-height: 2rem;
  }

  .text-lg {
    font-size: 1.125rem;
    line-height: 1.75rem;
  }

  pre {
    padding: 0.75rem;
    font-size: 0.8rem;
    margin: 0.75rem 0;
  }

  .language-java::before,
  .language-pseudocode::before {
    font-size: 0.7rem;
    padding: 0.1rem 0.375rem;
  }
}

/* Improved card layout */
.card-content {
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Better handling of long content */
.max-w-none {
  max-width: none;
}

/* Ensure proper spacing in flex layouts */
.gap-2 {
  gap: 0.5rem;
}

.gap-3 {
  gap: 0.75rem;
}

.gap-4 {
  gap: 1rem;
}

/* Enhanced hover effects for interactive elements */
.hover\:shadow-md:hover {
  box-shadow:
    0 4px 6px -1px rgba(0, 0, 0, 0.2),
    0 2px 4px -1px rgba(0, 0, 0, 0.12);
}

/* Color-specific shadow effects */
.shadow-green-900\/20 {
  box-shadow:
    0 1px 3px 0 rgba(20, 83, 45, 0.2),
    0 1px 2px -1px rgba(20, 83, 45, 0.1);
}

.shadow-red-900\/20 {
  box-shadow:
    0 1px 3px 0 rgba(127, 29, 29, 0.2),
    0 1px 2px -1px rgba(127, 29, 29, 0.1);
}

.shadow-blue-900\/20 {
  box-shadow:
    0 1px 3px 0 rgba(30, 58, 138, 0.2),
    0 1px 2px -1px rgba(30, 58, 138, 0.1);
}

/* Focus ring colors for different button variants */
.focus-visible\:ring-green-500:focus-visible {
  --tw-ring-color: rgb(34 197 94);
}

.focus-visible\:ring-red-500:focus-visible {
  --tw-ring-color: rgb(239 68 68);
}

.focus-visible\:ring-purple-500:focus-visible {
  --tw-ring-color: rgb(168 85 247);
}

.focus-visible\:ring-orange-500:focus-visible {
  --tw-ring-color: rgb(249 115 22);
}

.focus-visible\:ring-gray-500:focus-visible {
  --tw-ring-color: rgb(107 114 128);
}

/* Array Visualization Styles */
.array-visualization {
  display: flex;
  flex-direction: row;
  margin: 1.5rem 0;
  overflow-x: auto;
  padding: 0.5rem;
  border: 2px solid #374151;
  border-radius: 0.5rem;
  background-color: #1f2937;
  width: fit-content;
  max-width: 100%;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
}

.array-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 48px;
  max-width: 80px;
  box-sizing: border-box;
  border-right: 1px solid #4b5563;
  background-color: #374151;
  transition: background-color 0.2s ease;
}

.array-item:last-child {
  border-right: none;
}

.array-item:hover {
  background-color: #4b5563;
}

.array-item-index {
  font-size: 0.75rem;
  color: #9ca3af;
  padding: 4px 8px 2px 8px;
  width: 100%;
  text-align: center;
  box-sizing: border-box;
  border-bottom: 1px solid #4b5563;
  background-color: #1f2937;
  font-weight: 600;
  font-family: 'Courier New', monospace;
}

.array-item-value {
  font-family: 'Courier New', monospace;
  font-weight: 700;
  color: #f9fafb;
  padding: 8px 6px;
  width: 100%;
  text-align: center;
  box-sizing: border-box;
  font-size: 0.9rem;
  min-height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Ensure proper text wrapping in array cells */
.array-item-value,
.array-item-index {
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}

/* Mermaid Diagram Enhancements */
.mermaid {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1.5rem 0;
  padding: 1rem;
  background-color: #1f2937;
  border: 1px solid #374151;
  border-radius: 0.5rem;
  overflow-x: auto;
  min-height: 200px;
}

.mermaid svg {
  max-width: 100%;
  height: auto;
  background-color: transparent;
}

/* Dark theme specific Mermaid overrides */
.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: #374151 !important;
  stroke: #9ca3af !important;
  stroke-width: 2px !important;
}

.mermaid .node .label {
  color: #f9fafb !important;
  fill: #f9fafb !important;
  font-family: inherit !important;
  font-size: 14px !important;
}

.mermaid .edgePath .path {
  stroke: #9ca3af !important;
  stroke-width: 2px !important;
}

.mermaid .edgeLabel {
  background-color: #1f2937 !important;
  color: #f9fafb !important;
  fill: #f9fafb !important;
  font-family: inherit !important;
}

/* Accept state styling for FSMs */
.mermaid .node.acceptState rect,
.mermaid .node.acceptState circle {
  fill: #065f46 !important;
  stroke: #10b981 !important;
  stroke-width: 3px !important;
}

.mermaid .node.acceptState .label {
  color: #d1fae5 !important;
  fill: #d1fae5 !important;
  font-weight: 600 !important;
}

/* Start state styling */
.mermaid .node.startState rect,
.mermaid .node.startState circle {
  fill: #1e40af !important;
  stroke: #3b82f6 !important;
  stroke-width: 3px !important;
}

.mermaid .node.startState .label {
  color: #dbeafe !important;
  fill: #dbeafe !important;
  font-weight: 600 !important;
}

/* Responsive design for arrays */
@media (max-width: 640px) {
  .array-visualization {
    margin: 1rem 0;
    padding: 0.25rem;
  }

  .array-item {
    min-width: 40px;
    max-width: 60px;
  }

  .array-item-index {
    font-size: 0.7rem;
    padding: 2px 4px 1px 4px;
  }

  .array-item-value {
    font-size: 0.8rem;
    padding: 6px 4px;
    min-height: 28px;
  }

  .mermaid {
    padding: 0.5rem;
    margin: 1rem 0;
  }
}

/* Enhanced scrollbar for array visualization */
.array-visualization::-webkit-scrollbar {
  height: 8px;
}

.array-visualization::-webkit-scrollbar-track {
  background: #1f2937;
  border-radius: 4px;
}

.array-visualization::-webkit-scrollbar-thumb {
  background: #4b5563;
  border-radius: 4px;
}

.array-visualization::-webkit-scrollbar-thumb:hover {
  background: #6b7280;
}

/* Ensure proper spacing and alignment */
.array-visualization .array-item:first-child {
  border-top-left-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}

.array-visualization .array-item:last-child {
  border-top-right-radius: 0.25rem;
  border-bottom-right-radius: 0.25rem;
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: app\layout.tsx
SIZE: 914 bytes | LINES: 37
================================================================================
import type { Metadata } from 'next';
import { GeistSans } from 'geist/font/sans';
import { GeistMono } from 'geist/font/mono';
import { Analytics } from '@vercel/analytics/next';
import { ScreenReaderAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';
import './globals.css';

export const metadata: Metadata = {
  title: 'Quiz‑SRS',
  description: 'Secure spaced‑repetition quizzes with safe Markdown + KaTeX.',
  generator: 'quiz-srs',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <style>{`
html {
  font-family: ${GeistSans.style.fontFamily};
  --font-sans: ${GeistSans.variable};
  --font-mono: ${GeistMono.variable};
}
        `}</style>
      </head>
      <body>
        <ScreenReaderAnnouncer>{children}</ScreenReaderAnnouncer>
        <Analytics />
      </body>
    </html>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: app\page.tsx
SIZE: 77,948 bytes | LINES: 2,124
================================================================================
'use client';

import { useState, useMemo } from 'react';
import { WelcomeScreen } from '@/components/welcome-screen';
import { Dashboard } from '@/components/dashboard';
import { QuizSession } from '@/components/quiz-session';
import { QuizComplete } from '@/components/quiz-complete';
import { AllQuestionsView } from '@/components/all-questions-view';
import { ToastContainer } from '@/components/toast-notification';
import { useToast } from '@/hooks/use-toast';
import {
  validateQuizModule,
  normalizeQuizModule,
  validateSingleQuestion,
  normalizeSingleQuestion,
  recalculateChapterStats,
  validateAndCorrectQuizModule,
} from '@/utils/quiz-validation';
import type {
  QuizModule,
  QuizChapter,
  QuizQuestion,
  DisplayedOption,
  SrsProgressCounts,
  IncorrectAnswersExport,
  SessionHistoryEntry,
} from '@/types/quiz-types';
import { ConfirmationModal } from '@/components/confirmation-modal-radix';
import { QuestionReviewModal } from '@/components/question-review-modal';

// Enhanced mock data with new schema (kept as fallback/example)
const mockQuizModule: QuizModule = {
  name: 'Advanced Computer Science Concepts',
  description: 'Master key concepts in algorithms, data structures, and mathematical foundations',
  chapters: [
    {
      id: 'algorithms',
      name: 'Algorithm Analysis',
      description: 'Big O notation, complexity analysis, and optimization techniques',
      totalQuestions: 3,
      answeredQuestions: 2,
      correctAnswers: 1,
      isCompleted: false,
      questions: [
        {
          questionId: 'q1_complexity',
          questionText:
            'What is the time complexity of the following code snippet? <code>for(int i=0; i<n; i++) { for(int j=0; j<n; j++) { print(i*j); } }</code> Express your answer using Big O notation: $$O(f(n))$$',
          options: [
            {
              optionId: 'q1_opt1',
              optionText: '$O(n)$ - Linear time complexity',
            },
            {
              optionId: 'q1_opt2',
              optionText: '$O(n^2)$ - <b>Quadratic</b> time complexity',
            },
            {
              optionId: 'q1_opt3',
              optionText: '$O(\\log n)$ - Logarithmic time complexity',
            },
            {
              optionId: 'q1_opt4',
              optionText: '$O(2^n)$ - Exponential time complexity',
            },
            {
              optionId: 'q1_opt5',
              optionText: '$O(n \\log n)$ - Linearithmic time complexity',
            },
            {
              optionId: 'q1_opt6',
              optionText: '$O(n^3)$ - Cubic time complexity',
            },
            {
              optionId: 'q1_opt7',
              optionText: '$O(1)$ - Constant time complexity',
            },
            {
              optionId: 'q1_opt8',
              optionText: '$O(n!)$ - Factorial time complexity',
            },
          ],
          correctOptionIds: ['q1_opt2'],
          explanationText:
            'The nested loops iterate <code>n</code> times each, resulting in $n \\times n = n^2$ operations. Therefore, the time complexity is $$O(n^2)$$',
          status: 'attempted',
          timesAnsweredCorrectly: 0,
          timesAnsweredIncorrectly: 1,
          lastSelectedOptionId: 'q1_opt1',
          historyOfIncorrectSelections: ['q1_opt1'],
          srsLevel: 0,
          nextReviewAt: new Date(Date.now() + 30 * 1000).toISOString(), // 30 seconds for quick retry
          shownIncorrectOptionIds: ['q1_opt1', 'q1_opt3', 'q1_opt4'],
        },
        {
          questionId: 'q2_sorting',
          questionText:
            'Which sorting algorithms have an average-case time complexity of $O(n \\log n)$? Select <b>all</b> that apply:',
          options: [
            {
              optionId: 'q2_opt1',
              optionText: '<b>Bubble Sort</b> - $O(n^2)$ average case',
            },
            {
              optionId: 'q2_opt2',
              optionText: '<b>Quick Sort</b> - $O(n \\log n)$ average case',
            },
            {
              optionId: 'q2_opt3',
              optionText: '<b>Selection Sort</b> - $O(n^2)$ average case',
            },
            {
              optionId: 'q2_opt4',
              optionText: '<b>Merge Sort</b> - $O(n \\log n)$ average case',
            },
            {
              optionId: 'q2_opt5',
              optionText: '<b>Insertion Sort</b> - $O(n^2)$ average case',
            },
            {
              optionId: 'q2_opt6',
              optionText: '<b>Heap Sort</b> - $O(n \\log n)$ average case',
            },
            {
              optionId: 'q2_opt7',
              optionText: '<b>Radix Sort</b> - $O(d \\cdot n)$ average case',
            },
            {
              optionId: 'q2_opt8',
              optionText: '<b>Counting Sort</b> - $O(n + k)$ average case',
            },
            {
              optionId: 'q2_opt9',
              optionText: '<b>Shell Sort</b> - varies by gap sequence',
            },
            {
              optionId: 'q2_opt10',
              optionText: '<b>Tim Sort</b> - $O(n \\log n)$ average case',
            },
          ],
          correctOptionIds: ['q2_opt2', 'q2_opt4', 'q2_opt6', 'q2_opt10'],
          explanationText:
            'The algorithms with $O(n \\log n)$ average-case complexity are: <b>Quick Sort</b>, <b>Merge Sort</b>, <b>Heap Sort</b>, and <b>Tim Sort</b>. While Quick Sort can degrade to $O(n^2)$ in worst case, its average case is $O(n \\log n)$.',
          status: 'passed_once',
          timesAnsweredCorrectly: 1,
          timesAnsweredIncorrectly: 0,
          lastSelectedOptionId: 'q2_opt2',
          srsLevel: 1,
          nextReviewAt: new Date(Date.now() + 10 * 60 * 1000).toISOString(),
          shownIncorrectOptionIds: ['q2_opt1', 'q2_opt3', 'q2_opt5'],
        },
        {
          questionId: 'q3_bst',
          questionText:
            'In a binary search tree, what is the maximum number of comparisons needed to find an element in a <i>balanced</i> tree with $n$ nodes?',
          options: [
            { optionId: 'q3_opt1', optionText: '$O(n)$ comparisons' },
            { optionId: 'q3_opt2', optionText: '$O(\\log_2 n)$ comparisons' },
            { optionId: 'q3_opt3', optionText: '$O(n^2)$ comparisons' },
            { optionId: 'q3_opt4', optionText: '$O(1)$ comparisons' },
            { optionId: 'q3_opt5', optionText: '$O(n \\log n)$ comparisons' },
            { optionId: 'q3_opt6', optionText: '$O(\\sqrt{n})$ comparisons' },
          ],
          correctOptionIds: ['q3_opt2'],
          explanationText:
            'In a balanced binary search tree, the height is $\\log_2 n$. Since we eliminate half the remaining nodes with each comparison, the maximum number of comparisons is $$\\lceil \\log_2 n \\rceil$$',
          status: 'not_attempted',
          timesAnsweredCorrectly: 0,
          timesAnsweredIncorrectly: 0,
          srsLevel: 0,
          nextReviewAt: null, // Brand new question
          shownIncorrectOptionIds: [],
        },
      ],
    },
    {
      id: 'data-structures',
      name: 'Data Structures',
      description: 'Arrays, linked lists, trees, graphs, and hash tables',
      totalQuestions: 2,
      answeredQuestions: 0,
      correctAnswers: 0,
      isCompleted: false,
      questions: [
        {
          questionId: 'q4_hashtable',
          questionText:
            'What is the space complexity of a hash table with <code>n</code> elements and a load factor of $\\alpha$?',
          options: [
            { optionId: 'q4_opt1', optionText: '$O(n)$ space' },
            { optionId: 'q4_opt2', optionText: '$O(n^2)$ space' },
            { optionId: 'q4_opt3', optionText: '$O(\\log n)$ space' },
            { optionId: 'q4_opt4', optionText: '$O(n/\\alpha)$ space' },
            { optionId: 'q4_opt5', optionText: '$O(\\alpha \\cdot n)$ space' },
          ],
          correctOptionIds: ['q4_opt1'],
          explanationText:
            'A hash table stores <code>n</code> elements regardless of the load factor $\\alpha$. The load factor affects performance but not the fundamental space requirement of $$O(n)$$',
          status: 'not_attempted',
          timesAnsweredCorrectly: 0,
          timesAnsweredIncorrectly: 0,
          srsLevel: 0,
          nextReviewAt: null,
          shownIncorrectOptionIds: [],
        },
        {
          questionId: 'q5_priority_queue',
          questionText:
            'Which data structures are efficient for implementing a <b>priority queue</b>? Select all that apply:',
          options: [
            {
              optionId: 'q5_opt1',
              optionText: '<i>Array</i> - $O(n)$ insertion',
            },
            {
              optionId: 'q5_opt2',
              optionText: '<i>Linked List</i> - $O(n)$ insertion',
            },
            {
              optionId: 'q5_opt3',
              optionText: '<b>Binary Heap</b> - $O(\\log n)$ insertion',
            },
            {
              optionId: 'q5_opt4',
              optionText: '<i>Stack</i> - $O(1)$ insertion',
            },
            {
              optionId: 'q5_opt5',
              optionText: '<b>Fibonacci Heap</b> - $O(1)$ amortized insertion',
            },
            {
              optionId: 'q5_opt6',
              optionText: '<b>Balanced BST</b> - $O(\\log n)$ insertion',
            },
            {
              optionId: 'q5_opt7',
              optionText: "<i>Hash Table</i> - doesn't maintain order",
            },
            {
              optionId: 'q5_opt8',
              optionText: '<b>Binomial Heap</b> - $O(\\log n)$ insertion',
            },
          ],
          correctOptionIds: ['q5_opt3', 'q5_opt5', 'q5_opt6', 'q5_opt8'],
          explanationText:
            'Efficient priority queue implementations include <b>Binary Heap</b>, <b>Fibonacci Heap</b>, <b>Balanced BST</b>, and <b>Binomial Heap</b>. These provide logarithmic or better insertion and extraction operations while maintaining priority order.',
          status: 'not_attempted',
          timesAnsweredCorrectly: 0,
          timesAnsweredIncorrectly: 0,
          srsLevel: 0,
          nextReviewAt: null,
          shownIncorrectOptionIds: [],
        },
      ],
    },
    {
      id: 'mathematics',
      name: 'Mathematical Foundations',
      description: 'Discrete mathematics, probability, and computational theory',
      totalQuestions: 2,
      answeredQuestions: 2,
      correctAnswers: 2,
      isCompleted: true,
      questions: [
        {
          questionId: 'q6_sum_squares',
          questionText: 'What is the value of the sum: $$\\sum_{i=1}^{n} i^2$$',
          options: [
            { optionId: 'q6_opt1', optionText: '$\\frac{n(n+1)}{2}$' },
            { optionId: 'q6_opt2', optionText: '$\\frac{n(n+1)(2n+1)}{6}$' },
            { optionId: 'q6_opt3', optionText: '$n^2$' },
            { optionId: 'q6_opt4', optionText: '$\\frac{n^2(n+1)^2}{4}$' },
            { optionId: 'q6_opt5', optionText: '$2^n - 1$' },
          ],
          correctOptionIds: ['q6_opt2'],
          explanationText:
            'The sum of squares formula is: $$\\sum_{i=1}^{n} i^2 = \\frac{n(n+1)(2n+1)}{6}$$ This can be proven by mathematical induction.',
          status: 'mastered',
          timesAnsweredCorrectly: 2,
          timesAnsweredIncorrectly: 0,
          lastSelectedOptionId: 'q6_opt2',
          srsLevel: 2,
          nextReviewAt: null,
          shownIncorrectOptionIds: [],
        },
        {
          questionId: 'q7_probability',
          questionText:
            'In probability theory, if events $A$ and $B$ are <b>independent</b>, what is $P(A \\cap B)$?',
          options: [
            { optionId: 'q7_opt1', optionText: '$P(A) + P(B)$' },
            { optionId: 'q7_opt2', optionText: '$P(A) \\times P(B)$' },
            { optionId: 'q7_opt3', optionText: '$P(A) - P(B)$' },
            { optionId: 'q7_opt4', optionText: '$\\frac{P(A)}{P(B)}$' },
            { optionId: 'q7_opt5', optionText: '$\\max(P(A), P(B))$' },
            { optionId: 'q7_opt6', optionText: '$\\min(P(A), P(B))$' },
          ],
          correctOptionIds: ['q7_opt2'],
          explanationText:
            'For independent events, the probability of both occurring is: $$P(A \\cap B) = P(A) \\times P(B)$$ This is the fundamental definition of statistical independence.',
          status: 'mastered',
          timesAnsweredCorrectly: 2,
          timesAnsweredIncorrectly: 0,
          lastSelectedOptionId: 'q7_opt2',
          srsLevel: 2,
          nextReviewAt: null,
          shownIncorrectOptionIds: [],
        },
      ],
    },
  ],
};

type AppState = 'welcome' | 'dashboard' | 'quiz' | 'complete' | 'all-questions';

// Interface for the result of getNextReviewQuestion
interface NextReviewQuestion {
  chapterId: string;
  question: QuizQuestion;
}

// Define the structure for incorrect answer log entries
interface IncorrectAnswerLogEntry {
  questionId: string;
  questionText: string;
  chapterId: string;
  chapterName: string;
  incorrectSelections: {
    selectedOptionId: string;
    selectedOptionText: string;
  }[];
  correctOptionIds: string[];
  correctOptionTexts: string[];
  explanationText: string;
  totalTimesCorrect: number;
  totalTimesIncorrect: number;
  currentSrsLevel: number;
  lastAttemptedAt?: string;
}

export default function MCQQuizForge() {
  const [appState, setAppState] = useState<AppState>('welcome');
  const [currentModule, setCurrentModule] = useState<QuizModule | null>(null);
  const [currentChapterId, setCurrentChapterId] = useState<string>('');
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedOptionId, setSelectedOptionId] = useState<string | null>(null);
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string>('');

  // For managing the "delete current question" confirmation
  const [showDeleteCurrentQuestionConfirmation, setShowDeleteCurrentQuestionConfirmation] =
    useState(false);
  const [questionToDelete, setQuestionToDelete] = useState<QuizQuestion | null>(null);

  // For managing the "overwrite current question" confirmation
  const [showOverwriteCurrentQuestionConfirmation, setShowOverwriteCurrentQuestionConfirmation] =
    useState(false);
  const [pendingOverwriteData, setPendingOverwriteData] = useState<QuizQuestion | null>(null);

  // For managing the "review and append new questions" modal
  const [showAppendReviewModal, setShowAppendReviewModal] = useState(false);
  const [questionsToReviewForAppend, setQuestionsToReviewForAppend] = useState<QuizQuestion[]>([]);

  // Toast notifications
  const { toasts, removeToast, showSuccess, showError, showInfo, showWarning } = useToast();

  // SRS state - SIMPLIFIED: Remove static reviewQueue, use dynamic approach
  const [isReviewSessionActive, setIsReviewSessionActive] = useState(false);
  // For review mode, we'll store the current review question directly
  const [currentReviewQuestion, setCurrentReviewQuestion] = useState<NextReviewQuestion | null>(
    null,
  );

  // Session History Navigation State
  const [sessionHistory, setSessionHistory] = useState<SessionHistoryEntry[]>([]);
  const [currentHistoryViewIndex, setCurrentHistoryViewIndex] = useState<number | null>(null);

  // Edit Mode State - Phase 1
  const [isEditModeActive, setIsEditModeActive] = useState(false);
  const [editingQuestionData, setEditingQuestionData] = useState<QuizQuestion | null>(null);

  // Edit Mode Handler - Phase 1
  const handleSetEditMode = (question: QuizQuestion | null) => {
    console.log('=== Setting Edit Mode ===');
    console.log('Question:', question ? question.questionId : 'null (new question)');

    setEditingQuestionData(question);
    setIsEditModeActive(question !== null);

    if (question) {
      console.log('Entering edit mode for existing question');
    } else {
      console.log('Exiting edit mode');
    }
  };

  // Phase 3: Save/Update Logic
  const handleSaveQuestion = async (questionData: QuizQuestion) => {
    if (!currentModule || !currentChapterId) {
      showError('Save Failed', 'No current module or chapter context found');
      return;
    }

    try {
      console.log('=== Saving Question ===');
      console.log('Question ID:', questionData.questionId);
      console.log('Is new question:', !editingQuestionData);

      // Validate question data
      const validation = validateSingleQuestion(questionData);
      if (!validation.isValid) {
        showError(
          'Validation Failed',
          `Question validation failed:\n${validation.errors.slice(0, 3).join('\n')}`,
        );
        return;
      }

      // Create deep copy of module
      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (!targetChapter) {
        showError('Save Failed', 'Target chapter not found');
        return;
      }

      // Normalize the question data
      const normalizedQuestion = normalizeSingleQuestion(questionData);

      if (editingQuestionData) {
        // Update existing question
        const questionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === editingQuestionData.questionId,
        );

        if (questionIndex === -1) {
          showError('Save Failed', 'Original question not found for update');
          return;
        }

        // Preserve performance tracking data from original question
        const originalQuestion = targetChapter.questions[questionIndex];
        normalizedQuestion.status = originalQuestion.status;
        normalizedQuestion.timesAnsweredCorrectly = originalQuestion.timesAnsweredCorrectly;
        normalizedQuestion.timesAnsweredIncorrectly = originalQuestion.timesAnsweredIncorrectly;
        normalizedQuestion.historyOfIncorrectSelections =
          originalQuestion.historyOfIncorrectSelections;
        normalizedQuestion.lastSelectedOptionId = originalQuestion.lastSelectedOptionId;
        normalizedQuestion.lastAttemptedAt = originalQuestion.lastAttemptedAt;
        normalizedQuestion.srsLevel = originalQuestion.srsLevel;
        normalizedQuestion.nextReviewAt = originalQuestion.nextReviewAt;
        normalizedQuestion.shownIncorrectOptionIds = originalQuestion.shownIncorrectOptionIds;

        targetChapter.questions[questionIndex] = normalizedQuestion;
        console.log('Updated existing question at index:', questionIndex);

        showSuccess('Question Updated', 'Question updated successfully');
      } else {
        // Add new question
        const currentQuestion = getCurrentQuestion();
        let insertionIndex = targetChapter.questions.length; // Default to end

        if (currentQuestion) {
          // Insert after current question
          const currentIndex = targetChapter.questions.findIndex(
            (q) => q.questionId === currentQuestion.questionId,
          );
          if (currentIndex !== -1) {
            insertionIndex = currentIndex + 1;
          }
        }

        targetChapter.questions.splice(insertionIndex, 0, normalizedQuestion);
        console.log('Added new question at index:', insertionIndex);

        showSuccess('Question Added', 'New question added successfully');
      }

      // Recalculate chapter stats
      recalculateChapterStats(targetChapter);

      // Update module state
      setCurrentModule(updatedModule);

      // Exit edit mode
      handleSetEditMode(null);

      console.log('Question save completed successfully');
    } catch (error) {
      console.error('Error saving question:', error);
      showError(
        'Save Failed',
        `Failed to save question: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  };

  // Phase 4: Delete Logic
  const handleDeleteQuestion = async (questionId: string) => {
    if (!currentModule || !currentChapterId) {
      showError('Delete Failed', 'No current module or chapter context found');
      return;
    }

    try {
      console.log('=== Deleting Question ===');
      console.log('Question ID:', questionId);

      // Create deep copy of module
      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (!targetChapter) {
        showError('Delete Failed', 'Target chapter not found');
        return;
      }

      const questionIndex = targetChapter.questions.findIndex((q) => q.questionId === questionId);

      if (questionIndex === -1) {
        showError('Delete Failed', 'Question not found for deletion');
        return;
      }

      // Check if this is the only question in the chapter
      if (targetChapter.questions.length === 1) {
        showWarning('Cannot Delete', 'Cannot delete the last question in a chapter');
        return;
      }

      // Remove the question
      targetChapter.questions.splice(questionIndex, 1);
      console.log('Deleted question at index:', questionIndex);

      // Recalculate chapter stats
      recalculateChapterStats(targetChapter);

      // Update module state
      setCurrentModule(updatedModule);

      // Exit edit mode
      handleSetEditMode(null);

      // Adjust current question index if necessary
      if (currentQuestionIndex >= targetChapter.questions.length) {
        setCurrentQuestionIndex(Math.max(0, targetChapter.questions.length - 1));
      }

      showSuccess('Question Deleted', 'Question deleted successfully');
      console.log('Question deletion completed successfully');
    } catch (error) {
      console.error('Error deleting question:', error);
      showError(
        'Delete Failed',
        `Failed to delete question: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  };

  // Phase 5: Unique ID Generation
  const generateUniqueOptionId = (questionId: string, existingOptionIds: string[]): string => {
    let counter = 1;
    let newId: string;

    do {
      newId = `${questionId}_opt${counter}`;
      counter++;
    } while (existingOptionIds.includes(newId));

    return newId;
  };

  const generateUniqueQuestionId = (chapterId: string): string => {
    if (!currentModule) return `${chapterId}_q1`;

    const chapter = currentModule.chapters.find((c) => c.id === chapterId);
    if (!chapter) return `${chapterId}_q1`;

    const existingIds = chapter.questions.map((q) => q.questionId);
    let counter = 1;
    let newId: string;

    do {
      newId = `${chapterId}_q${counter}`;
      counter++;
    } while (existingIds.includes(newId));

    return newId;
  };

  // NEW: Load Default Quiz Handler
  const handleLoadDefaultQuiz = async () => {
    setIsLoading(true);
    setError('');

    try {
      console.log('=== Loading Default Quiz ===');
      console.log('Attempting to fetch default quiz from /default-quiz.json');

      // Fetch the default quiz file from public folder
      const response = await fetch('/default-quiz.json');

      if (!response.ok) {
        throw new Error(`Failed to fetch default quiz: ${response.statusText}`);
      }

      // Get file content as text
      const fileContent = await response.text();
      console.log('Default quiz file content length:', fileContent.length);

      // Parse JSON with error handling
      let parsedData: any;
      try {
        parsedData = JSON.parse(fileContent);
        console.log('Default quiz JSON parsed successfully');
      } catch (parseError) {
        console.error('Default quiz JSON parse error:', parseError);
        throw new Error('Invalid JSON format in default quiz file.');
      }

      // Validate the parsed data
      const validation = validateQuizModule(parsedData);
      if (!validation.isValid) {
        console.error('Default quiz validation errors:', validation.errors);
        throw new Error(`Invalid default quiz format:
${validation.errors.slice(0, 3).join('\n')}`);
      }

      // Normalize and set the module
      const normalizedModule = normalizeQuizModule(parsedData);
      setCurrentModule(normalizedModule);
      setAppState('dashboard');

      // Show success toast
      showSuccess(
        'Algorithm Quiz Loaded!',
        `Loaded "${normalizedModule.name}" with ${normalizedModule.chapters.length} chapters`,
        5000,
      );

      console.log('Successfully loaded default quiz module:', normalizedModule.name);
    } catch (err) {
      console.error('Error loading default quiz:', err);
      const errorMessage =
        err instanceof Error
          ? err.message
          : 'Unknown error occurred while loading the default quiz';
      setError(errorMessage);

      // Show error toast
      showError('Failed to Load Algorithm Quiz', errorMessage, 8000);

      // Keep user on welcome screen if loading fails
      setAppState('welcome');
    } finally {
      setIsLoading(false);
    }
  };

  // REFINED: Calculate review queue count with improved logic that aligns with getNextReviewQuestion
  const reviewQueueCount = useMemo(() => {
    if (!currentModule) return 0;

    const now = new Date();
    let count = 0;

    console.log('=== Calculating Review Queue Count (Refined) ===');
    console.log('Current time:', now.toISOString());

    currentModule.chapters.forEach((chapter) => {
      chapter.questions.forEach((question) => {
        const isNotMastered = question.status !== 'mastered';

        // REFINED: Align with getNextReviewQuestion's understanding of "due"
        const isBrandNewAndReady = question.srsLevel === 0 && question.nextReviewAt === null; // Brand new, srsLevel 0
        const isScheduledAndDue =
          question.nextReviewAt !== null && new Date(question.nextReviewAt!) <= now; // Scheduled and time has passed
        const isDue = isBrandNewAndReady || isScheduledAndDue;

        if (isNotMastered && isDue) {
          count++;
        }
      });
    });

    console.log(`Total review queue count: ${count}`);
    return count;
  }, [currentModule]);

  // FIXED: Calculate SRS progress counts for Anki-style progress bars
  const srsProgressCounts = useMemo((): SrsProgressCounts | null => {
    if (!currentModule || !isReviewSessionActive) return null;

    const now = new Date();
    let newOrLapsingDue = 0;
    let learningReviewDue = 0;
    let totalNonMastered = 0;

    console.log('=== Calculating SRS Progress Counts (FIXED) ===');

    currentModule.chapters.forEach((chapter) => {
      chapter.questions.forEach((question) => {
        const isNotMastered = question.status !== 'mastered';

        if (isNotMastered) {
          totalNonMastered++;

          // FIXED: For newOrLapsingDue, only count srsLevel 0 items that are actually due now
          if (question.srsLevel === 0) {
            const isBrandNewAndReady = question.nextReviewAt === null;
            const isScheduledAndDue =
              question.nextReviewAt !== null && new Date(question.nextReviewAt!) <= now;
            const isDue = isBrandNewAndReady || isScheduledAndDue;

            if (isDue) {
              newOrLapsingDue++;
              console.log(`  - ${question.questionId}: New/Lapsing (srsLevel 0, due now)`);
            }
          }

          // FIXED: For learningReviewDue, count ALL srsLevel 1 items regardless of due time
          // This represents items "in the learning pipeline" like Anki's green learning count
          if (question.srsLevel === 1) {
            learningReviewDue++;
            console.log(`  - ${question.questionId}: Learning Review (srsLevel 1, in pipeline)`);
          }
        }
      });
    });

    const counts = { newOrLapsingDue, learningReviewDue, totalNonMastered };
    return counts;
  }, [currentModule, isReviewSessionActive]);

  // ENHANCED: Find the next most urgent review question with slight "stickiness" for recent failures
  const getNextReviewQuestion = (): NextReviewQuestion | null => {
    if (!currentModule) return null;

    const now = new Date();
    const dueQuestions: Array<
      NextReviewQuestion & {
        priority: number;
        dueTime: number;
        isRecentFailure: boolean;
      }
    > = [];

    console.log('Current time:', now.toISOString());

    // Collect all due questions from all chapters
    currentModule.chapters.forEach((chapter) => {
      chapter.questions.forEach((question) => {
        const isNotMastered = question.status !== 'mastered';

        // Standard "due" evaluation
        const isBrandNewAndReady = question.srsLevel === 0 && question.nextReviewAt === null;
        const isScheduledAndDue =
          question.nextReviewAt !== null && new Date(question.nextReviewAt!) <= now;
        const isDue = isBrandNewAndReady || isScheduledAndDue;

        // ENHANCED: Check for "recent failure" - srsLevel 0 items with nextReviewAt in very near future
        const isRecentFailure =
          question.srsLevel === 0 &&
          question.nextReviewAt !== null &&
          new Date(question.nextReviewAt!).getTime() - now.getTime() <= 60000; // Within 60 seconds

        if (isNotMastered && (isDue || isRecentFailure)) {
          const srsLevel = question.srsLevel || 0;
          const dueTime = question.nextReviewAt ? new Date(question.nextReviewAt).getTime() : 0;

          dueQuestions.push({
            chapterId: chapter.id,
            question,
            priority: srsLevel,
            dueTime,
            isRecentFailure,
          });

          console.log(
            `  - ✅ ADDED TO DUE LIST (Priority: ${srsLevel}, Recent Failure: ${isRecentFailure})`,
          );
        } else {
          console.log(`  - ❌ NOT DUE`);
        }
      });
    });

    if (dueQuestions.length === 0) {
      console.log('No questions due for review');
      return null;
    }

    // ENHANCED: Sort with slight preference for recent failures if queue is small
    dueQuestions.sort((a, b) => {
      // If queue is small (≤3 items) and one is a recent failure, prioritize it slightly
      if (dueQuestions.length <= 3) {
        if (a.isRecentFailure && !b.isRecentFailure) return -1;
        if (!a.isRecentFailure && b.isRecentFailure) return 1;
      }

      // Standard priority sorting
      if (a.priority !== b.priority) {
        return a.priority - b.priority; // Lower srsLevel first
      }
      return a.dueTime - b.dueTime; // Earlier due time first
    });

    const nextQuestion = dueQuestions[0];
    console.log(
      `Selected next review question: ${nextQuestion.question.questionId} (Priority: ${nextQuestion.priority}, Recent Failure: ${nextQuestion.isRecentFailure})`,
    );

    return {
      chapterId: nextQuestion.chapterId,
      question: nextQuestion.question,
    };
  };

  // Load the next review question and set up the UI
  const loadNextReviewQuestion = () => {
    console.log('=== Loading Next Review Question ===');

    const nextReview = getNextReviewQuestion();

    if (nextReview) {
      console.log(
        `Loading question: ${nextReview.question.questionId} from chapter: ${nextReview.chapterId}`,
      );

      setCurrentReviewQuestion(nextReview);
      setCurrentChapterId(nextReview.chapterId);
      setSelectedOptionId(null);
      setIsSubmitted(false);
      setAppState('quiz');
    } else {
      console.log('No more questions due - ending review session');

      // No more questions due - end review session
      setIsReviewSessionActive(false);
      setCurrentReviewQuestion(null);
      setAppState('dashboard');

      // REPLACED: alert() with toast notification
      showSuccess('Review Session Complete! 🎉', 'No more reviews due right now. Great job!', 6000);
    }
  };

  const readFileAsText = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        const result = event.target?.result;
        if (typeof result === 'string') {
          resolve(result);
        }
      };
      reader.onload = (event) => {
        const result = event.target?.result;
        if (typeof result === 'string') {
          resolve(result);
        } else {
          reject(new Error('Failed to read file as text'));
        }
      };
      reader.onerror = () => reject(new Error('Error reading file'));
      reader.readAsText(file);
    });
  };

  // Replace the existing handleLoadQuiz function with this enhanced version
  const handleLoadQuiz = async (file: File) => {
    setIsLoading(true);
    setError('');

    try {
      console.log('Loading quiz file:', file.name, 'Size:', file.size, 'Type:', file.type);

      // Read file content
      const fileContent = await readFileAsText(file);
      console.log('File content length:', fileContent.length);

      // Determine file type and parse accordingly
      const isMarkdownFile =
        file.name.toLowerCase().endsWith('.md') || file.name.toLowerCase().endsWith('.markdown');

      let normalizedModule: QuizModule;
      let correctionResult: any;

      if (isMarkdownFile) {
        console.log('Processing as Markdown file...');

        // Parse Markdown content
        const { parseMarkdownToQuizModule } = await import('@/utils/quiz-validation');
        const parseResult = parseMarkdownToQuizModule(fileContent);

        if (!parseResult.success || !parseResult.quizModule) {
          console.error('Markdown parsing errors:', parseResult.errors);
          throw new Error(`Failed to parse Markdown file:
${parseResult.errors.slice(0, 3).join('\n')}`);
        }

        normalizedModule = parseResult.quizModule;

        // Show any parsing warnings
        if (parseResult.errors.length > 0) {
          console.warn('Markdown parsing warnings:', parseResult.errors);
          showWarning(
            'Parsing Warnings',
            `${parseResult.errors.length} warnings during parsing. Check console for details.`,
            6000,
          );
        }

        setCurrentModule(normalizedModule);
        setAppState('dashboard');

        showSuccess(
          'Markdown Quiz Loaded Successfully!',
          `Loaded "${normalizedModule.name}" with ${normalizedModule.chapters.length} chapters from Markdown`,
          6000,
        );

        console.log('Successfully loaded Markdown quiz module:', normalizedModule.name);
      } else {
        console.log('Processing as JSON file...');

        // Parse JSON with LaTeX correction (existing logic)
        let parsedData: any;
        try {
          // First attempt: try parsing as-is
          parsedData = JSON.parse(fileContent);
          console.log('JSON parsed successfully without corrections');
        } catch (parseError) {
          console.log('Initial JSON parse failed, applying LaTeX corrections...');

          // Apply LaTeX corrections and re-parse
          const {
            validationResult: validation,
            correctionResult: latexCorrection,
            normalizedModule: correctedModule,
          } = validateAndCorrectQuizModule(fileContent);

          correctionResult = latexCorrection;

          if (!validation.isValid) {
            console.error('Validation errors after LaTeX correction:', validation.errors);
            throw new Error(`Invalid quiz module format:
${validation.errors.slice(0, 3).join('\n')}`);
          }

          if (correctedModule) {
            // Use the pre-normalized module from the correction process
            setCurrentModule(correctedModule);
            setAppState('dashboard');

            // Show success message with correction details
            let successMessage = `Loaded "${correctedModule.name}" with ${correctedModule.chapters.length} chapters`;
            if (correctionResult && correctionResult.correctionsMade > 0) {
              successMessage += ` (${correctionResult.correctionsMade} LaTeX formatting corrections applied)`;
            }

            showSuccess('Quiz Module Loaded Successfully!', successMessage, 6000);

            // Show correction details if any were made
            if (correctionResult && correctionResult.correctionsMade > 0) {
              console.log('LaTeX corrections applied:', correctionResult.correctionDetails);
              showInfo(
                'LaTeX Formatting Corrected',
                `Automatically fixed ${correctionResult.correctionsMade} LaTeX formatting issues. Your quiz is now ready to use!`,
                8000,
              );
            }

            console.log(
              'Successfully loaded quiz module with LaTeX corrections:',
              correctedModule.name,
            );
            return;
          }
        }

        // If we reach here, either the JSON parsed successfully initially, or we need to handle it manually
        if (!correctionResult) {
          // Standard validation for successfully parsed JSON
          const validation = validateQuizModule(parsedData);
          if (!validation.isValid) {
            console.error('Validation errors:', validation.errors);
            throw new Error(`Invalid quiz module format:
${validation.errors.slice(0, 3).join('\n')}`);
          }

          // Normalize and set the module
          normalizedModule = normalizeQuizModule(parsedData);
          setCurrentModule(normalizedModule);
          setAppState('dashboard');

          showSuccess(
            'Quiz Module Loaded Successfully!',
            `Loaded "${normalizedModule.name}" with ${normalizedModule.chapters.length} chapters`,
            4000,
          );

          console.log('Successfully loaded quiz module:', normalizedModule.name);
        }
      }
    } catch (err) {
      console.error('Error loading quiz module:', err);
      const errorMessage =
        err instanceof Error ? err.message : 'Unknown error occurred while loading the quiz module';
      setError(errorMessage);

      showError('Failed to Load Quiz Module', errorMessage, 8000);
    } finally {
      setIsLoading(false);
    }
  };

  // Replace the existing handleImportState function with this enhanced version
  const handleImportState = async (file: File) => {
    try {
      console.log('Importing state file:', file.name, 'Size:', file.size, 'Type:', file.type);

      // Read file content
      const fileContent = await readFileAsText(file);
      console.log('State file content length:', fileContent.length);

      // Parse JSON with LaTeX correction support
      let parsedData: any;
      let correctionResult: any;
      try {
        // First attempt: try parsing as-is
        parsedData = JSON.parse(fileContent);
        console.log('State JSON parsed successfully without corrections');
      } catch (parseError) {
        console.log('Initial state JSON parse failed, applying LaTeX corrections...');

        // Apply LaTeX corrections and re-parse
        const {
          validationResult: validation,
          correctionResult: latexCorrection,
          normalizedModule,
        } = validateAndCorrectQuizModule(fileContent);

        correctionResult = latexCorrection;

        if (!validation.isValid) {
          console.error('State validation errors after LaTeX correction:', validation.errors);
          showError(
            'Invalid State File',
            `Invalid state file format:
${validation.errors.slice(0, 3).join('\n')}`,
            8000,
          );
          return;
        }

        if (normalizedModule) {
          // Use the pre-normalized module from the correction process
          setCurrentModule(normalizedModule);

          // Reset quiz session state
          setCurrentChapterId('');
          setCurrentQuestionIndex(0);
          setSelectedOptionId(null);
          setIsSubmitted(false);
          setError('');
          setIsReviewSessionActive(false);
          setCurrentReviewQuestion(null);

          // Show success message with correction details
          let successMessage = `Imported progress for "${normalizedModule.name}"`;
          if (correctionResult && correctionResult.correctionsMade > 0) {
            successMessage += ` (${correctionResult.correctionsMade} LaTeX corrections applied)`;
          }

          showSuccess('State Imported Successfully!', successMessage, 6000);

          // Show correction details if any were made
          if (correctionResult && correctionResult.correctionsMade > 0) {
            console.log(
              'LaTeX corrections applied during import:',
              correctionResult.correctionDetails,
            );
            showInfo(
              'LaTeX Formatting Corrected',
              `Automatically fixed ${correctionResult.correctionsMade} LaTeX formatting issues during import.`,
              6000,
            );
          }

          console.log('Successfully imported state with LaTeX corrections:', normalizedModule.name);
          return;
        }
      }

      // If we reach here, the JSON parsed successfully initially
      if (!correctionResult) {
        // Standard validation for successfully parsed JSON
        const validation = validateQuizModule(parsedData);
        if (!validation.isValid) {
          console.error('State validation errors:', validation.errors);
          showError(
            'Invalid State File',
            `Invalid state file format:
${validation.errors.slice(0, 3).join('\n')}`,
            8000,
          );
          return;
        }

        // Normalize and set the module
        const normalizedModule = normalizeQuizModule(parsedData);
        setCurrentModule(normalizedModule);

        // Reset quiz session state
        setCurrentChapterId('');
        setCurrentQuestionIndex(0);
        setSelectedOptionId(null);
        setIsSubmitted(false);
        setError('');
        setIsReviewSessionActive(false);
        setCurrentReviewQuestion(null);

        showSuccess(
          'State Imported Successfully!',
          `Imported progress for "${normalizedModule.name}"`,
          4000,
        );
        console.log('Successfully imported state:', normalizedModule.name);
      }
    } catch (err) {
      console.error('Error importing state:', err);
      showError(
        'Import Failed',
        `Error importing state: ${err instanceof Error ? err.message : 'Unknown error'}`,
        6000,
      );
    }
  };

  // NEW: Export current question state
  const handleExportCurrentQuestionState = () => {
    const currentQuestion = getCurrentQuestion();
    if (!currentQuestion) {
      showError('Export Failed', 'No current question found to export');
      return;
    }

    try {
      // Export as array for consistency with import logic
      const exportData = [currentQuestion];
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `qstate-${currentQuestion.questionId}-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);

      showSuccess(
        'Question Exported',
        `Exported question "${currentQuestion.questionId}" successfully`,
      );
    } catch (error) {
      console.error('Error exporting question:', error);
      showError('Export Failed', 'Failed to export question state');
    }
  };

  // NEW: Import question state from file
  const handleInitiateImportCurrentQuestionState = async (file: File) => {
    const currentQuestion = getCurrentQuestion();
    if (!currentQuestion || !currentChapterId) {
      showError('Import Failed', 'No current question context found');
      return;
    }

    try {
      // Read and parse file
      const fileContent = await readFileAsText(file);
      let parsedData: any;
      try {
        parsedData = JSON.parse(fileContent);
      } catch (parseError) {
        showError('Import Failed', 'Invalid JSON format in the imported file');
        return;
      }

      // Expect array of questions
      if (!Array.isArray(parsedData)) {
        showError('Import Failed', 'Expected an array of questions in the imported file');
        return;
      }

      // Handle empty array - offer to delete current question
      if (parsedData.length === 0) {
        setQuestionToDelete(currentQuestion);
        setShowDeleteCurrentQuestionConfirmation(true);
        return;
      }

      // Validate and normalize all imported questions
      const validNormalizedImportedQuestions: QuizQuestion[] = [];
      for (let i = 0; i < parsedData.length; i++) {
        const questionData = parsedData[i];
        const validation = validateSingleQuestion(questionData);

        if (!validation.isValid) {
          showError(
            'Import Failed',
            `Question ${i + 1} is invalid:
${validation.errors.slice(0, 3).join('\n')}`,
          );
          return;
        }

        const normalizedQuestion = normalizeSingleQuestion(questionData as QuizQuestion);
        validNormalizedImportedQuestions.push(normalizedQuestion);
      }

      if (validNormalizedImportedQuestions.length === 0) {
        showError('Import Failed', 'No valid questions found in the imported file');
        return;
      }

      // Process the questions
      const firstImportedQuestion = validNormalizedImportedQuestions[0];
      const additionalQuestionsForAppend = validNormalizedImportedQuestions.slice(1);

      // Check for overwrite
      if (firstImportedQuestion.questionId === currentQuestion.questionId) {
        setPendingOverwriteData(firstImportedQuestion);
        setQuestionsToReviewForAppend(additionalQuestionsForAppend);
        setShowOverwriteCurrentQuestionConfirmation(true);
      } else {
        // No overwrite - all questions are for appending
        setPendingOverwriteData(null);
        setQuestionsToReviewForAppend(validNormalizedImportedQuestions);

        if (validNormalizedImportedQuestions.length > 0) {
          setShowAppendReviewModal(true);
        } else {
          showInfo(
            'Nothing to Import',
            'Imported question ID does not match current. Nothing to overwrite or append.',
          );
        }
      }
    } catch (error) {
      console.error('Error importing question state:', error);
      showError(
        'Import Failed',
        `Error importing question state: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  };

  // NEW: Confirm delete current question
  const handleConfirmDeleteCurrentQuestion = () => {
    if (!currentModule || !questionToDelete || !currentChapterId) return;

    try {
      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (targetChapter) {
        const questionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === questionToDelete.questionId,
        );

        if (questionIndex !== -1) {
          targetChapter.questions.splice(questionIndex, 1);
          recalculateChapterStats(targetChapter);
          setCurrentModule(updatedModule);

          showSuccess('Question Deleted', 'Question deleted successfully');

          // Reset modal states
          setShowDeleteCurrentQuestionConfirmation(false);
          setQuestionToDelete(null);

          // Advance to next question
          handleNextQuestion();
        }
      }
    } catch (error) {
      console.error('Error deleting question:', error);
      showError('Delete Failed', 'Failed to delete question');
    }
  };

  // NEW: Cancel delete current question
  const handleCancelDeleteCurrentQuestion = () => {
    setShowDeleteCurrentQuestionConfirmation(false);
    setQuestionToDelete(null);
  };

  // NEW: Confirm overwrite current question
  const handleConfirmOverwriteCurrentQuestion = () => {
    if (!currentModule || !pendingOverwriteData || !currentChapterId) return;

    try {
      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (targetChapter) {
        const questionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === pendingOverwriteData.questionId,
        );

        if (questionIndex !== -1) {
          targetChapter.questions[questionIndex] = pendingOverwriteData;
          recalculateChapterStats(targetChapter);
          setCurrentModule(updatedModule);

          showSuccess('Question Overwritten', 'Question overwritten successfully');

          // Reset overwrite modal
          setShowOverwriteCurrentQuestionConfirmation(false);

          // Proceed to append if there are additional questions
          if (questionsToReviewForAppend.length > 0) {
            setShowAppendReviewModal(true);
          } else {
            setPendingOverwriteData(null);
            setQuestionsToReviewForAppend([]);
          }
        }
      }
    } catch (error) {
      console.error('Error overwriting question:', error);
      showError('Overwrite Failed', 'Failed to overwrite question');
    }
  };

  // NEW: Cancel overwrite current question
  const handleCancelOverwriteCurrentQuestion = () => {
    setShowOverwriteCurrentQuestionConfirmation(false);
    setPendingOverwriteData(null);
    setQuestionsToReviewForAppend([]);
  };

  // NEW: Save appended questions with overwrite capability
  const handleSaveAppendedQuestions = (questionsToActuallyAppend: QuizQuestion[]) => {
    if (!currentModule || !currentChapterId || questionsToActuallyAppend.length === 0) return;

    try {
      const currentQuestion = getCurrentQuestion();
      if (!currentQuestion) return;

      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (targetChapter) {
        // Find insertion point
        let insertionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === currentQuestion.questionId,
        );
        if (insertionIndex === -1) {
          insertionIndex = targetChapter.questions.length - 1; // Append at end if not found
        }

        // Process each imported question
        let overwrittenCount = 0;
        let addedCount = 0;
        const questionsToInsert: QuizQuestion[] = [];

        questionsToActuallyAppend.forEach((importedQuestion) => {
          // Check if a question with this ID already exists in the chapter
          const existingQuestionIndex = targetChapter.questions.findIndex(
            (q) => q.questionId === importedQuestion.questionId,
          );

          if (existingQuestionIndex !== -1) {
            // Overwrite existing question
            targetChapter.questions[existingQuestionIndex] = importedQuestion;
            overwrittenCount++;
            console.log(`Overwritten existing question: ${importedQuestion.questionId}`);
          } else {
            // New question - add to insertion list
            questionsToInsert.push(importedQuestion);
            addedCount++;
            console.log(`Prepared new question for insertion: ${importedQuestion.questionId}`);
          }
        });

        // Insert new questions after the current question
        if (questionsToInsert.length > 0) {
          targetChapter.questions.splice(insertionIndex + 1, 0, ...questionsToInsert);
        }

        // Recalculate chapter stats
        recalculateChapterStats(targetChapter);
        setCurrentModule(updatedModule);

        // Show success message with details
        const totalProcessed = overwrittenCount + addedCount;
        let message = `${totalProcessed} question(s) processed successfully`;
        if (overwrittenCount > 0 && addedCount > 0) {
          message += ` (${overwrittenCount} overwritten, ${addedCount} added)`;
        } else if (overwrittenCount > 0) {
          message += ` (${overwrittenCount} overwritten)`;
        } else {
          message += ` (${addedCount} added)`;
        }

        showSuccess('Questions Imported', message);

        // Reset modal states
        setShowAppendReviewModal(false);
        setQuestionsToReviewForAppend([]);
        setPendingOverwriteData(null);

        console.log(`Import complete: ${overwrittenCount} overwritten, ${addedCount} added`);
      }
    } catch (error) {
      console.error('Error importing questions:', error);
      showError('Import Failed', 'Failed to import questions');
    }
  };

  // NEW: Cancel append questions
  const handleCancelAppendQuestions = () => {
    setShowAppendReviewModal(false);
    setQuestionsToReviewForAppend([]);
    setPendingOverwriteData(null);
  };

  // VERIFIED: Export incorrect answers history with proper chapter name handling
  const handleLoadNewModule = () => {
    // Placeholder function - not implemented yet
    console.log('Load new module not implemented yet');
  };

  const handleExportIncorrectAnswers = () => {
    if (!currentModule) return;

    console.log('=== Exporting Incorrect Answers History ===');

    const incorrectAnswersLog: IncorrectAnswersExport = [];

    currentModule.chapters.forEach((chapter) => {
      chapter.questions.forEach((question) => {
        // Only include questions that have been answered incorrectly
        if ((question.timesAnsweredIncorrectly || 0) > 0) {
          console.log(`Processing question with incorrect answers: ${question.questionId}`);

          // Build incorrect selections array
          const incorrectSelections = (question.historyOfIncorrectSelections || []).map(
            (selectedOptionId) => {
              const selectedOption = question.options.find(
                (opt) => opt.optionId === selectedOptionId,
              );
              return {
                selectedOptionId,
                selectedOptionText: selectedOption
                  ? selectedOption.optionText
                  : `[Option ${selectedOptionId} not found]`,
              };
            },
          );

          // Build correct options array
          const correctOptionTexts = question.correctOptionIds.map((correctOptionId) => {
            const correctOption = question.options.find((opt) => opt.optionId === correctOptionId);
            return correctOption
              ? correctOption.optionText
              : `[Option ${correctOptionId} not found]`;
          });

          const logEntry: IncorrectAnswerLogEntry = {
            questionId: question.questionId,
            questionText: question.questionText,
            chapterId: chapter.id,
            chapterName: chapter.name, // VERIFIED: Correctly using chapter.name
            incorrectSelections,
            correctOptionIds: question.correctOptionIds,
            correctOptionTexts,
            explanationText: question.explanationText,
            totalTimesCorrect: question.timesAnsweredCorrectly || 0,
            totalTimesIncorrect: question.timesAnsweredIncorrectly || 0,
            currentSrsLevel: question.srsLevel || 0,
            lastAttemptedAt: question.lastAttemptedAt,
          };

          incorrectAnswersLog.push(logEntry);
          console.log(
            `Added to log: ${question.questionId} (${incorrectSelections.length} incorrect attempts)`,
          );
        }
      });
    });

    if (incorrectAnswersLog.length === 0) {
      // REPLACED: alert() with toast
      showInfo('No Mistakes to Export', 'No incorrect answers found to export!', 4000);
      return;
    }

    // Create export data with metadata
    const exportData = {
      exportedAt: new Date().toISOString(),
      moduleName: currentModule.name,
      moduleDescription: currentModule.description,
      totalIncorrectQuestions: incorrectAnswersLog.length,
      // VERIFIED: Using totalTimesIncorrect (better than incorrectSelections.length)
      totalIncorrectAttempts: incorrectAnswersLog.reduce(
        (sum, entry) => sum + entry.totalTimesIncorrect,
        0,
      ),
      incorrectAnswers: incorrectAnswersLog,
    };

    // Export as JSON file
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `incorrect-answers-log-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);

    console.log(`Exported ${incorrectAnswersLog.length} questions with incorrect answers`);

    // REPLACED: alert() with toast
    showSuccess(
      'Mistakes Exported Successfully!',
      `Exported ${incorrectAnswersLog.length} questions with incorrect answers`,
      5000,
    );
  };

  const handleStartQuiz = (chapterId: string) => {
    setCurrentChapterId(chapterId);
    setCurrentQuestionIndex(0);
    setSelectedOptionId(null);
    setIsSubmitted(false);
    setIsReviewSessionActive(false);
    setCurrentReviewQuestion(null);
    // Clear session history
    setSessionHistory([]);
    setCurrentHistoryViewIndex(null);
    setAppState('quiz');
  };

  // Start review session using dynamic approach
  const handleStartReviewSession = () => {
    if (!currentModule) return;

    console.log('=== Starting Refined Anki-style Review Session ===');

    // Set review mode active
    setIsReviewSessionActive(true);
    // Clear session history
    setSessionHistory([]);
    setCurrentHistoryViewIndex(null);

    // Load the first review question
    loadNextReviewQuestion();
  };

  const handleSelectOption = (optionId: string) => {
    if (!isSubmitted) {
      setSelectedOptionId(optionId);
    }
  };

  // NEW: Navigate to question from menu
  const handleNavigateToQuestionFromMenu = (targetQuestionIndex: number) => {
    console.log(`=== Navigating to Question ${targetQuestionIndex + 1} from Menu ===`);

    const currentChapter = getCurrentChapter();
    if (
      !currentChapter ||
      targetQuestionIndex < 0 ||
      targetQuestionIndex >= currentChapter.questions.length
    ) {
      console.error('Invalid question index or chapter not found');
      return;
    }

    const targetQuestion = currentChapter.questions[targetQuestionIndex];
    console.log(`Target question: ${targetQuestion.questionId}`);

    // Search for this question in session history
    const historyEntryIndex = sessionHistory.findIndex(
      (entry) => entry.questionSnapshot.questionId === targetQuestion.questionId,
    );

    if (historyEntryIndex !== -1) {
      // Question exists in session history - navigate to historical view
      console.log(`Found in session history at index ${historyEntryIndex}`);
      setCurrentHistoryViewIndex(historyEntryIndex);
      setIsSubmitted(true);
      setSelectedOptionId(sessionHistory[historyEntryIndex].selectedOptionId);
    } else {
      // Question not in session history - navigate to live question
      console.log('Not found in session history - navigating to live question');
      setCurrentQuestionIndex(targetQuestionIndex);
      setCurrentHistoryViewIndex(null);
      setSelectedOptionId(null);
      setIsSubmitted(false);
    }
  };

  // NEW: Retry Chapter Handler
  const handleRetryChapter = () => {
    if (!currentModule || !currentChapterId || isReviewSessionActive) {
      console.log('Cannot retry chapter - missing module, chapter ID, or in review session');
      return;
    }

    console.log(`=== Retrying Chapter: ${currentChapterId} ===`);

    try {
      // Create a deep copy of the module
      const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;
      const targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId);

      if (targetChapter) {
        // Reset all questions in the chapter
        targetChapter.questions.forEach((question) => {
          question.status = 'not_attempted';
          question.timesAnsweredCorrectly = 0;
          question.timesAnsweredIncorrectly = 0;
          question.historyOfIncorrectSelections = [];
          question.lastSelectedOptionId = undefined;
          question.lastAttemptedAt = undefined;
          question.srsLevel = 0;
          question.nextReviewAt = null;
          question.shownIncorrectOptionIds = [];
        });

        // Recalculate chapter stats
        recalculateChapterStats(targetChapter);

        // Update the module
        setCurrentModule(updatedModule);

        // Reset quiz session state
        setCurrentQuestionIndex(0);
        setSelectedOptionId(null);
        setIsSubmitted(false);
        setSessionHistory([]);
        setCurrentHistoryViewIndex(null);

        showSuccess(
          'Chapter Reset',
          `Chapter "${targetChapter.name}" has been reset. Starting fresh!`,
          4000,
        );

        console.log(`Successfully reset chapter: ${targetChapter.name}`);
      } else {
        console.error('Target chapter not found for retry');
        showError('Retry Failed', 'Chapter not found');
      }
    } catch (error) {
      console.error('Error retrying chapter:', error);
      showError('Retry Failed', 'Failed to reset chapter');
    }
  };

  // NEW: View All Questions Handler
  const handleViewAllQuestions = () => {
    if (!currentModule || !currentChapterId) {
      console.log('Cannot view all questions - missing module or chapter ID');
      return;
    }

    console.log(`=== Viewing All Questions for Chapter: ${currentChapterId} ===`);
    setAppState('all-questions');
  };

  // NEW: Back to Quiz from All Questions View
  const handleBackToQuizFromAllQuestions = () => {
    console.log('=== Returning to Quiz from All Questions View ===');
    setAppState('quiz');
  };

  const handleSubmitAnswer = (displayedOptions: DisplayedOption[]) => {
    if (!selectedOptionId || isSubmitted) return;

    const currentQuestion = getCurrentQuestion();
    if (!currentQuestion || !currentModule) return;

    console.log(`=== Submitting Answer for Question: ${currentQuestion.questionId} ===`);
    console.log(`Selected option: ${selectedOptionId}`);

    const isCorrect = currentQuestion.correctOptionIds.includes(selectedOptionId);
    console.log(`Answer is ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);

    // Create deep copy of module for updates
    const updatedModule = JSON.parse(JSON.stringify(currentModule)) as QuizModule;

    // Find and update the question
    let targetQuestion: QuizQuestion | null = null;
    let targetChapter: QuizChapter | null = null;

    if (isReviewSessionActive && currentReviewQuestion) {
      // Review session - find question in its original chapter
      targetChapter =
        updatedModule.chapters.find((c) => c.id === currentReviewQuestion.chapterId) || null;
      if (targetChapter) {
        const questionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === currentQuestion.questionId,
        );
        if (questionIndex !== -1) {
          targetQuestion = targetChapter.questions[questionIndex];
        }
      }
    } else {
      // Regular quiz - find question in current chapter
      targetChapter = updatedModule.chapters.find((c) => c.id === currentChapterId) || null;
      if (targetChapter) {
        const questionIndex = targetChapter.questions.findIndex(
          (q) => q.questionId === currentQuestion.questionId,
        );
        if (questionIndex !== -1) {
          targetQuestion = targetChapter.questions[questionIndex];
        }
      }
    }

    if (!targetQuestion || !targetChapter) {
      console.error('Could not find target question or chapter for update');
      return;
    }

    // Update question statistics
    targetQuestion.lastSelectedOptionId = selectedOptionId;
    targetQuestion.lastAttemptedAt = new Date().toISOString();

    if (isCorrect) {
      targetQuestion.timesAnsweredCorrectly = (targetQuestion.timesAnsweredCorrectly || 0) + 1;

      // Update SRS level and status
      const newSrsLevel = Math.min((targetQuestion.srsLevel || 0) + 1, 2);
      targetQuestion.srsLevel = newSrsLevel;

      if (newSrsLevel >= 2) {
        targetQuestion.status = 'mastered';
        targetQuestion.nextReviewAt = null;
        console.log(`Question mastered! SRS Level: ${newSrsLevel}`);
      } else {
        targetQuestion.status = 'passed_once';
        // Schedule next review (simplified intervals)
        const intervals = [0, 10 * 60 * 1000, 0]; // 0, 10 minutes, mastered
        const nextReviewTime = new Date(Date.now() + intervals[newSrsLevel]);
        targetQuestion.nextReviewAt = nextReviewTime.toISOString();
        console.log(
          `Correct answer! SRS Level: ${newSrsLevel}, Next review: ${nextReviewTime.toISOString()}`,
        );
      }
    } else {
      targetQuestion.timesAnsweredIncorrectly = (targetQuestion.timesAnsweredIncorrectly || 0) + 1;

      // Track incorrect selection
      if (!targetQuestion.historyOfIncorrectSelections) {
        targetQuestion.historyOfIncorrectSelections = [];
      }
      targetQuestion.historyOfIncorrectSelections.push(selectedOptionId);

      // Track shown incorrect options
      if (!targetQuestion.shownIncorrectOptionIds) {
        targetQuestion.shownIncorrectOptionIds = [];
      }
      displayedOptions.forEach((option) => {
        if (
          !option.isCorrect &&
          !targetQuestion.shownIncorrectOptionIds!.includes(option.optionId)
        ) {
          targetQuestion.shownIncorrectOptionIds!.push(option.optionId);
        }
      });

      // Reset SRS progress
      targetQuestion.srsLevel = 0;
      targetQuestion.status = 'attempted';

      // Schedule for quick retry (30 seconds)
      const nextReviewTime = new Date(Date.now() + 30 * 1000);
      targetQuestion.nextReviewAt = nextReviewTime.toISOString();

      console.log(
        `Incorrect answer! Reset to SRS Level 0, Next review: ${nextReviewTime.toISOString()}`,
      );
    }

    // Recalculate chapter stats
    recalculateChapterStats(targetChapter);

    // Update module state
    setCurrentModule(updatedModule);

    // Add to session history (for regular quiz only, not review sessions)
    if (!isReviewSessionActive) {
      const historyEntry: SessionHistoryEntry = {
        questionSnapshot: JSON.parse(JSON.stringify(currentQuestion)),
        selectedOptionId,
        isCorrect,
        displayedOptions: [...displayedOptions],
        chapterId: currentChapterId,
        isReviewSessionQuestion: false,
      };

      setSessionHistory((prev) => [...prev, historyEntry]);
      console.log(
        `Added to session history: ${currentQuestion.questionId} (${isCorrect ? 'correct' : 'incorrect'})`,
      );
    }

    // Mark as submitted
    setIsSubmitted(true);

    console.log('Answer submission completed successfully');
  };

  const handleNextQuestion = () => {
    if (isReviewSessionActive) {
      // Review session - load next review question
      console.log('=== Moving to Next Review Question ===');
      loadNextReviewQuestion();
    } else {
      // Regular quiz - advance to next question in chapter
      console.log('=== Moving to Next Question in Chapter ===');

      const currentChapter = getCurrentChapter();
      if (!currentChapter) return;

      // Clear history view if active
      setCurrentHistoryViewIndex(null);

      if (currentQuestionIndex < currentChapter.questions.length - 1) {
        setCurrentQuestionIndex(currentQuestionIndex + 1);
        setSelectedOptionId(null);
        setIsSubmitted(false);
      } else {
        // Chapter completed
        setAppState('complete');
      }
    }
  };

  // NEW: Session History Navigation Handlers
  const handleViewPreviousAnswer = () => {
    console.log('=== Viewing Previous Answer ===');

    if (currentHistoryViewIndex !== null) {
      // Currently viewing history - go to previous entry
      if (currentHistoryViewIndex > 0) {
        const newIndex = currentHistoryViewIndex - 1;
        console.log(`Moving to history index: ${newIndex}`);
        setCurrentHistoryViewIndex(newIndex);

        // Update UI state to match historical entry
        const historicalEntry = sessionHistory[newIndex];
        setSelectedOptionId(historicalEntry.selectedOptionId);
        setIsSubmitted(true);
      }
    } else {
      // Currently viewing live question - go to most recent history entry
      if (sessionHistory.length > 0) {
        const mostRecentIndex = sessionHistory.length - 1;
        console.log(`Entering history view at index: ${mostRecentIndex}`);
        setCurrentHistoryViewIndex(mostRecentIndex);

        // Update UI state to match historical entry
        const historicalEntry = sessionHistory[mostRecentIndex];
        setSelectedOptionId(historicalEntry.selectedOptionId);
        setIsSubmitted(true);
      }
    }
  };

  const handleViewNextInHistory = () => {
    console.log('=== Viewing Next in History ===');

    if (currentHistoryViewIndex !== null && currentHistoryViewIndex < sessionHistory.length - 1) {
      const newIndex = currentHistoryViewIndex + 1;
      console.log(`Moving to history index: ${newIndex}`);
      setCurrentHistoryViewIndex(newIndex);

      // Update UI state to match historical entry
      const historicalEntry = sessionHistory[newIndex];
      setSelectedOptionId(historicalEntry.selectedOptionId);
      setIsSubmitted(true);
    }
  };

  const handleBackToDashboard = () => {
    setAppState('dashboard');
    setCurrentChapterId('');
    setCurrentQuestionIndex(0);
    setSelectedOptionId(null);
    setIsSubmitted(false);
    setIsReviewSessionActive(false);
    setCurrentReviewQuestion(null);
    // Clear session history
    setSessionHistory([]);
    setCurrentHistoryViewIndex(null);
    // Clear edit mode
    setIsEditModeActive(false);
    setEditingQuestionData(null);
  };

  const handleExportState = () => {
    if (!currentModule) return;

    const dataStr = JSON.stringify(currentModule, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `quiz-state-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);

    // REPLACED: alert() with toast
    showSuccess(
      'State Exported Successfully!',
      'Your quiz progress has been saved to a file',
      4000,
    );
  };

  // Helper functions
  const getCurrentChapter = (): QuizChapter | null => {
    if (!currentModule) return null;

    if (isReviewSessionActive && currentReviewQuestion) {
      return currentModule.chapters.find((c) => c.id === currentReviewQuestion.chapterId) || null;
    }

    return currentModule.chapters.find((c) => c.id === currentChapterId) || null;
  };

  const getCurrentQuestion = (): QuizQuestion | null => {
    if (isReviewSessionActive && currentReviewQuestion) {
      return currentReviewQuestion.question;
    }

    const chapter = getCurrentChapter();
    if (!chapter || currentQuestionIndex >= chapter.questions.length) return null;

    return chapter.questions[currentQuestionIndex];
  };

  // Render the appropriate component based on app state
  const renderCurrentView = () => {
    switch (appState) {
      case 'welcome':
        return (
          <WelcomeScreen
            onLoadQuiz={handleLoadQuiz}
            onLoadDefaultQuiz={handleLoadDefaultQuiz}
            isLoading={isLoading}
            error={error}
          />
        );

      case 'dashboard':
        return (
          <Dashboard
            module={currentModule!}
            onStartQuiz={handleStartQuiz}
            onStartReviewSession={handleStartReviewSession}
            onExportState={handleExportState}
            onImportState={handleImportState}
            onExportIncorrectAnswers={handleExportIncorrectAnswers}
            onLoadNewModule={handleLoadNewModule}
            reviewQueueCount={reviewQueueCount}
          />
        );

      case 'quiz':
        const currentChapter = getCurrentChapter();
        const currentQuestion = getCurrentQuestion();

        if (!currentChapter || !currentQuestion) {
          return (
            <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-black via-slate-950 to-gray-950">
              <div className="text-xl text-white">Loading question...</div>
            </div>
          );
        }

        return (
          <QuizSession
            chapter={currentChapter}
            question={currentQuestion}
            currentQuestionIndex={currentQuestionIndex}
            totalQuestions={currentChapter.questions.length}
            selectedOptionId={selectedOptionId}
            isSubmitted={isSubmitted}
            isReviewSession={isReviewSessionActive}
            srsProgressCounts={srsProgressCounts || undefined}
            currentModule={currentModule || undefined}
            sessionHistory={sessionHistory}
            currentHistoryViewIndex={currentHistoryViewIndex}
            // Edit Mode Props - Phase 1
            isEditModeActive={isEditModeActive}
            editingQuestionData={editingQuestionData}
            onSetEditMode={handleSetEditMode}
            onSaveQuestion={handleSaveQuestion}
            onDeleteQuestion={handleDeleteQuestion}
            generateUniqueQuestionId={generateUniqueQuestionId}
            generateUniqueOptionId={generateUniqueOptionId}
            onSelectOption={handleSelectOption}
            onSubmitAnswer={handleSubmitAnswer}
            onNextQuestion={handleNextQuestion}
            onBackToDashboard={handleBackToDashboard}
            onExportCurrentQuestionState={handleExportCurrentQuestionState}
            onImportQuestionStateFromFile={handleInitiateImportCurrentQuestionState}
            onRetryChapter={handleRetryChapter}
            onNavigateToQuestion={handleNavigateToQuestionFromMenu}
            onViewPrevious={handleViewPreviousAnswer}
            onViewNextInHistory={handleViewNextInHistory}
            onViewAllQuestions={handleViewAllQuestions}
          />
        );

      case 'complete':
        const completedChapter = getCurrentChapter();
        if (!completedChapter) return null;

        // Calculate results for the completed chapter
        const results = {
          totalQuestions: completedChapter.totalQuestions,
          correctAnswers: completedChapter.correctAnswers,
          incorrectAnswers: completedChapter.totalQuestions - completedChapter.correctAnswers,
          accuracy:
            completedChapter.totalQuestions > 0
              ? Math.round(
                  (completedChapter.correctAnswers / completedChapter.totalQuestions) * 100,
                )
              : 0,
        };

        // Check if there are incorrect answers to export
        const hasIncorrectAnswers = results.incorrectAnswers > 0;

        // Find next chapter
        const currentChapterIndex =
          currentModule?.chapters.findIndex((c) => c.id === completedChapter.id) ?? -1;
        const nextChapter =
          currentModule &&
          currentChapterIndex >= 0 &&
          currentChapterIndex < currentModule.chapters.length - 1
            ? currentModule.chapters[currentChapterIndex + 1]
            : null;

        return (
          <QuizComplete
            chapter={completedChapter}
            results={results}
            onRetryQuiz={handleRetryChapter}
            onBackToDashboard={handleBackToDashboard}
            onExportResults={handleExportState}
            onLoadNewModule={() => setAppState('welcome')}
            onExportIncorrectAnswers={handleExportIncorrectAnswers}
            hasIncorrectAnswers={hasIncorrectAnswers}
            nextChapterId={nextChapter?.id}
            onStartChapterQuiz={handleStartQuiz}
          />
        );

      case 'all-questions':
        const allQuestionsChapter = getCurrentChapter();
        if (!allQuestionsChapter) return null;

        return (
          <AllQuestionsView
            chapter={allQuestionsChapter}
            onBackToQuiz={handleBackToQuizFromAllQuestions}
            onBackToDashboard={handleBackToDashboard}
            onRetryChapter={handleRetryChapter}
            isReviewSession={isReviewSessionActive}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen">
      {renderCurrentView()}

      {/* Toast Container */}
      <ToastContainer toasts={toasts} onRemoveToast={removeToast} />

      {/* Confirmation Modal for Deleting Current Question */}
      <ConfirmationModal
        isOpen={showDeleteCurrentQuestionConfirmation}
        title="Delete Current Question"
        message={`Are you sure you want to delete the current question "${questionToDelete?.questionId}"? This action cannot be undone.`}
        confirmText="Delete Question"
        cancelText="Cancel"
        onConfirm={handleConfirmDeleteCurrentQuestion}
        onCancel={handleCancelDeleteCurrentQuestion}
        variant="danger"
      />

      {/* Confirmation Modal for Overwriting Current Question */}
      <ConfirmationModal
        isOpen={showOverwriteCurrentQuestionConfirmation}
        title="Overwrite Current Question"
        message={`The imported file contains a question with the same ID as the current question. Do you want to overwrite the current question with the imported data?`}
        confirmText="Overwrite"
        cancelText="Cancel"
        onConfirm={handleConfirmOverwriteCurrentQuestion}
        onCancel={handleCancelOverwriteCurrentQuestion}
        variant="warning"
      />
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: app\test\page.tsx
SIZE: 6,100 bytes | LINES: 195
================================================================================
'use client';

import { useState } from 'react';
import { parseMarkdownToQuizModule } from '@/utils/quiz-validation';

// Test data based on your actual formats
const testMarkdown1 = `# MCQ Compact Output

Description: _Fundamentals of Computer Science_

## Chapter 1: Algorithm Fundamentals

<!-- CH_ID: ch_fundamentals_1 -->

**Q1:** What is the primary purpose of algorithm analysis?

<!-- Q_ID: ch_fundamentals_1_q1 -->

**Options:**
- **A1:** To determine the correctness of an algorithm
- **A2:** To measure the efficiency and resource usage of an algorithm
- **A3:** To write the algorithm in a specific programming language

**Correct:** A2

**Explanation:** Algorithm analysis primarily focuses on measuring efficiency and resource usage, including time and space complexity.

---

**Q2:** Which of the following best describes Big O notation?

<!-- Q_ID: ch_fundamentals_1_q2 -->

**Opt:**
- **A1:** It provides the exact running time of an algorithm
- **A2:** It describes the upper bound of an algorithm's growth rate
- **A3:** It only applies to sorting algorithms

**Ans:** A2

**Explanation:** Big O notation describes the upper bound of an algorithm's growth rate as input size approaches infinity.`;

const testMarkdown2 = `# Advanced Algorithms Quiz

Description: _Advanced topics in algorithm design and analysis_

## Chapter 1: Sorting Algorithms

<!-- CH_ID: sorting_algorithms -->

**Q1:** What is the worst-case time complexity of QuickSort?

<!-- Q_ID: sorting_q1 -->

**Options:**
**A1:** O(n log n)
**A2:** O(n²)
**A3:** O(n)

**Correct:** A2

**Explanation:** QuickSort has O(n²) worst-case time complexity when the pivot is always the smallest or largest element.

---

**Q2:** Which sorting algorithm is stable?

<!-- Q_ID: sorting_q2 -->

**Opt:**
**A1:** QuickSort
**A2:** MergeSort
**A3:** HeapSort

**Ans:** A2

**Explanation:** MergeSort is stable because it preserves the relative order of equal elements.`;

export default function TestPage() {
  const [testResults, setTestResults] = useState<string>('');
  const [isRunning, setIsRunning] = useState(false);

  const runTests = () => {
    setIsRunning(true);
    setTestResults('Running tests...\n\n');

    try {
      // Test 1: Format with "Options:" and "Correct:"
      console.log('=== Testing Format 1 ===');
      const result1 = parseMarkdownToQuizModule(testMarkdown1);

      let results = '=== TEST 1: Options/Correct Format ===\n';
      results += `Success: ${result1.success}\n`;
      results += `Errors: ${result1.errors.length}\n`;

      if (result1.success && result1.quizModule) {
        const module = result1.quizModule;
        results += `Module Name: ${module.name}\n`;
        results += `Description: ${module.description}\n`;
        results += `Chapters: ${module.chapters.length}\n`;

        if (module.chapters.length > 0) {
          const chapter = module.chapters[0];
          results += `Chapter ID: ${chapter.id}\n`;
          results += `Chapter Name: ${chapter.name}\n`;
          results += `Questions: ${chapter.questions.length}\n`;

          if (chapter.questions.length > 0) {
            const q1 = chapter.questions[0];
            results += `Q1 ID: ${q1.questionId}\n`;
            results += `Q1 Options: ${q1.options.length}\n`;
            results += `Q1 Correct: ${q1.correctOptionIds.join(', ')}\n`;
          }
        }
      } else {
        results += `Errors: ${result1.errors.join('; ')}\n`;
      }

      results += '\n';

      // Test 2: Format with "Opt:" and "Ans:"
      console.log('=== Testing Format 2 ===');
      const result2 = parseMarkdownToQuizModule(testMarkdown2);

      results += '=== TEST 2: Opt/Ans Format ===\n';
      results += `Success: ${result2.success}\n`;
      results += `Errors: ${result2.errors.length}\n`;

      if (result2.success && result2.quizModule) {
        const module = result2.quizModule;
        results += `Module Name: ${module.name}\n`;
        results += `Description: ${module.description}\n`;
        results += `Chapters: ${module.chapters.length}\n`;

        if (module.chapters.length > 0) {
          const chapter = module.chapters[0];
          results += `Chapter ID: ${chapter.id}\n`;
          results += `Chapter Name: ${chapter.name}\n`;
          results += `Questions: ${chapter.questions.length}\n`;

          if (chapter.questions.length > 0) {
            const q1 = chapter.questions[0];
            results += `Q1 ID: ${q1.questionId}\n`;
            results += `Q1 Options: ${q1.options.length}\n`;
            results += `Q1 Correct: ${q1.correctOptionIds.join(', ')}\n`;
          }
        }
      } else {
        results += `Errors: ${result2.errors.join('; ')}\n`;
      }

      setTestResults(results);
    } catch (error) {
      setTestResults(`Test failed with error: ${error}`);
    } finally {
      setIsRunning(false);
    }
  };

  return (
    <div className="mx-auto max-w-4xl p-6">
      <h1 className="mb-6 text-3xl font-bold">Markdown Parser Tests</h1>

      <button
        onClick={runTests}
        disabled={isRunning}
        className="mb-4 rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700"
      >
        {isRunning ? 'Running Tests...' : 'Run Tests'}
      </button>

      {testResults && (
        <div className="rounded bg-gray-100 p-4">
          <h3 className="mb-2 font-bold">Test Results:</h3>
          <pre className="whitespace-pre-wrap text-sm">{testResults}</pre>
        </div>
      )}

      <div className="mt-8">
        <h2 className="mb-4 text-xl font-bold">Test Data Preview</h2>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div>
            <h3 className="mb-2 font-semibold">Format 1: Options/Correct</h3>
            <pre className="max-h-64 overflow-auto bg-gray-50 p-3 text-xs">{testMarkdown1}</pre>
          </div>
          <div>
            <h3 className="mb-2 font-semibold">Format 2: Opt/Ans</h3>
            <pre className="max-h-64 overflow-auto bg-gray-50 p-3 text-xs">{testMarkdown2}</pre>
          </div>
        </div>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components.json
SIZE: 444 bytes | LINES: 22
================================================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\a11y\AccessibleOptionList.tsx
SIZE: 4,020 bytes | LINES: 140
================================================================================
'use client';

import { useCallback, useEffect, useRef, useState } from 'react';
import { OptionCard } from '@/components/option-card';
import type { DisplayedOption } from '@/types/quiz-types';

interface AccessibleOptionListProps {
  options: DisplayedOption[];
  selectedOptionId: string | null;
  onSelectOption: (optionId: string) => void;
  isSubmitted: boolean;
  disabled?: boolean;
}

export function AccessibleOptionList({
  options,
  selectedOptionId,
  onSelectOption,
  isSubmitted,
  disabled = false,
}: AccessibleOptionListProps) {
  const [focusedIndex, setFocusedIndex] = useState<number>(0);
  const optionRefs = useRef<(HTMLDivElement | null)[]>([]);

  // Update option refs array when options change
  useEffect(() => {
    optionRefs.current = optionRefs.current.slice(0, options.length);
  }, [options.length]);

  // Focus management
  const focusOption = useCallback((index: number) => {
    if (optionRefs.current[index]) {
      optionRefs.current[index]?.focus();
      setFocusedIndex(index);
    }
  }, []);

  // Handle focus events from the wrapper div
  const handleFocus = useCallback((index: number) => {
    setFocusedIndex(index);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = useCallback(
    (event: React.KeyboardEvent) => {
      if (disabled || isSubmitted) return;

      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          const nextIndex = (focusedIndex + 1) % options.length;
          focusOption(nextIndex);
          break;

        case 'ArrowUp':
          event.preventDefault();
          const prevIndex = focusedIndex === 0 ? options.length - 1 : focusedIndex - 1;
          focusOption(prevIndex);
          break;

        case ' ':
        case 'Enter':
          event.preventDefault();
          if (options[focusedIndex]) {
            onSelectOption(options[focusedIndex].optionId);
          }
          break;

        case 'Home':
          event.preventDefault();
          focusOption(0);
          break;

        case 'End':
          event.preventDefault();
          focusOption(options.length - 1);
          break;
      }
    },
    [disabled, isSubmitted, focusedIndex, options, focusOption, onSelectOption],
  );

  // Set initial focus when component mounts
  useEffect(() => {
    if (options.length > 0) {
      focusOption(0);
    }
  }, [options.length, focusOption]);

  // Update focused index when selected option changes
  useEffect(() => {
    const selectedIndex = options.findIndex((option) => option.optionId === selectedOptionId);
    if (selectedIndex !== -1) {
      setFocusedIndex(selectedIndex);
    }
  }, [selectedOptionId, options]);

  return (
    <div
      role="radiogroup"
      aria-label="Answer options"
      onKeyDown={handleKeyDown}
      className="space-y-3"
    >
      {options.map((option, index) => {
        const displayState = {
          isSelected: option.optionId === selectedOptionId,
          showAsCorrect: false,
          showAsIncorrect: false,
        };

        return (
          <div
            key={option.optionId}
            ref={(el) => {
              optionRefs.current[index] = el;
            }}
            role="radio"
            aria-checked={displayState.isSelected}
            tabIndex={index === focusedIndex ? 0 : -1}
            aria-labelledby={`option-text-${option.optionId}`}
            className="rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900"
            onFocus={() => handleFocus(index)}
          >
            <OptionCard
              option={option}
              isSelected={displayState.isSelected}
              showAsCorrect={displayState.showAsCorrect}
              showAsIncorrect={displayState.showAsIncorrect}
              isSubmitted={isSubmitted}
              onSelect={() => onSelectOption(option.optionId)}
              disabled={disabled}
            />
          </div>
        );
      })}
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\a11y\AccessibleQuestionGrid.tsx
SIZE: 7,888 bytes | LINES: 234
================================================================================
'use client';

import { useCallback, useEffect, useRef, useState } from 'react';
import type { QuizQuestion, SessionHistoryEntry } from '@/types/quiz-types';

interface AccessibleQuestionGridProps {
  questions: QuizQuestion[];
  currentQuestionIndex: number;
  sessionHistory: SessionHistoryEntry[];
  currentHistoryViewIndex: number | null;
  onNavigateToQuestion: (questionIndex: number) => void;
  isReviewSession: boolean;
}

export function AccessibleQuestionGrid({
  questions,
  currentQuestionIndex,
  sessionHistory,
  currentHistoryViewIndex,
  onNavigateToQuestion,
  isReviewSession,
}: AccessibleQuestionGridProps) {
  const [focusedIndex, setFocusedIndex] = useState<number>(currentQuestionIndex);
  const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

  // Update button refs array when questions change
  useEffect(() => {
    buttonRefs.current = buttonRefs.current.slice(0, questions.length);
  }, [questions.length]);

  // Focus management
  const focusButton = useCallback((index: number) => {
    if (buttonRefs.current[index]) {
      buttonRefs.current[index]?.focus();
      setFocusedIndex(index);
    }
  }, []);

  // Handle focus events from buttons
  const handleButtonFocus = useCallback((index: number) => {
    setFocusedIndex(index);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = useCallback(
    (event: React.KeyboardEvent) => {
      if (isReviewSession) return;

      switch (event.key) {
        case 'ArrowRight':
          event.preventDefault();
          const nextIndex = (focusedIndex + 1) % questions.length;
          focusButton(nextIndex);
          break;

        case 'ArrowLeft':
          event.preventDefault();
          const prevIndex = focusedIndex === 0 ? questions.length - 1 : focusedIndex - 1;
          focusButton(prevIndex);
          break;

        case 'Home':
          event.preventDefault();
          focusButton(0);
          break;

        case 'End':
          event.preventDefault();
          focusButton(questions.length - 1);
          break;

        case ' ':
        case 'Enter':
          event.preventDefault();
          onNavigateToQuestion(focusedIndex);
          break;
      }
    },
    [isReviewSession, focusedIndex, questions.length, focusButton, onNavigateToQuestion],
  );

  // Handle individual button key events
  const handleButtonKeyDown = useCallback(
    (event: React.KeyboardEvent, index: number) => {
      if (isReviewSession) return;

      switch (event.key) {
        case 'ArrowRight':
          event.preventDefault();
          const nextIndex = (index + 1) % questions.length;
          focusButton(nextIndex);
          break;

        case 'ArrowLeft':
          event.preventDefault();
          const prevIndex = index === 0 ? questions.length - 1 : index - 1;
          focusButton(prevIndex);
          break;

        case 'Home':
          event.preventDefault();
          focusButton(0);
          break;

        case 'End':
          event.preventDefault();
          focusButton(questions.length - 1);
          break;

        case ' ':
        case 'Enter':
          event.preventDefault();
          onNavigateToQuestion(index);
          break;
      }
    },
    [isReviewSession, questions.length, focusButton, onNavigateToQuestion],
  );

  // Set initial focus when component mounts
  useEffect(() => {
    if (questions.length > 0) {
      focusButton(currentQuestionIndex);
    }
  }, [questions.length, currentQuestionIndex, focusButton]);

  // Update focused index when current question changes
  useEffect(() => {
    setFocusedIndex(currentQuestionIndex);
  }, [currentQuestionIndex]);

  // Helper function to find session history entry for a question
  const findHistoryEntryForQuestion = (questionId: string): SessionHistoryEntry | null => {
    return sessionHistory.find((entry) => entry.questionSnapshot.questionId === questionId) || null;
  };

  // Helper function to determine the status and styling for each question box
  const getQuestionBoxStatus = (questionIndex: number) => {
    const question = questions[questionIndex];
    const historyEntry = findHistoryEntryForQuestion(question.questionId);

    // Check if this is the question being viewed in history mode
    const isCurrentHistoricalView =
      currentHistoryViewIndex !== null &&
      historyEntry &&
      sessionHistory[currentHistoryViewIndex]?.questionSnapshot.questionId === question.questionId;

    // Check if this is the current live question (not yet submitted)
    const isCurrentLive =
      questionIndex === currentQuestionIndex && currentHistoryViewIndex === null && !historyEntry;

    // Determine status
    if (isCurrentHistoricalView) {
      return {
        status: 'current-historical',
        isCorrect: historyEntry.isCorrect,
        classes: historyEntry.isCorrect
          ? 'bg-gradient-to-r from-green-900 to-green-800 border-green-600 ring-2 ring-green-400 ring-opacity-50'
          : 'bg-gradient-to-r from-red-900 to-red-800 border-red-600 ring-2 ring-red-400 ring-opacity-50',
      };
    } else if (isCurrentLive) {
      return {
        status: 'current-live',
        classes:
          'bg-gradient-to-r from-blue-900 to-blue-800 border-blue-600 ring-2 ring-blue-400 ring-opacity-50',
      };
    } else if (historyEntry) {
      return {
        status: historyEntry.isCorrect ? 'answered-correct' : 'answered-incorrect',
        isCorrect: historyEntry.isCorrect,
        classes: historyEntry.isCorrect
          ? 'bg-gradient-to-r from-green-950 to-green-900 border-green-700 hover:from-green-900 hover:to-green-800'
          : 'bg-gradient-to-r from-red-950 to-red-900 border-red-700 hover:from-red-900 hover:to-red-800',
      };
    } else {
      return {
        status: 'unanswered',
        classes:
          'bg-gradient-to-r from-slate-800 to-gray-800 border-gray-600 hover:from-slate-700 hover:to-gray-700',
      };
    }
  };

  // Don't render during review sessions
  if (isReviewSession) {
    return null;
  }

  return (
    <div
      role="grid"
      aria-label="Question navigation"
      onKeyDown={handleKeyDown}
      className="space-y-4"
    >
      <div className="flex w-full gap-1">
        {questions.map((question, index) => {
          const boxStatus = getQuestionBoxStatus(index);

          return (
            <button
              key={question.questionId}
              ref={(el) => {
                buttonRefs.current[index] = el;
              }}
              onClick={() => onNavigateToQuestion(index)}
              role="gridcell"
              tabIndex={index === focusedIndex ? 0 : -1}
              className={`${boxStatus.classes} flex h-10 min-w-[2.5rem] flex-1 items-center justify-center whitespace-nowrap rounded-md border-2 px-2 text-sm font-medium text-white transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 active:scale-95`}
              title={`Question ${index + 1}${
                boxStatus.status === 'current-live'
                  ? ' (Current)'
                  : boxStatus.status === 'current-historical'
                    ? ` (Viewing - ${boxStatus.isCorrect ? 'Correct' : 'Incorrect'})`
                    : boxStatus.status === 'answered-correct'
                      ? ' (Correct)'
                      : boxStatus.status === 'answered-incorrect'
                        ? ' (Incorrect)'
                        : ' (Unanswered)'
              }`}
              aria-label={`Navigate to question ${index + 1}`}
              aria-describedby={`question-status-${index}`}
              onFocus={() => handleButtonFocus(index)}
              onKeyDown={(e) => handleButtonKeyDown(e, index)}
            >
              {index + 1}
            </button>
          );
        })}
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\a11y\DashboardWithInlineErrors.tsx
SIZE: 3,314 bytes | LINES: 112
================================================================================
'use client';

import React, { useRef, useCallback } from 'react';
import { Dashboard } from '@/components/dashboard';
import { InlineErrorHandler, useInlineErrors, ErrorMessage } from './InlineErrorHandler';
import { QuizModule } from '@/types/quiz-types';

interface DashboardWithInlineErrorsProps {
  module: QuizModule;
  onStartQuiz: (chapterId: string) => void;
  onStartReviewSession: () => void;
  onLoadNewModule: () => void;
  onExportState: () => void;
  onImportState: (file: File) => Promise<void>;
  onExportIncorrectAnswers: () => void;
  reviewQueueCount: number;
}

function DashboardContent({
  module,
  onStartQuiz,
  onStartReviewSession,
  onLoadNewModule,
  onExportState,
  onImportState,
  onExportIncorrectAnswers,
  reviewQueueCount,
}: DashboardWithInlineErrorsProps) {
  const importFileInputRef = useRef<HTMLInputElement>(null);
  const { setFieldError, clearFieldError, getFieldAriaProps } = useInlineErrors();

  // Enhanced import handler with error handling
  const handleImportState = useCallback(
    async (file: File) => {
      try {
        // Clear any existing errors
        clearFieldError('import-state-file');

        // Call the original import handler
        await onImportState(file);
      } catch (error) {
        // Set error with ARIA attributes
        const errorMessage = error instanceof Error ? error.message : 'Import failed';
        setFieldError('import-state-file', errorMessage);
      }
    },
    [onImportState, setFieldError, clearFieldError],
  );

  // Enhanced file input change handler
  const handleImportFileSelect = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file) {
        handleImportState(file);
      }
      // Reset the input so the same file can be selected again if needed
      if (importFileInputRef.current) {
        importFileInputRef.current.value = '';
      }
    },
    [handleImportState],
  );

  const triggerImportFileInput = useCallback(() => {
    importFileInputRef.current?.click();
  }, []);

  const ariaProps = getFieldAriaProps('import-state-file');

  return (
    <div className="relative">
      {/* Enhanced hidden file input with ARIA error handling */}
      <input
        ref={importFileInputRef}
        type="file"
        accept=".json,application/json"
        onChange={handleImportFileSelect}
        className="hidden"
        {...ariaProps}
        aria-label="Import quiz state file"
      />

      {/* Error message for file input */}
      <ErrorMessage fieldId="import-state-file" />

      {/* Dashboard with enhanced import functionality */}
      <Dashboard
        module={module}
        onStartQuiz={onStartQuiz}
        onStartReviewSession={onStartReviewSession}
        onLoadNewModule={onLoadNewModule}
        onExportState={onExportState}
        onImportState={triggerImportFileInput}
        onExportIncorrectAnswers={onExportIncorrectAnswers}
        reviewQueueCount={reviewQueueCount}
      />
    </div>
  );
}

/**
 * Enhanced Dashboard component with inline error handling and ARIA attributes
 */
export function DashboardWithInlineErrors(props: DashboardWithInlineErrorsProps) {
  return (
    <InlineErrorHandler>
      <DashboardContent {...props} />
    </InlineErrorHandler>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\a11y\InlineErrorHandler.tsx
SIZE: 4,638 bytes | LINES: 193
================================================================================
'use client';

import React, { useState, useCallback, useRef } from 'react';

interface InlineError {
  fieldId: string;
  message: string;
  id: string;
}

interface InlineErrorHandlerProps {
  children: React.ReactNode;
  onFieldError?: (fieldId: string, error: string) => void;
  onFieldClear?: (fieldId: string) => void;
}

interface InlineErrorContextType {
  setFieldError: (fieldId: string, error: string) => void;
  clearFieldError: (fieldId: string) => void;
  getFieldError: (fieldId: string) => InlineError | null;
  getFieldAriaProps: (fieldId: string) => {
    'aria-invalid': boolean;
    'aria-describedby': string | undefined;
  };
}

const InlineErrorContext = React.createContext<InlineErrorContextType | null>(null);

export function useInlineErrors() {
  const context = React.useContext(InlineErrorContext);
  if (!context) {
    throw new Error('useInlineErrors must be used within an InlineErrorHandler');
  }
  return context;
}

/**
 * Inline error handler that provides ARIA-compliant error management
 * for form fields and other interactive elements
 */
export function InlineErrorHandler({
  children,
  onFieldError,
  onFieldClear,
}: InlineErrorHandlerProps) {
  const [errors, setErrors] = useState<Map<string, InlineError>>(new Map());
  const errorIdCounter = useRef(0);

  const generateErrorId = useCallback(() => {
    return `error-${++errorIdCounter.current}`;
  }, []);

  const setFieldError = useCallback(
    (fieldId: string, error: string) => {
      const errorId = generateErrorId();
      const inlineError: InlineError = {
        fieldId,
        message: error,
        id: errorId,
      };

      setErrors((prev) => new Map(prev.set(fieldId, inlineError)));
      onFieldError?.(fieldId, error);
    },
    [generateErrorId, onFieldError],
  );

  const clearFieldError = useCallback(
    (fieldId: string) => {
      setErrors((prev) => {
        const newMap = new Map(prev);
        newMap.delete(fieldId);
        return newMap;
      });
      onFieldClear?.(fieldId);
    },
    [onFieldClear],
  );

  const getFieldError = useCallback(
    (fieldId: string) => {
      return errors.get(fieldId) || null;
    },
    [errors],
  );

  const getFieldAriaProps = useCallback(
    (fieldId: string) => {
      const error = errors.get(fieldId);
      return {
        'aria-invalid': !!error,
        'aria-describedby': error?.id,
      };
    },
    [errors],
  );

  const contextValue: InlineErrorContextType = {
    setFieldError,
    clearFieldError,
    getFieldError,
    getFieldAriaProps,
  };

  return (
    <InlineErrorContext.Provider value={contextValue}>
      {children}

      {/* Render all error messages */}
      {Array.from(errors.values()).map((error) => (
        <div
          key={error.id}
          id={error.id}
          role="alert"
          className="sr-only"
          aria-live="polite"
          aria-atomic="true"
        >
          {error.message}
        </div>
      ))}
    </InlineErrorContext.Provider>
  );
}

/**
 * Hook to handle file input errors with ARIA attributes
 */
export function useFileInputWithErrors(
  fieldId: string,
  onFileSelect: (file: File) => Promise<void>,
) {
  const { setFieldError, clearFieldError, getFieldAriaProps } = useInlineErrors();
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = useCallback(
    async (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (!file) return;

      try {
        // Clear any existing errors
        clearFieldError(fieldId);

        // Call the original file handler
        await onFileSelect(file);
      } catch (error) {
        // Set error with ARIA attributes
        const errorMessage = error instanceof Error ? error.message : 'File upload failed';
        setFieldError(fieldId, errorMessage);
      }
    },
    [fieldId, onFileSelect, setFieldError, clearFieldError],
  );

  const ariaProps = getFieldAriaProps(fieldId);

  return {
    fileInputRef,
    handleFileChange,
    ariaProps,
  };
}

/**
 * Component to render visible error messages
 */
interface ErrorMessageProps {
  fieldId: string;
  className?: string;
}

export function ErrorMessage({
  fieldId,
  className = 'text-red-400 text-sm mt-1',
}: ErrorMessageProps) {
  const { getFieldError } = useInlineErrors();
  const error = getFieldError(fieldId);

  if (!error) return null;

  return (
    <div
      id={error.id} // Use the same ID that's referenced in aria-describedby
      role="alert"
      className={className}
      aria-live="polite"
    >
      {error.message}
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\a11y\ScreenReaderAnnouncer.tsx
SIZE: 2,075 bytes | LINES: 82
================================================================================
'use client';

import {
  createContext,
  useContext,
  useState,
  useCallback,
  useEffect,
  useRef,
  ReactNode,
} from 'react';

interface AnnouncerContextType {
  announce: (message: string) => void;
  announcement: string | null;
}

const AnnouncerContext = createContext<AnnouncerContextType | null>(null);

export function useAnnouncer() {
  const context = useContext(AnnouncerContext);
  if (!context) {
    throw new Error('useAnnouncer must be used within a ScreenReaderAnnouncer');
  }
  return context;
}

interface ScreenReaderAnnouncerProps {
  children: ReactNode;
}

/**
 * Screen reader announcer provider that manages aria-live announcements
 * Provides a polite live region for screen readers and visible status for inversion safety
 */
export function ScreenReaderAnnouncer({ children }: ScreenReaderAnnouncerProps) {
  const [announcement, setAnnouncement] = useState<string | null>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const announce = useCallback((message: string) => {
    setAnnouncement(message);

    // Clear any existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Clear the announcement after a short delay to allow for new announcements
    timeoutRef.current = setTimeout(() => {
      setAnnouncement(null);
      timeoutRef.current = null;
    }, 100);
  }, []);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return (
    <AnnouncerContext.Provider value={{ announce, announcement }}>
      {children}

      {/* Screen reader live region */}
      <div aria-live="polite" aria-atomic="true" className="sr-only" role="status">
        {announcement}
      </div>

      {/* Visible status for inversion safety */}
      {announcement && (
        <div className="fixed right-4 top-4 z-50 rounded bg-blue-600 px-4 py-2 text-white shadow-lg">
          {announcement}
        </div>
      )}
    </AnnouncerContext.Provider>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\all-questions-view.tsx
SIZE: 22,681 bytes | LINES: 598
================================================================================
'use client';
import { useState, useEffect, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { OptionCard } from './option-card';
import { ProgressBar } from './progress-bar';
import {
  ArrowLeft,
  CheckCircle,
  XCircle,
  Clock,
  Eye,
  EyeOff,
  RotateCcw,
  Home,
  Brain,
} from 'lucide-react';
import type { QuizChapter, QuizQuestion, DisplayedOption } from '@/types/quiz-types';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { CircularProgress } from '@/components/ui/circular-progress';

interface AllQuestionsViewProps {
  chapter: QuizChapter;
  onBackToQuiz: () => void;
  onBackToDashboard: () => void;
  onRetryChapter: () => void;
  isReviewSession?: boolean;
}

interface QuestionState {
  selectedOptionId: string | null;
  isSubmitted: boolean;
  isCorrect: boolean | null;
  displayedOptions: DisplayedOption[];
}

export function AllQuestionsView({
  chapter,
  onBackToQuiz,
  onBackToDashboard,
  onRetryChapter,
  isReviewSession = false,
}: AllQuestionsViewProps) {
  // State for each question's answers and submission status
  const [questionStates, setQuestionStates] = useState<Record<string, QuestionState>>({});

  // Toggle for showing/hiding answers
  const [showAnswers, setShowAnswers] = useState(false);

  // Initialize question states and generate displayed options for each question
  useEffect(() => {
    const initialStates: Record<string, QuestionState> = {};

    chapter.questions.forEach((question) => {
      // Generate displayed options for each question (similar to quiz session logic)
      const displayedOptions = generateDisplayedOptionsForQuestion(question);

      initialStates[question.questionId] = {
        selectedOptionId: null,
        isSubmitted: false,
        isCorrect: null,
        displayedOptions,
      };
    });

    setQuestionStates(initialStates);
  }, [chapter.questions]);

  // Generate displayed options for a question (simplified version of quiz logic)
  const generateDisplayedOptionsForQuestion = (question: QuizQuestion): DisplayedOption[] => {
    const maxDisplayOptions = 5;
    const correctOptions = question.options.filter((opt) =>
      question.correctOptionIds.includes(opt.optionId),
    );
    const incorrectOptions = question.options.filter(
      (opt) => !question.correctOptionIds.includes(opt.optionId),
    );

    const selectedOptions: DisplayedOption[] = [];

    // Add at least one correct option
    if (correctOptions.length > 0) {
      const correctIndex = question.srsLevel ? question.srsLevel % correctOptions.length : 0;
      const selectedCorrectOption = correctOptions[correctIndex] || correctOptions[0];
      selectedOptions.push({
        ...selectedCorrectOption,
        isCorrect: true,
      });
    }

    // Fill remaining slots with incorrect options
    const remainingSlots = maxDisplayOptions - selectedOptions.length;
    const shuffledIncorrect = [...incorrectOptions].sort(() => Math.random() - 0.5);

    for (let i = 0; i < Math.min(remainingSlots, shuffledIncorrect.length); i++) {
      selectedOptions.push({
        ...shuffledIncorrect[i],
        isCorrect: false,
      });
    }

    // Add more correct options if we have space
    const remainingSlotsAfterIncorrect = maxDisplayOptions - selectedOptions.length;
    const remainingCorrect = correctOptions.filter(
      (opt) => !selectedOptions.some((selected) => selected.optionId === opt.optionId),
    );

    for (let i = 0; i < Math.min(remainingSlotsAfterIncorrect, remainingCorrect.length); i++) {
      selectedOptions.push({
        ...remainingCorrect[i],
        isCorrect: true,
      });
    }

    // Shuffle final options
    return selectedOptions.sort(() => Math.random() - 0.5);
  };

  // Calculate real-time score percentage
  const scoreData = useMemo(() => {
    const submittedQuestions = Object.values(questionStates).filter((state) => state.isSubmitted);
    const correctAnswers = submittedQuestions.filter((state) => state.isCorrect).length;
    const totalQuestions = chapter.questions.length;
    const answeredQuestions = submittedQuestions.length;

    const scorePercentage =
      totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
    const progressPercentage =
      totalQuestions > 0 ? Math.round((answeredQuestions / totalQuestions) * 100) : 0;

    return {
      correctAnswers,
      totalQuestions,
      answeredQuestions,
      scorePercentage,
      progressPercentage,
    };
  }, [questionStates, chapter.questions.length]);

  // Handle option selection for a specific question
  const handleSelectOption = (questionId: string, optionId: string) => {
    setQuestionStates((prev) => ({
      ...prev,
      [questionId]: {
        ...prev[questionId],
        selectedOptionId: optionId,
      },
    }));
  };

  // Handle answer submission for a specific question
  const handleSubmitAnswer = (questionId: string) => {
    const questionState = questionStates[questionId];
    if (!questionState?.selectedOptionId) return;

    const question = chapter.questions.find((q) => q.questionId === questionId);
    if (!question) return;

    const isCorrect = question.correctOptionIds.includes(questionState.selectedOptionId);

    setQuestionStates((prev) => ({
      ...prev,
      [questionId]: {
        ...prev[questionId],
        isSubmitted: true,
        isCorrect,
      },
    }));
  };

  // Get option display state for feedback
  const getOptionDisplayState = (questionId: string, option: DisplayedOption) => {
    const questionState = questionStates[questionId];
    const question = chapter.questions.find((q) => q.questionId === questionId);

    if (!questionState || !question) {
      return {
        isSelected: false,
        showAsCorrect: false,
        showAsIncorrect: false,
      };
    }

    if (!questionState.isSubmitted && !showAnswers) {
      return {
        isSelected: questionState.selectedOptionId === option.optionId,
        showAsCorrect: false,
        showAsIncorrect: false,
      };
    }

    // Show answers mode or submitted state
    const isSelected = questionState.selectedOptionId === option.optionId;
    const isCorrectOption = question.correctOptionIds.includes(option.optionId);
    const selectedWasCorrect = questionState.isCorrect;

    if (showAnswers) {
      // In show answers mode, highlight all correct options
      return {
        isSelected,
        showAsCorrect: isCorrectOption,
        showAsIncorrect: isSelected && !isCorrectOption,
      };
    }

    // Normal submitted state logic
    if (selectedWasCorrect) {
      return {
        isSelected,
        showAsCorrect: isSelected && isCorrectOption,
        showAsIncorrect: false,
      };
    } else {
      return {
        isSelected,
        showAsCorrect: !isSelected && isCorrectOption,
        showAsIncorrect: isSelected && !isCorrectOption,
      };
    }
  };

  // Process explanation text to replace option IDs with option text
  const processExplanationText = (question: QuizQuestion, questionId: string): string => {
    let processedText = question.explanationText;
    const questionState = questionStates[questionId];

    // Replace option IDs in <code> tags
    processedText = processedText.replace(/<code>(.*?)<\/code>/g, (match, optionId) => {
      const option = question.options.find((opt) => opt.optionId === optionId);
      if (option) {
        return `<code>${option.optionText}</code>`;
      }
      return match;
    });

    // Replace bare option IDs with option text
    question.options.forEach((option) => {
      const optionIdPattern = new RegExp(
        `\\b${option.optionId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`,
        'g',
      );

      processedText = processedText.replace(optionIdPattern, (match) => {
        const isSelectedOption = questionState?.selectedOptionId === option.optionId;

        if (isSelectedOption) {
          return `<strong class="text-blue-300">"${option.optionText}"</strong>`;
        } else {
          return `"${option.optionText}"`;
        }
      });
    });

    return processedText;
  };

  // Reset all answers
  const handleResetAllAnswers = () => {
    const resetStates: Record<string, QuestionState> = {};

    chapter.questions.forEach((question) => {
      resetStates[question.questionId] = {
        selectedOptionId: null,
        isSubmitted: false,
        isCorrect: null,
        displayedOptions: questionStates[question.questionId]?.displayedOptions || [],
      };
    });

    setQuestionStates(resetStates);
    setShowAnswers(false);
  };

  // Enhanced chapter name parsing
  const parseChapterName = (name: string) => {
    const chapterMatch = name.match(/^(Chapter\s+\d+):\s*(.*)$/i);

    if (chapterMatch) {
      return {
        chapterNumber: chapterMatch[1],
        chapterTitle: chapterMatch[2].trim(),
        hasChapterNumber: true,
      };
    }

    return {
      chapterNumber: '',
      chapterTitle: name,
      hasChapterNumber: false,
    };
  };

  const headerInfo = parseChapterName(chapter.name);

  return (
    <div className="min-h-screen bg-gradient-to-br from-black via-slate-950 to-gray-950">
      {/* Fixed Progress and Score Bar */}
      <div className="sticky top-0 z-50 border-b border-slate-700 bg-gradient-to-r from-slate-900/95 to-slate-800/95 shadow-lg backdrop-blur-md">
        <div className="mx-auto max-w-6xl px-4 py-3">
          <div className="flex items-center gap-4">
            {/* Progress Section */}
            <div className="flex flex-1 items-center gap-3">
              <Clock className="h-5 w-5 flex-shrink-0 text-blue-300" />
              <span className="min-w-[3rem] whitespace-nowrap text-right text-sm font-medium text-blue-300">
                {scoreData.progressPercentage}%
              </span>
              <ProgressBar
                current={scoreData.answeredQuestions}
                total={scoreData.totalQuestions}
                variant="default"
                showText={false}
                showPercentage={false}
                className="h-2 flex-1"
              />
            </div>

            {/* Score Section */}
            <div className="flex items-center gap-3">
              <Brain className="h-5 w-5 flex-shrink-0 text-green-300" />
              <span className="whitespace-nowrap text-sm font-medium text-green-300">Score:</span>
              <CircularProgress
                value={scoreData.scorePercentage}
                size={32}
                className="text-green-400"
              />
            </div>
          </div>
        </div>
      </div>

      <div className="p-4 pt-8 sm:pt-12">
        <div className="mx-auto max-w-6xl space-y-6">
          {/* Header */}
          <div className="mb-8 flex flex-col gap-4 lg:flex-row lg:items-start lg:justify-between">
            <div className="min-w-0 flex-1">
              <div className="mb-2 flex items-start gap-3">
                <div className="min-w-0 flex-1">
                  {isReviewSession ? (
                    <div>
                      <h1 className="hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                        Review Session - All Questions
                      </h1>
                      <div className="mt-2">
                        {headerInfo.hasChapterNumber ? (
                          <div>
                            <div className="break-words text-lg font-medium text-orange-300">
                              {headerInfo.chapterNumber}
                            </div>
                            <div className="mt-1 break-words text-xl font-medium leading-tight text-orange-200">
                              {headerInfo.chapterTitle}
                            </div>
                          </div>
                        ) : (
                          <p className="mt-1 break-words text-lg font-medium text-orange-300">
                            {headerInfo.chapterTitle}
                          </p>
                        )}
                      </div>
                    </div>
                  ) : (
                    <div>
                      {headerInfo.hasChapterNumber ? (
                        <div>
                          <div className="hyphens-auto break-words text-xl font-semibold text-blue-300">
                            {headerInfo.chapterNumber} - All Questions
                          </div>
                          <h1 className="mt-1 hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                            {headerInfo.chapterTitle}
                          </h1>
                        </div>
                      ) : (
                        <h1 className="hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                          {chapter.name} - All Questions
                        </h1>
                      )}
                    </div>
                  )}
                </div>
              </div>
              <p className="break-words text-base text-gray-400">
                Complete overview of all {chapter.questions.length} questions
              </p>
            </div>

            <TooltipProvider>
              <div className="flex gap-2">
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      onClick={handleResetAllAnswers}
                      variant="outline"
                      size="sm"
                      className="h-10 w-10 border-orange-700 bg-orange-900/40 p-0 text-orange-200 transition-all duration-200 hover:border-orange-600 hover:bg-orange-800/50 hover:text-white"
                    >
                      <RotateCcw className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Reset All Answers</p>
                  </TooltipContent>
                </Tooltip>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      onClick={onBackToDashboard}
                      variant="outline"
                      size="sm"
                      className="h-10 w-10 border-gray-700 bg-gray-900/70 p-0 text-gray-200 transition-all duration-200 hover:border-gray-600 hover:bg-gray-800 hover:text-white"
                    >
                      <Home className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Return to Dashboard</p>
                  </TooltipContent>
                </Tooltip>
              </div>
            </TooltipProvider>
          </div>

          {/* Controls */}
          <div className="flex flex-col items-stretch gap-4 sm:flex-row sm:items-center sm:justify-between">
            <Button
              onClick={onBackToQuiz}
              variant="outline"
              className="border-gray-700 bg-gray-900/40 text-gray-200 transition-all duration-200 hover:border-gray-600 hover:bg-gray-800/50 hover:text-white"
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Back to Quiz Navigation
            </Button>

            <div className="flex gap-2">
              <Button
                onClick={() => setShowAnswers(!showAnswers)}
                variant="outline"
                className={`transition-all duration-200 ${
                  showAnswers
                    ? 'border-yellow-600 bg-yellow-900/50 text-yellow-200 hover:bg-yellow-800/60'
                    : 'border-gray-700 bg-gray-900/40 text-gray-200 hover:bg-gray-800/50'
                }`}
              >
                {showAnswers ? (
                  <>
                    <EyeOff className="mr-2 h-4 w-4" />
                    Hide Answers
                  </>
                ) : (
                  <>
                    <Eye className="mr-2 h-4 w-4" />
                    Show All Answers
                  </>
                )}
              </Button>
            </div>
          </div>

          {/* All Questions */}
          <div className="space-y-8">
            {chapter.questions.map((question, index) => {
              const questionState = questionStates[question.questionId];
              const isSubmitted = questionState?.isSubmitted || showAnswers;

              return (
                <Card
                  key={question.questionId}
                  className="border-slate-700 bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 shadow-lg backdrop-blur-sm"
                >
                  <CardHeader>
                    <CardTitle className="flex items-center gap-3 break-words text-lg text-white">
                      <span className="font-mono text-base text-blue-400">Q{index + 1}</span>
                      {questionState?.isSubmitted && (
                        <div className="flex items-center gap-1">
                          {questionState.isCorrect ? (
                            <CheckCircle className="h-5 w-5 text-green-400" />
                          ) : (
                            <XCircle className="h-5 w-5 text-red-400" />
                          )}
                          <span
                            className={`text-sm font-medium ${
                              questionState.isCorrect ? 'text-green-400' : 'text-red-400'
                            }`}
                          >
                            {questionState.isCorrect ? 'Correct' : 'Incorrect'}
                          </span>
                        </div>
                      )}
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-6">
                    {/* Question Text */}
                    <div className="prose prose-invert max-w-none">
                      <MarkdownRenderer
                        markdown={question.questionText}
                        className="break-words text-lg leading-relaxed text-white"
                      />
                    </div>

                    {/* Options */}
                    <div className="space-y-3">
                      <h4 className="break-words text-base font-semibold text-white">
                        Choose your answer:
                      </h4>
                      <div className="space-y-2">
                        {questionState?.displayedOptions.map((option) => {
                          const displayState = getOptionDisplayState(question.questionId, option);
                          return (
                            <OptionCard
                              key={option.optionId}
                              option={option}
                              isSelected={displayState.isSelected}
                              showAsCorrect={displayState.showAsCorrect}
                              showAsIncorrect={displayState.showAsIncorrect}
                              isSubmitted={isSubmitted}
                              onSelect={() =>
                                handleSelectOption(question.questionId, option.optionId)
                              }
                              disabled={isSubmitted}
                            />
                          );
                        })}
                      </div>
                    </div>

                    {/* Submit Button */}
                    {!isSubmitted && !showAnswers && (
                      <div className="flex justify-end">
                        <Button
                          onClick={() => handleSubmitAnswer(question.questionId)}
                          disabled={!questionState?.selectedOptionId}
                          className="bg-blue-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-blue-800 active:bg-blue-900"
                        >
                          Submit Answer
                        </Button>
                      </div>
                    )}

                    {/* Explanation */}
                    {isSubmitted && (
                      <Card className="border-slate-700 bg-gradient-to-r from-slate-900 to-slate-950 backdrop-blur-sm">
                        <CardHeader>
                          <CardTitle className="text-base text-slate-200">Explanation</CardTitle>
                        </CardHeader>
                        <CardContent>
                          <div className="prose prose-invert max-w-none">
                            <MarkdownRenderer
                              markdown={processExplanationText(question, question.questionId)}
                              className="break-words text-sm leading-relaxed text-white"
                            />
                          </div>
                        </CardContent>
                      </Card>
                    )}
                  </CardContent>
                </Card>
              );
            })}
          </div>

          {/* Bottom Actions */}
          <div className="flex flex-col items-stretch gap-4 border-t border-slate-700 pt-8 sm:flex-row sm:items-center sm:justify-between">
            <Button
              onClick={onBackToQuiz}
              variant="outline"
              className="border-gray-700 bg-gray-900/40 text-gray-200 transition-all duration-200 hover:border-gray-600 hover:bg-gray-800/50 hover:text-white"
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Back to Quiz Navigation
            </Button>

            <div className="flex gap-2">
              {!isReviewSession && (
                <Button
                  onClick={onRetryChapter}
                  variant="outline"
                  className="border-orange-700 bg-orange-900/40 text-orange-200 transition-all duration-200 hover:border-orange-600 hover:bg-orange-800/50 hover:text-white"
                >
                  <RotateCcw className="mr-2 h-4 w-4" />
                  Retry Chapter
                </Button>
              )}

              <Button
                onClick={onBackToDashboard}
                className="bg-green-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-green-800 active:bg-green-900"
              >
                <Home className="mr-2 h-4 w-4" />
                Back to Dashboard
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\chapter-card.tsx
SIZE: 4,729 bytes | LINES: 124
================================================================================
'use client';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ProgressBar } from './progress-bar';
import { BookOpen, CheckCircle, PlayCircle } from 'lucide-react';

interface ChapterCardProps {
  chapter: {
    id: string;
    name: string;
    description?: string;
    totalQuestions: number;
    answeredQuestions: number;
    correctAnswers: number;
    isCompleted: boolean;
  };
  onStartQuiz: (chapterId: string) => void;
}

export function ChapterCard({ chapter, onStartQuiz }: ChapterCardProps) {
  const accuracy =
    chapter.answeredQuestions > 0
      ? Math.round((chapter.correctAnswers / chapter.answeredQuestions) * 100)
      : 0;

  const getButtonText = () => {
    if (chapter.isCompleted) return 'Review Quiz';
    if (chapter.answeredQuestions > 0) return 'Continue Quiz';
    return 'Start Quiz';
  };

  const getButtonIcon = () => {
    if (chapter.isCompleted) return <CheckCircle className="h-4 w-4" />;
    return <PlayCircle className="h-4 w-4" />;
  };

  // Parse chapter name to separate prefix from main title
  const parseChapterName = (name: string) => {
    const nameParts = name.split(/:\s*(.*)/); // Splits on the first ": "
    const prefix = nameParts.length > 1 ? nameParts[0] + ':' : '';
    const mainTitle = nameParts.length > 1 ? nameParts[1] : name;
    return { prefix, mainTitle };
  };

  const { prefix, mainTitle } = parseChapterName(chapter.name);

  return (
    <Card
      className={`flex h-full flex-col bg-gradient-to-r shadow-sm backdrop-blur-sm transition-all duration-200 hover:border-gray-700 hover:shadow-md active:scale-[0.98] ${
        chapter.isCompleted
          ? 'border-green-700/70 from-slate-900 to-green-950'
          : 'border-gray-800 from-slate-950 to-gray-950 hover:from-slate-900 hover:to-gray-900'
      } `}
    >
      <CardHeader className="flex-shrink-0 pb-3">
        <div className="flex items-start justify-between gap-2">
          <div className="min-w-0 flex-1">
            <CardTitle className="line-clamp-2 hyphens-auto break-words text-lg leading-tight">
              {prefix && (
                <span className="mr-1 font-medium text-gray-400 opacity-80">{prefix}</span>
              )}
              <span className="font-semibold text-white">{mainTitle}</span>
            </CardTitle>
          </div>
          <div className="flex-shrink-0">
            <BookOpen className="h-5 w-5 text-gray-500" />
          </div>
        </div>
        {chapter.description && (
          <p className="mt-2 line-clamp-3 hyphens-auto break-words text-xs leading-relaxed text-gray-400">
            {chapter.description}
          </p>
        )}
      </CardHeader>

      <CardContent className="flex flex-1 flex-col space-y-4">
        {/* Flexible content area that pushes progress section to bottom */}
        <div className="flex-1" />

        {/* Fixed progress section at bottom */}
        <div className="space-y-3">
          {/* Progress bar with consistent positioning */}
          <div>
            <ProgressBar
              current={chapter.answeredQuestions}
              total={chapter.totalQuestions}
              variant={chapter.isCompleted ? 'success' : 'default'}
              compact={true}
              showPercentage={true}
            />
          </div>

          {/* Progress info and accuracy in aligned container */}
          <div className="flex min-h-[1.25rem] items-center justify-between text-sm">
            <span className="whitespace-nowrap text-gray-400">
              {chapter.answeredQuestions} of {chapter.totalQuestions} questions completed
            </span>
            {chapter.answeredQuestions > 0 ? (
              <span className="ml-2 whitespace-nowrap text-gray-300">
                Accuracy:{' '}
                <span className={accuracy >= 70 ? 'text-green-400' : 'text-yellow-400'}>
                  {accuracy}%
                </span>
              </span>
            ) : (
              <span className="ml-2 whitespace-nowrap text-transparent">Accuracy: 0%</span>
            )}
          </div>

          {/* Button with consistent positioning */}
          <Button
            onClick={() => onStartQuiz(chapter.id)}
            className="w-full bg-blue-700 text-white shadow-sm transition-all duration-200 hover:bg-blue-800 focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 active:bg-blue-900"
            size="sm"
          >
            {getButtonIcon()}
            <span className="ml-1 truncate">{getButtonText()}</span>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\confirmation-modal-radix.tsx
SIZE: 3,343 bytes | LINES: 109
================================================================================
'use client';

import { Button } from '@/components/ui/button';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { AlertTriangle, Info, AlertCircle } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';

interface ConfirmationModalProps {
  isOpen: boolean;
  title: string;
  message: string;
  questionPreview?: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
  onConfirm: () => void;
  onCancel: () => void;
}

export function ConfirmationModal({
  isOpen,
  title,
  message,
  questionPreview,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'info',
  onConfirm,
  onCancel,
}: ConfirmationModalProps) {
  const getVariantStyles = () => {
    switch (variant) {
      case 'danger':
        return {
          icon: <AlertCircle className="h-6 w-6 text-red-400" />,
          confirmBg: 'bg-red-700 hover:bg-red-800 active:bg-red-900',
          confirmRing: 'focus-visible:ring-red-500',
        };
      case 'warning':
        return {
          icon: <AlertTriangle className="h-6 w-6 text-yellow-400" />,
          confirmBg: 'bg-yellow-700 hover:bg-yellow-800 active:bg-yellow-900',
          confirmRing: 'focus-visible:ring-yellow-500',
        };
      case 'info':
      default:
        return {
          icon: <Info className="h-6 w-6 text-blue-400" />,
          confirmBg: 'bg-blue-700 hover:bg-blue-800 active:bg-blue-900',
          confirmRing: 'focus-visible:ring-blue-500',
        };
    }
  };

  const styles = getVariantStyles();

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onCancel()}>
      <DialogContent className="max-w-2xl border-blue-700 bg-gradient-to-r from-blue-950 to-blue-900 text-white">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-3 text-xl text-white">
            {styles.icon}
            {title}
          </DialogTitle>
          <DialogDescription className="text-gray-300">
            <MarkdownRenderer
              markdown={message}
              className="break-words leading-relaxed text-white"
            />
          </DialogDescription>
        </DialogHeader>

        {questionPreview && (
          <div className="rounded-lg border border-gray-700 bg-gray-800/50 p-4">
            <div className="mb-2 text-sm font-medium text-gray-300">Question Preview:</div>
            <MarkdownRenderer
              markdown={questionPreview}
              className="break-words text-sm leading-relaxed text-gray-200"
            />
          </div>
        )}

        <DialogFooter className="gap-3">
          <Button
            variant="outline"
            onClick={onCancel}
            className="border-gray-700 bg-gray-900/70 text-gray-200 hover:border-gray-600 hover:bg-gray-800 hover:text-white"
          >
            {cancelText}
          </Button>
          <Button
            onClick={onConfirm}
            className={`${styles.confirmBg} text-white transition-all duration-200 ${styles.confirmRing} focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900`}
          >
            {confirmText}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\dashboard.tsx
SIZE: 10,838 bytes | LINES: 263
================================================================================
'use client';
import { useRef } from 'react';
import type React from 'react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ChapterCard } from './chapter-card';
import { ProgressBar } from './progress-bar';
import {
  Upload,
  Download,
  RotateCcw,
  Clock,
  FileText,
  BookOpen,
  HelpCircle,
  CheckCircle,
  TrendingUp,
} from 'lucide-react';
import type { QuizModule } from '@/types/quiz-types';

interface DashboardProps {
  module: QuizModule;
  onStartQuiz: (chapterId: string) => void;
  onStartReviewSession: () => void;
  onLoadNewModule: () => void;
  onExportState: () => void;
  onImportState: (file: File) => void;
  onExportIncorrectAnswers: () => void;
  reviewQueueCount: number;
}

export function Dashboard({
  module,
  onStartQuiz,
  onStartReviewSession,
  onLoadNewModule,
  onExportState,
  onImportState,
  onExportIncorrectAnswers,
  reviewQueueCount,
}: DashboardProps) {
  const importFileInputRef = useRef<HTMLInputElement>(null);

  const totalQuestions = module.chapters.reduce((sum, chapter) => sum + chapter.totalQuestions, 0);
  const totalAnswered = module.chapters.reduce(
    (sum, chapter) => sum + chapter.answeredQuestions,
    0,
  );
  const totalCorrect = module.chapters.reduce((sum, chapter) => sum + chapter.correctAnswers, 0);
  const overallAccuracy = totalAnswered > 0 ? Math.round((totalCorrect / totalAnswered) * 100) : 0;

  const hasIncorrectAnswers = module.chapters.some((chapter) =>
    chapter.questions.some((question) => (question.timesAnsweredIncorrectly || 0) > 0),
  );

  const handleImportFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      console.log('Import file selected:', file.name, 'Type:', file.type, 'Size:', file.size);
      onImportState(file);
    }
    if (importFileInputRef.current) {
      importFileInputRef.current.value = '';
    }
  };

  const triggerImportFileInput = () => {
    importFileInputRef.current?.click();
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-black via-slate-950 to-gray-950 p-4">
      <div className="mx-auto max-w-7xl space-y-6">
        {/* Header - Improved responsive layout */}
        <div className="flex flex-col gap-4 lg:flex-row lg:items-start lg:justify-between">
          <div className="min-w-0 flex-1">
            <h1 className="hyphens-auto break-words text-3xl font-extrabold leading-tight text-white">
              {module.name}
            </h1>
            {module.description && (
              <p className="mt-2 hyphens-auto break-words text-sm leading-relaxed text-gray-300">
                {module.description}
              </p>
            )}
          </div>

          {/* Action buttons - Improved responsive layout */}
          <div className="flex flex-wrap gap-2 lg:flex-shrink-0">
            <input
              ref={importFileInputRef}
              type="file"
              accept=".json,application/json"
              onChange={handleImportFileSelect}
              className="hidden"
            />

            <Button
              onClick={triggerImportFileInput}
              variant="outline"
              size="sm"
              className="whitespace-nowrap border-blue-700 bg-blue-900/40 text-blue-200 shadow-sm transition-all duration-200 hover:border-blue-600 hover:bg-blue-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-blue-500 active:bg-blue-800/70"
            >
              <Upload className="mr-2 h-4 w-4" />
              Import State
            </Button>
            <Button
              onClick={onExportState}
              variant="outline"
              size="sm"
              className="whitespace-nowrap border-green-700 bg-green-900/40 text-green-200 shadow-sm transition-all duration-200 hover:border-green-600 hover:bg-green-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-green-500 active:bg-green-800/70"
            >
              <Download className="mr-2 h-4 w-4" />
              Export State
            </Button>
            <Button
              onClick={onExportIncorrectAnswers}
              disabled={!hasIncorrectAnswers}
              variant="outline"
              size="sm"
              className="whitespace-nowrap border-red-700 bg-red-900/40 text-red-200 shadow-sm transition-all duration-200 hover:border-red-600 hover:bg-red-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-red-500 active:bg-red-800/70 disabled:cursor-not-allowed disabled:opacity-50"
              title={
                hasIncorrectAnswers
                  ? 'Export detailed log of incorrect answers'
                  : 'No incorrect answers to export'
              }
            >
              <FileText className="mr-2 h-4 w-4" />
              Export Mistakes
            </Button>
            <Button
              onClick={onLoadNewModule}
              variant="outline"
              size="sm"
              className="whitespace-nowrap border-purple-700 bg-purple-900/40 text-purple-200 shadow-sm transition-all duration-200 hover:border-purple-600 hover:bg-purple-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-purple-500 active:bg-purple-800/70"
            >
              <RotateCcw className="mr-2 h-4 w-4" />
              Load New Module
            </Button>
          </div>
        </div>

        {/* Review Session Card */}
        {reviewQueueCount > 0 && (
          <Card className="border-orange-700 bg-gradient-to-r from-orange-950 to-red-950 shadow-sm backdrop-blur-sm">
            <CardHeader>
              <div className="flex items-center justify-between gap-4">
                <CardTitle className="break-words text-xl font-semibold text-white">
                  Spaced Repetition Review
                </CardTitle>{' '}
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
                <div className="min-w-0 flex-1 space-y-1">
                  <p className="break-words text-sm text-orange-200">
                    You have <span className="font-bold text-orange-300">{reviewQueueCount}</span>{' '}
                    question
                    {reviewQueueCount !== 1 ? 's' : ''} ready for review
                  </p>
                  <p className="break-words text-xs text-orange-300">
                    Review questions to strengthen your memory and improve retention
                  </p>
                </div>
                <Button
                  onClick={onStartReviewSession}
                  className="flex-shrink-0 whitespace-nowrap bg-orange-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-orange-800 focus-visible:ring-2 focus-visible:ring-orange-500 active:bg-orange-900"
                >
                  <Clock className="mr-2 h-4 w-4" />
                  Start Review Session
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Overall Progress - Redesigned */}
        <Card className="border-gray-800 bg-gradient-to-r from-slate-950 to-gray-950 shadow-sm backdrop-blur-sm">
          <CardHeader>
            <CardTitle className="text-white">Overall Progress</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* Progress Bar Section */}
            <div>
              <ProgressBar
                current={totalAnswered}
                total={totalQuestions}
                variant={totalAnswered === totalQuestions ? 'success' : 'default'}
                showText={true}
                label="Questions Completed"
                showPercentage={true}
              />
            </div>

            {/* Stat Cards Grid */}
            <div className="grid grid-cols-2 gap-4 sm:grid-cols-4">
              {/* Chapters */}
              <div className="space-y-3 rounded-lg bg-slate-800 p-4">
                <div className="w-fit rounded-lg bg-blue-700/20 p-2">
                  <BookOpen className="h-5 w-5 text-blue-400" />
                </div>
                <div className="space-y-1">
                  <div className="text-sm text-gray-400">Chapters</div>
                  <div className="text-2xl font-bold tabular-nums text-white">
                    {module.chapters.length}
                  </div>
                </div>
              </div>

              {/* Total Questions */}
              <div className="space-y-3 rounded-lg bg-slate-800 p-4">
                <div className="w-fit rounded-lg bg-purple-700/20 p-2">
                  <HelpCircle className="h-5 w-5 text-purple-400" />
                </div>
                <div className="space-y-1">
                  <div className="text-sm text-gray-400">Total Questions</div>
                  <div className="text-2xl font-bold tabular-nums text-white">{totalQuestions}</div>
                </div>
              </div>

              {/* Answered */}
              <div className="space-y-3 rounded-lg bg-slate-800 p-4">
                <div className="w-fit rounded-lg bg-green-700/20 p-2">
                  <CheckCircle className="h-5 w-5 text-green-400" />
                </div>
                <div className="space-y-1">
                  <div className="text-sm text-gray-400">Answered</div>
                  <div className="text-2xl font-bold tabular-nums text-white">{totalAnswered}</div>
                </div>
              </div>

              {/* Accuracy */}
              <div className="space-y-3 rounded-lg bg-slate-800 p-4">
                <div className="w-fit rounded-lg bg-yellow-700/20 p-2">
                  <TrendingUp className="h-5 w-5 text-yellow-400" />
                </div>
                <div className="space-y-1">
                  <div className="text-sm text-gray-400">Accuracy</div>
                  <div
                    className={`text-2xl font-bold tabular-nums ${overallAccuracy >= 70 ? 'text-green-400' : 'text-yellow-400'}`}
                  >
                    {overallAccuracy}%
                  </div>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Chapters Grid - Improved responsive layout */}
        <div>
          <h2 className="mb-4 text-xl font-semibold text-white">Chapters</h2>
          <div className="grid auto-rows-fr grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4">
            {module.chapters.map((chapter) => (
              <ChapterCard key={chapter.id} chapter={chapter} onStartQuiz={onStartQuiz} />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\option-card.tsx
SIZE: 2,817 bytes | LINES: 94
================================================================================
'use client';
import { Card } from '@/components/ui/card';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { Check, X } from 'lucide-react';
import type { QuizOption } from '@/types/quiz-types';
import { memo } from 'react';

interface OptionCardProps {
  option: QuizOption;
  isSelected: boolean;
  showAsCorrect?: boolean;
  showAsIncorrect?: boolean;
  isSubmitted: boolean;
  onSelect: () => void;
  disabled?: boolean;
}

// MEMOIZED: Prevent unnecessary re-renders when props haven't meaningfully changed
export const OptionCard = memo(function OptionCard({
  option,
  isSelected,
  showAsCorrect = false,
  showAsIncorrect = false,
  isSubmitted,
  onSelect,
  disabled = false,
}: OptionCardProps) {
  const getCardClasses = () => {
    let baseClasses =
      'cursor-pointer transition-all duration-200 border-2 backdrop-blur-sm shadow-sm ';

    if (disabled) {
      baseClasses += 'cursor-not-allowed opacity-70 ';
    }

    if (isSubmitted) {
      if (showAsCorrect) {
        baseClasses +=
          'bg-gradient-to-r from-green-950 to-green-900 border-green-700 shadow-green-900/20 ';
      } else if (showAsIncorrect) {
        baseClasses += 'bg-gradient-to-r from-red-950 to-red-900 border-red-700 shadow-red-900/20 ';
      } else {
        baseClasses += 'bg-gradient-to-r from-slate-950 to-gray-950 border-gray-800 ';
      }
    } else {
      if (isSelected) {
        baseClasses +=
          'bg-gradient-to-r from-blue-950 to-blue-900 border-blue-700 shadow-blue-900/20 ';
      } else {
        baseClasses +=
          'bg-gradient-to-r from-slate-950 to-gray-950 border-gray-800 hover:from-slate-900 hover:to-gray-900 hover:border-gray-700 hover:shadow-md active:scale-[0.99] ';
      }
    }

    return baseClasses;
  };

  const getIcon = () => {
    return (
      <div className="flex h-5 w-5 flex-shrink-0 items-center justify-center">
        {isSubmitted && showAsCorrect && <Check className="h-5 w-5 text-green-400" />}
        {isSubmitted && showAsIncorrect && <X className="h-5 w-5 text-red-400" />}
      </div>
    );
  };

  return (
    <Card
      className={getCardClasses()}
      onClick={disabled ? undefined : onSelect}
      role="button"
      tabIndex={disabled ? -1 : 0}
      aria-pressed={isSelected}
      onKeyDown={(e) => {
        if (!disabled && (e.key === 'Enter' || e.key === ' ')) {
          e.preventDefault();
          onSelect();
        }
      }}
    >
      <div className="flex items-start gap-3 p-4">
        <div className="flex-1">
          <MarkdownRenderer
            key={`option-${option.optionId}-${isSelected}-${isSubmitted}`}
            markdown={option.optionText}
            className="leading-relaxed text-white"
          />
        </div>
        {getIcon()}
      </div>
    </Card>
  );
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\progress-bar.tsx
SIZE: 2,584 bytes | LINES: 87
================================================================================
import { PercentIcon } from 'lucide-react';

interface ProgressBarProps {
  current: number;
  total: number;
  className?: string;
  showText?: boolean;
  variant?: 'default' | 'success' | 'warning';
  label?: string;
  showPercentage?: boolean;
  compact?: boolean;
}

export function ProgressBar({
  current,
  total,
  className = '',
  showText = true,
  variant = 'default',
  label = 'questions completed',
  showPercentage = true,
  compact = false,
}: ProgressBarProps) {
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;

  const variantClasses = {
    default: 'bg-blue-500',
    success: 'bg-green-500',
    warning: 'bg-yellow-500',
  };

  if (compact) {
    // Compact mode for chapter cards - just the bar with percentage on the right
    return (
      <div className={`w-full ${className}`}>
        <div className="mb-2 flex items-center justify-between">
          <div className="flex-1" />
          {showPercentage && (
            <span className="text-sm font-medium tabular-nums text-gray-300">{percentage}%</span>
          )}
        </div>
        <div className="h-2.5 w-full rounded-full bg-gray-700">
          <div
            className={`h-2.5 rounded-full transition-all duration-300 ${variantClasses[variant]}`}
            style={{ width: `${percentage}%` }}
          />
        </div>
      </div>
    );
  }

  // Full mode for dashboard and quiz sessions - Enhanced alignment
  return (
    <div className={`w-full ${className}`}>
      {/* Display label above the aligned row if showText is true */}
      {showText && <div className="mb-1 text-sm font-medium text-gray-400">{label}</div>}

      {/* Horizontally aligned row */}
      <div className="flex items-start space-x-3">
        {/* Icon */}

        {/* Progress Bar */}
        <div className="h-2.5 flex-grow rounded-full bg-gray-700 leading-3 leading-4 leading-5 leading-6 leading-7">
          <div
            className={`h-2.5 rounded-full transition-all duration-300 ${variantClasses[variant]}`}
            style={{ width: `${percentage}%` }}
          />
        </div>

        {/* Percentage Text */}
        {showPercentage && (
          <span className="w-12 flex-shrink-0 text-right text-sm font-medium tabular-nums text-gray-300">
            {percentage}%
          </span>
        )}

        {/* Score Text ("current/total") */}
        {showText && (
          <span className="flex-shrink-0 whitespace-nowrap text-sm tabular-nums text-gray-400">
            {current}/{total}
          </span>
        )}
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\question-editor.tsx
SIZE: 23,658 bytes | LINES: 588
================================================================================
'use client';

import { useState, useEffect } from 'react';
import type React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { ConfirmationModal } from './confirmation-modal-radix';
import { X, Plus, Trash2, Save, Eye, EyeOff } from 'lucide-react';
import type { QuizQuestion, QuizOption } from '@/types/quiz-types';

interface QuestionEditorProps {
  isOpen: boolean;
  question: QuizQuestion;
  chapterId: string;
  onSave: (question: QuizQuestion) => void;
  onCancel: () => void;
  onDelete: (questionId: string) => void;
  generateUniqueOptionId?: (questionId: string, existingOptionIds: string[]) => string;
}

export function QuestionEditor({
  isOpen,
  question,
  chapterId,
  onSave,
  onCancel,
  onDelete,
  generateUniqueOptionId,
}: QuestionEditorProps) {
  // Form state
  const [questionId, setQuestionId] = useState('');
  const [questionText, setQuestionText] = useState('');
  const [options, setOptions] = useState<QuizOption[]>([]);
  const [correctOptionIds, setCorrectOptionIds] = useState<string[]>([]);
  const [explanationText, setExplanationText] = useState('');

  // SRS and performance tracking fields
  const [srsLevel, setSrsLevel] = useState(0);
  const [nextReviewAt, setNextReviewAt] = useState('');

  // UI state
  const [showPreview, setShowPreview] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [errors, setErrors] = useState<string[]>([]);
  const [isNewQuestion, setIsNewQuestion] = useState(false);

  // Initialize form data when question changes
  useEffect(() => {
    if (question) {
      setQuestionId(question.questionId);
      setQuestionText(question.questionText);
      setOptions([...question.options]);
      setCorrectOptionIds([...question.correctOptionIds]);
      setExplanationText(question.explanationText);
      setSrsLevel(question.srsLevel || 0);
      setNextReviewAt(question.nextReviewAt || '');

      // Determine if this is a new question (empty questionText indicates new)
      setIsNewQuestion(!question.questionText);

      console.log('Question Editor initialized with:', {
        questionId: question.questionId,
        isNew: !question.questionText,
        optionsCount: question.options.length,
      });
    }
  }, [question]);

  // Validation function
  const validateForm = (): string[] => {
    const validationErrors: string[] = [];

    if (!questionId.trim()) {
      validationErrors.push('Question ID is required');
    }

    if (!questionText.trim()) {
      validationErrors.push('Question text is required');
    }

    if (options.length < 2) {
      validationErrors.push('At least 2 options are required');
    }

    // Check for empty options
    const emptyOptions = options.filter((opt) => !opt.optionText.trim());
    if (emptyOptions.length > 0) {
      validationErrors.push(`${emptyOptions.length} option(s) have empty text`);
    }

    // Check for duplicate option IDs
    const optionIds = options.map((opt) => opt.optionId);
    const duplicateIds = optionIds.filter((id, index) => optionIds.indexOf(id) !== index);
    if (duplicateIds.length > 0) {
      validationErrors.push('Duplicate option IDs found');
    }

    if (correctOptionIds.length === 0) {
      validationErrors.push('At least one correct answer must be selected');
    }

    // Check that all correct option IDs exist in options
    const invalidCorrectIds = correctOptionIds.filter(
      (correctId) => !options.some((opt) => opt.optionId === correctId),
    );
    if (invalidCorrectIds.length > 0) {
      validationErrors.push('Some correct answers reference non-existent options');
    }

    if (!explanationText.trim()) {
      validationErrors.push('Explanation text is required');
    }

    return validationErrors;
  };

  // Add new option
  const handleAddOption = () => {
    const existingOptionIds = options.map((opt) => opt.optionId);
    const newOptionId = generateUniqueOptionId
      ? generateUniqueOptionId(questionId, existingOptionIds)
      : `${questionId}_opt${options.length + 1}`;

    const newOption: QuizOption = {
      optionId: newOptionId,
      optionText: '',
    };

    setOptions([...options, newOption]);
    console.log('Added new option:', newOptionId);
  };

  // Remove option
  const handleRemoveOption = (optionId: string) => {
    setOptions(options.filter((opt) => opt.optionId !== optionId));
    setCorrectOptionIds(correctOptionIds.filter((id) => id !== optionId));
    console.log('Removed option:', optionId);
  };

  // Update option text
  const handleUpdateOptionText = (optionId: string, newText: string) => {
    setOptions(
      options.map((opt) => (opt.optionId === optionId ? { ...opt, optionText: newText } : opt)),
    );
  };

  // Toggle correct answer
  const handleToggleCorrectAnswer = (optionId: string) => {
    if (correctOptionIds.includes(optionId)) {
      setCorrectOptionIds(correctOptionIds.filter((id) => id !== optionId));
    } else {
      setCorrectOptionIds([...correctOptionIds, optionId]);
    }
  };

  // Handle save
  const handleSave = () => {
    const validationErrors = validateForm();

    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }

    const updatedQuestion: QuizQuestion = {
      questionId,
      questionText,
      options,
      correctOptionIds,
      explanationText,
      // Preserve existing performance tracking data
      status: question.status || 'not_attempted',
      timesAnsweredCorrectly: question.timesAnsweredCorrectly || 0,
      timesAnsweredIncorrectly: question.timesAnsweredIncorrectly || 0,
      historyOfIncorrectSelections: question.historyOfIncorrectSelections || [],
      lastSelectedOptionId: question.lastSelectedOptionId,
      lastAttemptedAt: question.lastAttemptedAt,
      // SRS fields
      srsLevel,
      nextReviewAt: nextReviewAt || null,
      shownIncorrectOptionIds: question.shownIncorrectOptionIds || [],
    };

    console.log('Saving question:', updatedQuestion.questionId);
    onSave(updatedQuestion);
  };

  // Handle delete
  const handleDelete = () => {
    if (isNewQuestion) {
      // Just cancel for new questions
      onCancel();
    } else {
      setShowDeleteConfirmation(true);
    }
  };

  const handleConfirmDelete = () => {
    console.log('Deleting question:', questionId);
    onDelete(questionId);
    setShowDeleteConfirmation(false);
  };

  // Handle keyboard shortcuts
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      onCancel();
    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      handleSave();
    }
  };

  if (!isOpen) return null;

  return (
    <>
      {/* Main Editor Modal */}
      <div
        className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4 backdrop-blur-sm"
        onClick={onCancel}
        onKeyDown={handleKeyDown}
        tabIndex={-1}
      >
        <Card
          className="max-h-[90vh] w-full max-w-6xl overflow-hidden border-gray-800 bg-gradient-to-r from-slate-950 to-gray-950 shadow-xl backdrop-blur-sm"
          onClick={(e) => e.stopPropagation()}
        >
          <CardHeader className="border-b border-gray-800 pb-4">
            <div className="flex items-start justify-between gap-4">
              <div className="flex min-w-0 flex-1 items-start gap-3">
                <div className="flex-shrink-0 rounded-lg bg-yellow-700/20 p-2">
                  <X className="h-5 w-5 text-yellow-400" />
                </div>
                <div className="min-w-0 flex-1">
                  <CardTitle className="break-words text-xl leading-tight text-white">
                    {isNewQuestion ? 'Add New Question' : 'Edit Question'}
                  </CardTitle>
                  <p className="mt-1 text-sm text-gray-400">
                    {isNewQuestion
                      ? 'Create a new question for this chapter'
                      : 'Modify the current question'}
                  </p>
                </div>
              </div>
              <div className="flex gap-2">
                <Button
                  onClick={() => setShowPreview(!showPreview)}
                  variant="outline"
                  size="sm"
                  className="border-blue-700 bg-blue-900/40 text-blue-200 hover:bg-blue-800/50 hover:text-white"
                >
                  {showPreview ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </Button>
                <Button
                  onClick={onCancel}
                  variant="ghost"
                  size="sm"
                  className="flex-shrink-0 text-gray-400 hover:bg-white/10 hover:text-white"
                  aria-label="Close editor"
                >
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardHeader>

          <CardContent className="max-h-[calc(90vh-200px)] overflow-y-auto p-6">
            <div className={`grid ${showPreview ? 'grid-cols-2' : 'grid-cols-1'} gap-6`}>
              {/* Editor Form */}
              <div className="space-y-6">
                {/* Error Display */}
                {errors.length > 0 && (
                  <div className="rounded-lg border border-red-700 bg-red-900/40 p-4">
                    <h4 className="mb-2 font-medium text-red-300">Validation Errors:</h4>
                    <ul className="space-y-1 text-sm text-red-200">
                      {errors.map((error, index) => (
                        <li key={index}>• {error}</li>
                      ))}
                    </ul>
                  </div>
                )}

                {/* Question ID */}
                <div className="space-y-2">
                  <Label htmlFor="questionId" className="font-medium text-white">
                    Question ID
                  </Label>
                  <Input
                    id="questionId"
                    value={questionId}
                    onChange={(e) => setQuestionId(e.target.value)}
                    placeholder="e.g., chapter1_q1"
                    className="border-slate-700 bg-slate-800 text-white"
                    disabled={!isNewQuestion} // Disable editing ID for existing questions
                  />
                  {!isNewQuestion && (
                    <p className="text-xs text-gray-400">
                      Question ID cannot be changed for existing questions
                    </p>
                  )}
                </div>

                {/* Question Text */}
                <div className="space-y-2">
                  <Label htmlFor="questionText" className="font-medium text-white">
                    Question Text
                  </Label>
                  <Textarea
                    id="questionText"
                    value={questionText}
                    onChange={(e) => setQuestionText(e.target.value)}
                    placeholder="Enter your question here. You can use Markdown, LaTeX ($$...$$), and HTML."
                    className="min-h-[120px] border-slate-700 bg-slate-800 text-white"
                    rows={5}
                  />
                  <p className="text-xs text-gray-400">
                    Supports Markdown, LaTeX math ($$...$$), and basic HTML formatting
                  </p>
                </div>

                {/* Options */}
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <Label className="font-medium text-white">Answer Options</Label>
                    <Button
                      onClick={handleAddOption}
                      variant="outline"
                      size="sm"
                      className="border-green-700 bg-green-900/40 text-green-200 hover:bg-green-800/50"
                    >
                      <Plus className="mr-2 h-4 w-4" />
                      Add Option
                    </Button>
                  </div>

                  <div className="space-y-3">
                    {options.map((option, index) => (
                      <div
                        key={option.optionId}
                        className="rounded-lg border border-slate-700 bg-slate-800/50 p-4"
                      >
                        <div className="flex items-start gap-3">
                          <div className="mt-2 flex items-center gap-2">
                            <input
                              type="checkbox"
                              checked={correctOptionIds.includes(option.optionId)}
                              onChange={() => handleToggleCorrectAnswer(option.optionId)}
                              className="h-4 w-4 rounded border-slate-600 bg-slate-700 text-green-600 focus:ring-green-500"
                            />
                            <span className="text-xs text-gray-400">Correct</span>
                          </div>

                          <div className="flex-1 space-y-2">
                            <div className="flex items-center gap-2">
                              <Label className="text-sm text-gray-300">Option {index + 1}</Label>
                              <code className="rounded bg-slate-700 px-2 py-1 text-xs text-blue-300">
                                {option.optionId}
                              </code>
                            </div>
                            <Textarea
                              value={option.optionText}
                              onChange={(e) =>
                                handleUpdateOptionText(option.optionId, e.target.value)
                              }
                              placeholder="Enter option text (supports Markdown and LaTeX)"
                              className="border-slate-600 bg-slate-700 text-white"
                              rows={2}
                            />
                          </div>

                          <Button
                            onClick={() => handleRemoveOption(option.optionId)}
                            variant="ghost"
                            size="sm"
                            className="mt-2 text-red-400 hover:bg-red-900/20 hover:text-red-300"
                            disabled={options.length <= 2}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                    ))}
                  </div>

                  {options.length < 2 && (
                    <p className="text-sm text-yellow-400">At least 2 options are required</p>
                  )}
                </div>

                {/* Explanation */}
                <div className="space-y-2">
                  <Label htmlFor="explanationText" className="font-medium text-white">
                    Explanation
                  </Label>
                  <Textarea
                    id="explanationText"
                    value={explanationText}
                    onChange={(e) => setExplanationText(e.target.value)}
                    placeholder="Provide a detailed explanation of the correct answer. Supports Markdown and LaTeX."
                    className="min-h-[100px] border-slate-700 bg-slate-800 text-white"
                    rows={4}
                  />
                </div>

                {/* SRS Fields */}
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="srsLevel" className="font-medium text-white">
                      SRS Level
                    </Label>
                    <Input
                      id="srsLevel"
                      type="number"
                      min="0"
                      max="2"
                      value={srsLevel}
                      onChange={(e) => setSrsLevel(Number.parseInt(e.target.value) || 0)}
                      className="border-slate-700 bg-slate-800 text-white"
                    />
                    <p className="text-xs text-gray-400">
                      0 = New/Failed, 1 = Learning, 2 = Mastered
                    </p>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="nextReviewAt" className="font-medium text-white">
                      Next Review (ISO Date)
                    </Label>
                    <Input
                      id="nextReviewAt"
                      type="datetime-local"
                      value={nextReviewAt ? new Date(nextReviewAt).toISOString().slice(0, 16) : ''}
                      onChange={(e) =>
                        setNextReviewAt(
                          e.target.value ? new Date(e.target.value).toISOString() : '',
                        )
                      }
                      className="border-slate-700 bg-slate-800 text-white"
                    />
                    <p className="text-xs text-gray-400">Leave empty for immediate availability</p>
                  </div>
                </div>
              </div>

              {/* Preview Panel */}
              {showPreview && (
                <div className="space-y-4">
                  <h3 className="text-lg font-semibold text-white">Preview</h3>

                  {/* Question Preview */}
                  <Card className="border-slate-700 bg-slate-800/50">
                    <CardHeader>
                      <CardTitle className="text-base text-white">Question</CardTitle>
                    </CardHeader>
                    <CardContent>
                      {questionText ? (
                        <div className="prose prose-invert max-w-none">
                          <MarkdownRenderer markdown={questionText} className="text-white" />
                        </div>
                      ) : (
                        <p className="italic text-gray-400">Question text will appear here...</p>
                      )}
                    </CardContent>
                  </Card>

                  {/* Options Preview */}
                  <Card className="border-slate-700 bg-slate-800/50">
                    <CardHeader>
                      <CardTitle className="text-base text-white">Options</CardTitle>
                    </CardHeader>
                    <CardContent className="space-y-2">
                      {options.length > 0 ? (
                        options.map((option, index) => (
                          <div
                            key={option.optionId}
                            className={`rounded border-2 p-3 ${
                              correctOptionIds.includes(option.optionId)
                                ? 'border-green-600 bg-green-900/20'
                                : 'border-slate-600 bg-slate-700/30'
                            }`}
                          >
                            <div className="flex items-start gap-2">
                              <span className="mt-1 text-sm text-gray-400">{index + 1}.</span>
                              {option.optionText ? (
                                <div className="prose prose-invert max-w-none flex-1">
                                  <MarkdownRenderer
                                    markdown={option.optionText}
                                    className="text-sm text-white"
                                  />
                                </div>
                              ) : (
                                <p className="text-sm italic text-gray-400">
                                  Option text will appear here...
                                </p>
                              )}
                              {correctOptionIds.includes(option.optionId) && (
                                <span className="rounded bg-green-700 px-2 py-1 text-xs text-green-100">
                                  Correct
                                </span>
                              )}
                            </div>
                          </div>
                        ))
                      ) : (
                        <p className="italic text-gray-400">Options will appear here...</p>
                      )}
                    </CardContent>
                  </Card>

                  {/* Explanation Preview */}
                  <Card className="border-slate-700 bg-slate-800/50">
                    <CardHeader>
                      <CardTitle className="text-base text-white">Explanation</CardTitle>
                    </CardHeader>
                    <CardContent>
                      {explanationText ? (
                        <div className="prose prose-invert max-w-none">
                          <MarkdownRenderer markdown={explanationText} className="text-white" />
                        </div>
                      ) : (
                        <p className="italic text-gray-400">Explanation will appear here...</p>
                      )}
                    </CardContent>
                  </Card>
                </div>
              )}
            </div>
          </CardContent>

          {/* Footer with action buttons */}
          <div className="border-t border-gray-800 p-6">
            <div className="flex items-center justify-between gap-4">
              <div className="text-sm text-gray-400">Use Ctrl+Enter to save, Escape to cancel</div>
              <div className="flex gap-3">
                <Button
                  onClick={onCancel}
                  variant="outline"
                  className="border-gray-700 bg-gray-900/70 text-gray-200 hover:border-gray-600 hover:bg-gray-800 hover:text-white"
                >
                  Cancel
                </Button>
                {!isNewQuestion && (
                  <Button
                    onClick={handleDelete}
                    variant="destructive"
                    className="bg-red-700 text-white hover:bg-red-800"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete Question
                  </Button>
                )}
                <Button
                  onClick={handleSave}
                  className="bg-green-700 text-white transition-all duration-200 hover:bg-green-800 focus-visible:ring-2 focus-visible:ring-green-500 active:bg-green-900"
                >
                  <Save className="mr-2 h-4 w-4" />
                  {isNewQuestion ? 'Add Question' : 'Save Changes'}
                </Button>
              </div>
            </div>
          </div>
        </Card>
      </div>

      {/* Delete Confirmation Modal */}
      {showDeleteConfirmation && (
        <ConfirmationModal
          isOpen={showDeleteConfirmation}
          title="Delete Question"
          message={`Are you sure you want to delete this question? This action cannot be undone.`}
          questionPreview={
            questionText.substring(0, 150) + (questionText.length > 150 ? '...' : '')
          }
          confirmText="Delete Question"
          variant="danger"
          onConfirm={handleConfirmDelete}
          onCancel={() => setShowDeleteConfirmation(false)}
        />
      )}
    </>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\question-navigation-menu.tsx
SIZE: 6,281 bytes | LINES: 149
================================================================================
'use client';
import { memo } from 'react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import type { QuizQuestion, SessionHistoryEntry } from '@/types/quiz-types';

interface QuestionNavigationMenuProps {
  questions: QuizQuestion[];
  currentQuestionIndex: number;
  sessionHistory: SessionHistoryEntry[];
  currentHistoryViewIndex: number | null;
  onNavigateToQuestion: (questionIndex: number) => void;
  isReviewSession: boolean;
}

export const QuestionNavigationMenu = memo(function QuestionNavigationMenu({
  questions,
  currentQuestionIndex,
  sessionHistory,
  currentHistoryViewIndex,
  onNavigateToQuestion,
  isReviewSession,
}: QuestionNavigationMenuProps) {
  // Don't render during review sessions
  if (isReviewSession) {
    return null;
  }

  // Helper function to find session history entry for a question
  const findHistoryEntryForQuestion = (questionId: string): SessionHistoryEntry | null => {
    return sessionHistory.find((entry) => entry.questionSnapshot.questionId === questionId) || null;
  };

  // Calculate progress percentage
  const answeredCount = sessionHistory.length;
  const progressPercentage =
    questions.length > 0 ? Math.round((answeredCount / questions.length) * 100) : 0;

  // Helper function to determine the status and styling for each question box
  const getQuestionBoxStatus = (questionIndex: number) => {
    const question = questions[questionIndex];
    const historyEntry = findHistoryEntryForQuestion(question.questionId);

    // Check if this is the question being viewed in history mode
    const isCurrentHistoricalView =
      currentHistoryViewIndex !== null &&
      historyEntry &&
      sessionHistory[currentHistoryViewIndex]?.questionSnapshot.questionId === question.questionId;

    // Check if this is the current live question (not yet submitted)
    const isCurrentLive =
      questionIndex === currentQuestionIndex && currentHistoryViewIndex === null && !historyEntry;

    // Determine status
    if (isCurrentHistoricalView) {
      return {
        status: 'current-historical',
        isCorrect: historyEntry.isCorrect,
        classes: historyEntry.isCorrect
          ? 'bg-gradient-to-r from-green-900 to-green-800 border-green-600 ring-2 ring-green-400 ring-opacity-50'
          : 'bg-gradient-to-r from-red-900 to-red-800 border-red-600 ring-2 ring-red-400 ring-opacity-50',
      };
    } else if (isCurrentLive) {
      return {
        status: 'current-live',
        classes:
          'bg-gradient-to-r from-blue-900 to-blue-800 border-blue-600 ring-2 ring-blue-400 ring-opacity-50',
      };
    } else if (historyEntry) {
      return {
        status: historyEntry.isCorrect ? 'answered-correct' : 'answered-incorrect',
        isCorrect: historyEntry.isCorrect,
        classes: historyEntry.isCorrect
          ? 'bg-gradient-to-r from-green-950 to-green-900 border-green-700 hover:from-green-900 hover:to-green-800'
          : 'bg-gradient-to-r from-red-950 to-red-900 border-red-700 hover:from-red-900 hover:to-red-800',
      };
    } else {
      return {
        status: 'unanswered',
        classes:
          'bg-gradient-to-r from-slate-800 to-gray-800 border-gray-600 hover:from-slate-700 hover:to-gray-700',
      };
    }
  };

  return (
    <Card className="mb-6 border-slate-700 bg-slate-900/50 shadow-sm backdrop-blur-sm">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium text-white">Question Navigation</h3>
          <div className="text-sm font-medium tabular-nums text-gray-300">
            {progressPercentage}% Complete
          </div>
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Single-line question navigation buttons */}
        <div className="flex w-full gap-1">
          {questions.map((question, index) => {
            const boxStatus = getQuestionBoxStatus(index);

            return (
              <button
                key={question.questionId}
                onClick={() => onNavigateToQuestion(index)}
                className={` ${boxStatus.classes} flex h-10 min-w-[2.5rem] flex-1 items-center justify-center whitespace-nowrap rounded-md border-2 px-2 text-sm font-medium text-white transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 active:scale-95`}
                title={`Question ${index + 1}${
                  boxStatus.status === 'current-live'
                    ? ' (Current)'
                    : boxStatus.status === 'current-historical'
                      ? ` (Viewing - ${boxStatus.isCorrect ? 'Correct' : 'Incorrect'})`
                      : boxStatus.status === 'answered-correct'
                        ? ' (Correct)'
                        : boxStatus.status === 'answered-incorrect'
                          ? ' (Incorrect)'
                          : ' (Unanswered)'
                }`}
                aria-label={`Navigate to question ${index + 1}`}
              >
                {index + 1}
              </button>
            );
          })}
        </div>

        {/* Status Legend */}
        <div className="flex flex-wrap gap-4 border-t border-slate-700 pt-2 text-xs text-gray-400">
          <div className="flex items-center gap-1.5">
            <div className="h-3 w-3 rounded border border-blue-600 bg-gradient-to-r from-blue-900 to-blue-800"></div>
            <span>Current</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div className="h-3 w-3 rounded border border-green-700 bg-gradient-to-r from-green-950 to-green-900"></div>
            <span>Correct</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div className="h-3 w-3 rounded border border-red-700 bg-gradient-to-r from-red-950 to-red-900"></div>
            <span>Incorrect</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div className="h-3 w-3 rounded border border-gray-600 bg-gradient-to-r from-slate-800 to-gray-800"></div>
            <span>Unanswered</span>
          </div>
        </div>
      </CardContent>
    </Card>
  );
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\question-review-modal.tsx
SIZE: 13,336 bytes | LINES: 333
================================================================================
'use client';
import { useState } from 'react';
import type React from 'react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { ChevronLeft, ChevronRight, X, Plus, Minus, Save, FileText } from 'lucide-react';
import type { QuizQuestion } from '@/types/quiz-types';

interface QuestionReviewModalProps {
  isOpen: boolean;
  questionsToReview: QuizQuestion[];
  onSaveSelected: (selectedQuestions: QuizQuestion[]) => void;
  onCancel: () => void;
}

export function QuestionReviewModal({
  isOpen,
  questionsToReview,
  onSaveSelected,
  onCancel,
}: QuestionReviewModalProps) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [questionsMarkedForAddition, setQuestionsMarkedForAddition] = useState<QuizQuestion[]>([]);

  if (!isOpen || questionsToReview.length === 0) return null;

  const currentQuestion = questionsToReview[currentIndex];
  const isCurrentQuestionMarked = questionsMarkedForAddition.some(
    (q) => q.questionId === currentQuestion.questionId,
  );

  const handlePrevious = () => {
    setCurrentIndex((prev) => (prev > 0 ? prev - 1 : questionsToReview.length - 1));
  };

  const handleNext = () => {
    setCurrentIndex((prev) => (prev < questionsToReview.length - 1 ? prev + 1 : 0));
  };

  const handleToggleQuestion = () => {
    if (isCurrentQuestionMarked) {
      // Remove from marked list
      setQuestionsMarkedForAddition((prev) =>
        prev.filter((q) => q.questionId !== currentQuestion.questionId),
      );
    } else {
      // Add to marked list
      setQuestionsMarkedForAddition((prev) => [...prev, currentQuestion]);
    }
  };

  const handleSaveSelected = () => {
    onSaveSelected(questionsMarkedForAddition);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      onCancel();
    } else if (e.key === 'ArrowLeft') {
      e.preventDefault();
      handlePrevious();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      handleNext();
    } else if (e.key === ' ') {
      e.preventDefault();
      handleToggleQuestion();
    }
  };

  // Get correct options for display
  const correctOptions = currentQuestion.options.filter((opt) =>
    currentQuestion.correctOptionIds.includes(opt.optionId),
  );
  const incorrectOptions = currentQuestion.options.filter(
    (opt) => !currentQuestion.correctOptionIds.includes(opt.optionId),
  );

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4 backdrop-blur-sm"
      onClick={onCancel}
      onKeyDown={handleKeyDown}
      tabIndex={-1}
    >
      <Card
        className="max-h-[90vh] w-full max-w-4xl overflow-hidden border-gray-800 bg-gradient-to-r from-slate-950 to-gray-950 shadow-xl backdrop-blur-sm"
        onClick={(e) => e.stopPropagation()}
      >
        <CardHeader className="border-b border-gray-800 pb-4">
          <div className="flex items-start justify-between gap-4">
            <div className="flex min-w-0 flex-1 items-start gap-3">
              <div className="flex-shrink-0 rounded-lg bg-purple-700/20 p-2">
                <FileText className="h-5 w-5 text-purple-400" />
              </div>
              <div className="min-w-0 flex-1">
                <CardTitle className="break-words text-xl leading-tight text-white">
                  Review Questions for Addition
                </CardTitle>
                <p className="mt-1 text-sm text-gray-400">
                  Review and select questions to add to the current chapter
                </p>
              </div>
            </div>
            <Button
              onClick={onCancel}
              variant="ghost"
              size="sm"
              className="flex-shrink-0 text-gray-400 hover:bg-white/10 hover:text-white"
              aria-label="Close modal"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>

        <CardContent className="max-h-[calc(90vh-200px)] overflow-y-auto p-6">
          <div className="space-y-6">
            {/* Navigation and status */}
            <div className="flex items-center justify-between gap-4 rounded-lg bg-slate-800/50 p-4">
              <div className="flex items-center gap-3">
                <Button
                  onClick={handlePrevious}
                  variant="outline"
                  size="sm"
                  className="border-gray-700 bg-gray-900/70 text-gray-200 hover:bg-gray-800"
                  disabled={questionsToReview.length <= 1}
                >
                  <ChevronLeft className="h-4 w-4" />
                </Button>
                <span className="font-medium text-white">
                  Question {currentIndex + 1} of {questionsToReview.length}
                </span>
                <Button
                  onClick={handleNext}
                  variant="outline"
                  size="sm"
                  className="border-gray-700 bg-gray-900/70 text-gray-200 hover:bg-gray-800"
                  disabled={questionsToReview.length <= 1}
                >
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>

              <div className="flex items-center gap-3">
                <span className="text-sm text-gray-400">
                  {questionsMarkedForAddition.length} selected for addition
                </span>
                <Button
                  onClick={handleToggleQuestion}
                  variant={isCurrentQuestionMarked ? 'destructive' : 'default'}
                  size="sm"
                  className={
                    isCurrentQuestionMarked
                      ? 'bg-red-700 hover:bg-red-800'
                      : 'bg-green-700 text-white hover:bg-green-800'
                  }
                >
                  {isCurrentQuestionMarked ? (
                    <>
                      <Minus className="mr-2 h-4 w-4" />
                      Remove from Selection
                    </>
                  ) : (
                    <>
                      <Plus className="mr-2 h-4 w-4" />
                      Add to Selection
                    </>
                  )}
                </Button>
              </div>
            </div>

            {/* Question preview */}
            <div className="space-y-4">
              {/* Question ID and metadata */}
              <div className="rounded-lg bg-slate-800/30 p-3">
                <div className="flex flex-wrap gap-4 text-sm">
                  <span className="text-gray-400">
                    ID:{' '}
                    <span className="font-mono text-blue-400">{currentQuestion.questionId}</span>
                  </span>
                  {currentQuestion.srsLevel !== undefined && (
                    <span className="text-gray-400">
                      SRS Level: <span className="text-yellow-400">{currentQuestion.srsLevel}</span>
                    </span>
                  )}
                  {currentQuestion.timesAnsweredCorrectly !== undefined && (
                    <span className="text-gray-400">
                      Correct:{' '}
                      <span className="text-green-400">
                        {currentQuestion.timesAnsweredCorrectly}
                      </span>
                    </span>
                  )}
                  {currentQuestion.timesAnsweredIncorrectly !== undefined && (
                    <span className="text-gray-400">
                      Incorrect:{' '}
                      <span className="text-red-400">
                        {currentQuestion.timesAnsweredIncorrectly}
                      </span>
                    </span>
                  )}
                </div>
              </div>

              {/* Question text */}
              <Card className="border-slate-700 bg-slate-800/50">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg text-white">Question Text</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="prose prose-invert max-w-none">
                    <MarkdownRenderer
                      markdown={currentQuestion.questionText}
                      className="break-words leading-relaxed text-white"
                    />
                  </div>
                </CardContent>
              </Card>

              {/* Options */}
              <Card className="border-slate-700 bg-slate-800/50">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg text-white">Answer Options</CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  {/* Correct options */}
                  {correctOptions.length > 0 && (
                    <div>
                      <h4 className="mb-2 text-sm font-medium text-green-400">
                        Correct Answer(s):
                      </h4>
                      <div className="space-y-2">
                        {correctOptions.map((option) => (
                          <div
                            key={option.optionId}
                            className="rounded-lg border border-green-700/50 bg-green-950/30 p-3"
                          >
                            <div className="prose prose-invert max-w-none">
                              <MarkdownRenderer
                                markdown={option.optionText}
                                className="break-words text-sm leading-relaxed text-green-200"
                              />
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Incorrect options (show first few) */}
                  {incorrectOptions.length > 0 && (
                    <div>
                      <h4 className="mb-2 text-sm font-medium text-gray-400">
                        Other Options ({incorrectOptions.length}):
                      </h4>
                      <div className="space-y-2">
                        {incorrectOptions.slice(0, 3).map((option) => (
                          <div
                            key={option.optionId}
                            className="rounded-lg border border-slate-700/50 bg-slate-800/30 p-3"
                          >
                            <div className="prose prose-invert max-w-none">
                              <MarkdownRenderer
                                markdown={option.optionText}
                                className="break-words text-sm leading-relaxed text-gray-300"
                              />
                            </div>
                          </div>
                        ))}
                        {incorrectOptions.length > 3 && (
                          <div className="py-2 text-center text-sm text-gray-500">
                            ... and {incorrectOptions.length - 3} more options
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </CardContent>
              </Card>

              {/* Explanation */}
              <Card className="border-slate-700 bg-slate-800/50">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg text-white">Explanation</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="prose prose-invert max-w-none">
                    <MarkdownRenderer
                      markdown={currentQuestion.explanationText}
                      className="break-words leading-relaxed text-gray-200"
                    />
                  </div>
                </CardContent>
              </Card>
            </div>
          </div>
        </CardContent>

        {/* Footer with action buttons */}
        <div className="border-t border-gray-800 p-6">
          <div className="flex items-center justify-between gap-4">
            <div className="text-sm text-gray-400">
              Use arrow keys to navigate, spacebar to toggle selection
            </div>
            <div className="flex gap-3">
              <Button
                onClick={onCancel}
                variant="outline"
                className="border-gray-700 bg-gray-900/70 text-gray-200 hover:border-gray-600 hover:bg-gray-800 hover:text-white"
              >
                Cancel All Additions
              </Button>
              <Button
                onClick={handleSaveSelected}
                disabled={questionsMarkedForAddition.length === 0}
                className="bg-green-700 text-white transition-all duration-200 hover:bg-green-800 focus-visible:ring-2 focus-visible:ring-green-500 active:bg-green-900"
              >
                <Save className="mr-2 h-4 w-4" />
                Save {questionsMarkedForAddition.length} Added Question
                {questionsMarkedForAddition.length !== 1 ? 's' : ''}
              </Button>
            </div>
          </div>
        </div>
      </Card>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\quiz-complete.tsx
SIZE: 7,508 bytes | LINES: 213
================================================================================
'use client';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ProgressBar } from './progress-bar';
import {
  Trophy,
  RotateCcw,
  Home,
  Download,
  Upload,
  FileText,
  LayoutGrid,
  SkipForward,
} from 'lucide-react';

interface QuizCompleteProps {
  chapter: {
    id: string;
    name: string;
  };
  results?: {
    totalQuestions: number;
    correctAnswers: number;
    incorrectAnswers: number;
    accuracy: number;
  };
  onBackToDashboard: () => void;
  onRetryQuiz: () => void;
  onExportResults: () => void;
  onLoadNewModule: () => void;
  onExportIncorrectAnswers: () => void;
  hasIncorrectAnswers: boolean;
  nextChapterId?: string | null;
  onStartChapterQuiz: (chapterId: string) => void;
}

export function QuizComplete({
  chapter,
  results,
  onBackToDashboard,
  onRetryQuiz,
  onExportResults,
  onLoadNewModule,
  onExportIncorrectAnswers,
  hasIncorrectAnswers,
  nextChapterId,
  onStartChapterQuiz,
}: QuizCompleteProps) {
  const getPerformanceMessage = () => {
    if (!results) return 'No results available';
    if (results.accuracy >= 90) return 'Outstanding! 🎉';
    if (results.accuracy >= 80) return 'Excellent work! 👏';
    if (results.accuracy >= 70) return 'Good job! 👍';
    if (results.accuracy >= 60) return 'Not bad, keep practicing! 💪';
    return 'Keep studying and try again! 📚';
  };

  const getPerformanceColor = () => {
    if (!results) return 'text-gray-400';
    if (results.accuracy >= 80) return 'text-green-400';
    if (results.accuracy >= 60) return 'text-yellow-400';
    return 'text-red-400';
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-black via-slate-950 to-gray-950 p-4">
      <div className="w-full max-w-2xl space-y-6">
        {/* Celebration Header */}
        <div className="space-y-4 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-yellow-700 p-4 shadow-sm">
              <Trophy className="h-12 w-12 text-white" />
            </div>
          </div>
          <h1 className="text-4xl font-bold text-white">Quiz Complete!</h1>
          <p className="text-xl text-gray-300">
            You've finished <span className="text-blue-400">{chapter.name}</span>
          </p>
        </div>

        {/* Results Card */}
        <Card className="border-gray-800 bg-gradient-to-r from-slate-950 to-gray-950 shadow-sm backdrop-blur-sm">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl text-white">Your Results</CardTitle>
            <p className={`text-xl font-semibold ${getPerformanceColor()}`}>
              {getPerformanceMessage()}
            </p>
          </CardHeader>

          <CardContent className="space-y-6">
            {/* Score Display */}
            <div className="text-center">
              <div className={`text-6xl font-bold ${getPerformanceColor()}`}>
                {results?.accuracy ?? 0}%
              </div>
              <p className="mt-2 text-gray-300">Overall Accuracy</p>
            </div>

            {/* Progress Bar */}
            <ProgressBar
              current={results?.correctAnswers ?? 0}
              total={results?.totalQuestions ?? 0}
              variant={
                results && results.accuracy >= 70
                  ? 'success'
                  : results && results.accuracy >= 50
                    ? 'warning'
                    : 'default'
              }
            />

            {/* Detailed Stats */}
            <div className="grid grid-cols-3 gap-4 text-center">
              <div className="space-y-1">
                <div className="text-2xl font-bold text-white">{results?.totalQuestions ?? 0}</div>
                <div className="text-sm text-gray-300">Total Questions</div>
              </div>
              <div className="space-y-1">
                <div className="text-2xl font-bold text-green-400">
                  {results?.correctAnswers ?? 0}
                </div>
                <div className="text-sm text-gray-300">Correct</div>
              </div>
              <div className="space-y-1">
                <div className="text-2xl font-bold text-red-400">
                  {results?.incorrectAnswers ?? 0}
                </div>
                <div className="text-sm text-gray-300">Incorrect</div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Action Buttons */}
        <div
          className={`grid grid-cols-1 ${nextChapterId ? 'md:grid-cols-3' : 'md:grid-cols-2'} gap-3`}
        >
          <Button
            onClick={onBackToDashboard}
            className="bg-blue-700 text-white shadow-sm hover:bg-blue-800"
            size="lg"
          >
            <Home className="mr-2 h-5 w-5" />
            Back to Dashboard
          </Button>

          <Button
            onClick={onRetryQuiz}
            className="border-blue-700 bg-blue-900/40 text-blue-200 shadow-sm transition-all duration-200 hover:border-blue-600 hover:bg-blue-800/50 hover:text-white"
            size="lg"
          >
            <RotateCcw className="mr-2 h-5 w-5" />
            Retry Quiz
          </Button>

          {nextChapterId && (
            <Button
              onClick={() => onStartChapterQuiz(nextChapterId)}
              className="bg-teal-700 text-white shadow-sm hover:bg-teal-800"
              size="lg"
            >
              <SkipForward className="mr-2 h-5 w-5" />
              Start Next Chapter
            </Button>
          )}
        </div>

        {/* Additional Actions */}
        <div className="grid grid-cols-1 gap-3 sm:grid-cols-4">
          <Button
            onClick={onExportResults}
            className="border-green-700 bg-green-900/40 text-green-200 shadow-sm transition-all duration-200 hover:border-green-600 hover:bg-green-800/50 hover:text-white"
          >
            <Download className="mr-2 h-4 w-4" />
            Export Results
          </Button>

          {/* NEW: Export Incorrect Answers Button */}
          <Button
            onClick={onExportIncorrectAnswers}
            disabled={!hasIncorrectAnswers}
            className="border-red-700 bg-red-900/40 text-red-200 shadow-sm transition-all duration-200 hover:border-red-600 hover:bg-red-800/50 hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
            title={
              hasIncorrectAnswers
                ? 'Export detailed log of incorrect answers'
                : 'No incorrect answers to export'
            }
          >
            <FileText className="mr-2 h-4 w-4" />
            Export Mistakes
          </Button>

          <Button
            onClick={onLoadNewModule}
            className="border-purple-700 bg-purple-900/40 text-purple-200 shadow-sm transition-all duration-200 hover:border-purple-600 hover:bg-purple-800/50 hover:text-white"
          >
            <Upload className="mr-2 h-4 w-4" />
            Load New Module
          </Button>

          <Button
            onClick={onBackToDashboard}
            className="border-amber-700 bg-amber-900/40 text-amber-200 shadow-sm transition-all duration-200 hover:border-amber-600 hover:bg-amber-800/50 hover:text-white"
          >
            <LayoutGrid className="mr-2 h-4 w-4" />
            View All Chapters
          </Button>
        </div>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\quiz-session.tsx
SIZE: 40,908 bytes | LINES: 971
================================================================================
'use client';
import { useState, useEffect, useRef, useMemo } from 'react';
import type React from 'react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { MarkdownRenderer } from './rendering/MarkdownRenderer';
import { useAnnouncer } from './a11y/ScreenReaderAnnouncer';
import { OptionCard } from './option-card';
import { AccessibleOptionList } from './a11y/AccessibleOptionList';
import { AccessibleQuestionGrid } from './a11y/AccessibleQuestionGrid';
import { QuestionNavigationMenu } from './question-navigation-menu';
import {
  ArrowLeft,
  ArrowRight,
  Send,
  Clock,
  Brain,
  Download,
  Upload,
  RotateCcw,
  Edit,
  Plus,
  Home,
  List,
} from 'lucide-react';
import type {
  QuizChapter,
  QuizQuestion,
  DisplayedOption,
  SrsProgressCounts,
  SessionHistoryEntry,
  QuizModule,
} from '@/types/quiz-types';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { QuestionEditor } from './question-editor';
import { CircularProgress } from '@/components/ui/circular-progress';
import { ProgressBar } from './progress-bar';

interface QuizSessionProps {
  chapter: QuizChapter;
  question: QuizQuestion;
  currentQuestionIndex: number;
  totalQuestions: number;
  selectedOptionId: string | null;
  isSubmitted: boolean;
  isReviewSession?: boolean;
  srsProgressCounts?: SrsProgressCounts;
  currentModule?: QuizModule;
  // Session History Navigation Props
  sessionHistory?: SessionHistoryEntry[];
  currentHistoryViewIndex?: number | null;
  // Edit Mode Props - Phase 1
  isEditModeActive?: boolean;
  editingQuestionData?: QuizQuestion | null;
  onSetEditMode?: (question: QuizQuestion | null) => void;
  onSaveQuestion?: (question: QuizQuestion) => void;
  onDeleteQuestion?: (questionId: string) => void;
  generateUniqueQuestionId?: (chapterId: string) => string;
  generateUniqueOptionId?: (questionId: string, existingOptionIds: string[]) => string;
  onSelectOption: (optionId: string) => void;
  onSubmitAnswer: (displayedOptions: DisplayedOption[]) => void;
  onNextQuestion: () => void;
  onBackToDashboard: () => void;
  onExportCurrentQuestionState: () => void;
  onImportQuestionStateFromFile: (file: File) => void;
  onRetryChapter: () => void;
  onNavigateToQuestion: (questionIndex: number) => void;
  // Session History Navigation Handlers
  onViewPrevious?: () => void;
  onViewNextInHistory?: () => void;
  // NEW: All Questions View Handler
  onViewAllQuestions?: () => void;
}

export function QuizSession({
  chapter,
  question,
  currentQuestionIndex,
  totalQuestions,
  selectedOptionId,
  isSubmitted,
  isReviewSession = false,
  srsProgressCounts,
  currentModule,
  sessionHistory = [],
  currentHistoryViewIndex = null,
  // Edit Mode Props - Phase 1
  isEditModeActive = false,
  editingQuestionData = null,
  onSetEditMode,
  onSaveQuestion,
  onDeleteQuestion,
  generateUniqueQuestionId,
  generateUniqueOptionId,
  onSelectOption,
  onSubmitAnswer,
  onNextQuestion,
  onBackToDashboard,
  onExportCurrentQuestionState,
  onImportQuestionStateFromFile,
  onRetryChapter,
  onNavigateToQuestion,
  onViewPrevious,
  onViewNextInHistory,
  onViewAllQuestions,
}: QuizSessionProps) {
  const [displayedOptionsCache, setDisplayedOptionsCache] = useState<DisplayedOption[]>([]);
  const [targetCorrectOptionForFeedback, setTargetCorrectOptionForFeedback] = useState<
    string | null
  >(null);

  const importFileInputRef = useRef<HTMLInputElement>(null);
  const { announce } = useAnnouncer();

  // FIXED: Correctly access props for history state
  const isViewingHistoricalEntry =
    typeof currentHistoryViewIndex === 'number' &&
    currentHistoryViewIndex >= 0 &&
    sessionHistory &&
    sessionHistory.length > 0 &&
    currentHistoryViewIndex < sessionHistory.length;

  const historicalEntry = isViewingHistoricalEntry ? sessionHistory[currentHistoryViewIndex] : null;

  // Use historical data when viewing history, otherwise use live data
  const displayQuestion = historicalEntry ? historicalEntry.questionSnapshot : question;
  const displaySelectedOptionId = historicalEntry
    ? historicalEntry.selectedOptionId
    : selectedOptionId;
  const displayIsSubmitted = historicalEntry ? true : isSubmitted; // Historical entries are always "submitted"
  const displayDisplayedOptions = historicalEntry
    ? historicalEntry.displayedOptions
    : displayedOptionsCache;

  const handleImportFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      onImportQuestionStateFromFile(file);
    }
    if (importFileInputRef.current) {
      importFileInputRef.current.value = ''; // Reset file input
    }
  };

  const triggerImportFileInput = () => {
    importFileInputRef.current?.click();
  };

  console.log('Quiz Session - isSubmitted:', displayIsSubmitted);
  console.log('Quiz Session - question:', displayQuestion.questionId);
  console.log('Quiz Session - isViewingHistoricalEntry:', isViewingHistoricalEntry);

  // FIXED: Stable display options for historical view
  useEffect(() => {
    if (isViewingHistoricalEntry && historicalEntry) {
      // Use historical displayed options directly
      setDisplayedOptionsCache(historicalEntry.displayedOptions);
      setTargetCorrectOptionForFeedback(null); // Not relevant for historical views
      console.log(
        `Using historical options for question: ${historicalEntry.questionSnapshot.questionId}`,
      );
      return;
    }

    // Generate options only for live questions (not historical)
    console.log(`=== Generating options for live question: ${question.questionId} ===`);

    const generateDisplayedOptions = (): DisplayedOption[] => {
      const maxDisplayOptions = 5;
      const correctOptions = question.options.filter((opt) =>
        question.correctOptionIds.includes(opt.optionId),
      );
      const incorrectOptions = question.options.filter(
        (opt) => !question.correctOptionIds.includes(opt.optionId),
      );

      const shownIncorrectIds = question.shownIncorrectOptionIds || [];
      const unshownIncorrectOptions = incorrectOptions.filter(
        (opt) => !shownIncorrectIds.includes(opt.optionId),
      );
      const shownIncorrectOptions = incorrectOptions.filter((opt) =>
        shownIncorrectIds.includes(opt.optionId),
      );

      const selectedOptions: DisplayedOption[] = [];

      if (correctOptions.length > 0) {
        const correctIndex = question.srsLevel ? question.srsLevel % correctOptions.length : 0;
        const selectedCorrectOption = correctOptions[correctIndex] || correctOptions[0];
        selectedOptions.push({
          ...selectedCorrectOption,
          isCorrect: true,
        });
      }

      const remainingSlots = maxDisplayOptions - selectedOptions.length;

      const shuffledUnshown = [...unshownIncorrectOptions].sort(() => Math.random() - 0.5);
      for (let i = 0; i < Math.min(remainingSlots, shuffledUnshown.length); i++) {
        selectedOptions.push({
          ...shuffledUnshown[i],
          isCorrect: false,
        });
      }

      const remainingSlotsAfterUnshown = maxDisplayOptions - selectedOptions.length;
      if (remainingSlotsAfterUnshown > 0 && shownIncorrectOptions.length > 0) {
        const shuffledShown = [...shownIncorrectOptions].sort(() => Math.random() - 0.5);
        for (let i = 0; i < Math.min(remainingSlotsAfterUnshown, shuffledShown.length); i++) {
          selectedOptions.push({
            ...shuffledShown[i],
            isCorrect: false,
          });
        }
      }

      const remainingSlotsAfterIncorrect = maxDisplayOptions - selectedOptions.length;
      const remainingCorrect = correctOptions.filter(
        (opt) => !selectedOptions.some((selected) => selected.optionId === opt.optionId),
      );

      for (let i = 0; i < Math.min(remainingSlotsAfterIncorrect, remainingCorrect.length); i++) {
        selectedOptions.push({
          ...remainingCorrect[i],
          isCorrect: true,
        });
      }

      const finalOptions = selectedOptions.sort(() => Math.random() - 0.5);

      console.log(`Generated ${finalOptions.length} options for display:`);
      finalOptions.forEach((opt, index) => {
        console.log(`  ${index + 1}. ${opt.optionId} (${opt.isCorrect ? 'CORRECT' : 'incorrect'})`);
      });

      return finalOptions;
    };

    const newDisplayedOptions = generateDisplayedOptions();
    setDisplayedOptionsCache(newDisplayedOptions);
    setTargetCorrectOptionForFeedback(null);

    console.log(
      `Options cached for question ${question.questionId} - will remain stable during feedback`,
    );
  }, [question.questionId, isViewingHistoricalEntry, historicalEntry]);

  // FIXED: Accurate feedback for historical answers
  const getOptionDisplayState = (option: DisplayedOption) => {
    if (isViewingHistoricalEntry && historicalEntry) {
      // Historical view logic
      const isSelected = historicalEntry.selectedOptionId === option.optionId;
      const userWasCorrect = historicalEntry.isCorrect;
      const optionIsActuallyCorrect = historicalEntry.questionSnapshot.correctOptionIds.includes(
        option.optionId,
      );

      if (isSelected) {
        return {
          isSelected: true,
          showAsCorrect: userWasCorrect,
          showAsIncorrect: !userWasCorrect,
        };
      } else {
        // Not selected by user - highlight correct answer if user was wrong
        return {
          isSelected: false,
          showAsCorrect: !userWasCorrect && optionIsActuallyCorrect,
          showAsIncorrect: false,
        };
      }
    }

    // Live question logic (existing)
    if (!displayIsSubmitted) {
      return {
        isSelected: displaySelectedOptionId === option.optionId,
        showAsCorrect: false,
        showAsIncorrect: false,
      };
    }

    const isSelected = displaySelectedOptionId === option.optionId;
    const isCorrectOption = displayQuestion.correctOptionIds.includes(option.optionId);
    const selectedWasCorrect = displaySelectedOptionId
      ? displayQuestion.correctOptionIds.includes(displaySelectedOptionId)
      : false;

    if (selectedWasCorrect) {
      return {
        isSelected,
        showAsCorrect: isSelected && isCorrectOption,
        showAsIncorrect: false,
      };
    } else {
      if (isSelected) {
        return {
          isSelected,
          showAsCorrect: false,
          showAsIncorrect: true,
        };
      } else if (option.optionId === targetCorrectOptionForFeedback) {
        return {
          isSelected: false,
          showAsCorrect: true,
          showAsIncorrect: false,
        };
      } else {
        return {
          isSelected: false,
          showAsCorrect: false,
          showAsIncorrect: false,
        };
      }
    }
  };

  const handleSubmitAnswer = () => {
    if (!selectedOptionId || isViewingHistoricalEntry) return;

    // Add validation for correctOptionIds
    if (!question.correctOptionIds || !Array.isArray(question.correctOptionIds)) {
      console.error('Question missing correctOptionIds:', question.questionId);
      return;
    }

    console.log(`=== Submitting answer for question: ${question.questionId} ===`);
    console.log(`Selected option: ${selectedOptionId}`);
    console.log(
      `Options being submitted:`,
      displayedOptionsCache.map((opt) => opt.optionId),
    );

    const selectedWasCorrect = question.correctOptionIds.includes(selectedOptionId);

    // Announce the result to screen readers
    if (selectedWasCorrect) {
      announce('Answer is correct!');
    } else {
      announce('Answer is incorrect. The correct answer is provided below.');
    }

    if (!selectedWasCorrect) {
      const displayedCorrectOptions = displayedOptionsCache.filter((opt) =>
        question.correctOptionIds.includes(opt.optionId),
      );

      if (displayedCorrectOptions.length > 0) {
        const targetOption =
          question.correctOptionIds.find((correctId) =>
            displayedCorrectOptions.some((displayed) => displayed.optionId === correctId),
          ) || displayedCorrectOptions[0].optionId;

        setTargetCorrectOptionForFeedback(targetOption);
        console.log(`Set target correct option for feedback: ${targetOption}`);
      } else {
        setTargetCorrectOptionForFeedback(question.correctOptionIds[0]);
        console.log(`Fallback target correct option: ${question.correctOptionIds[0]}`);
      }
    }

    onSubmitAnswer(displayedOptionsCache);
  };

  const processExplanationText = (explanationText: string): string => {
    let processedText = explanationText;

    // First, handle option IDs wrapped in <code> tags (existing functionality)
    processedText = processedText.replace(/<code>(.*?)<\/code>/g, (match, optionId) => {
      const option = displayQuestion.options.find((opt) => opt.optionId === optionId);
      if (option) {
        return `<code>${option.optionText}</code>`;
      } else {
        console.warn(`Option ID ${optionId} not found in question ${displayQuestion.questionId}`);
        return match;
      }
    });

    // Then, replace any bare option IDs with their corresponding option text
    // This handles option IDs that appear directly in the explanation text
    displayQuestion.options.forEach((option) => {
      const optionIdPattern = new RegExp(
        `\\b${option.optionId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`,
        'g',
      );

      processedText = processedText.replace(optionIdPattern, (match) => {
        // Check if this option ID is the currently selected option
        const isSelectedOption = displaySelectedOptionId === option.optionId;

        if (isSelectedOption) {
          // Highlight the selected option text
          return `<strong class="text-blue-300">"${option.optionText}"</strong>`;
        } else {
          // Regular option text replacement
          return `"${option.optionText}"`;
        }
      });
    });

    return processedText;
  };

  // Enhanced chapter name parsing for better formatting
  const parseChapterName = (name: string) => {
    // Match patterns like "Chapter X:" or "Chapter XX:" at the beginning
    const chapterMatch = name.match(/^(Chapter\s+\d+):\s*(.*)$/i);

    if (chapterMatch) {
      return {
        chapterNumber: chapterMatch[1], // e.g., "Chapter 1"
        chapterTitle: chapterMatch[2].trim(), // e.g., "Fundamentals of Algorithms & Complexity"
        hasChapterNumber: true,
      };
    }

    // Fallback for names that don't follow the "Chapter X:" pattern
    return {
      chapterNumber: '',
      chapterTitle: name,
      hasChapterNumber: false,
    };
  };

  const getHeaderTitle = () => {
    if (isReviewSession) {
      return `Review Session`;
    }
    return parseChapterName(chapter.name);
  };

  const getProgressInfo = () => {
    if (isReviewSession) {
      return '';
    }
    return 'Chapter Progress';
  };

  const headerInfo = getHeaderTitle();

  // FIXED: Navigation button visibility and state logic using props
  const canViewPrevious =
    isViewingHistoricalEntry || (isSubmitted && sessionHistory && sessionHistory.length > 0);

  const canViewNextInHistory =
    isViewingHistoricalEntry &&
    currentHistoryViewIndex !== null &&
    currentHistoryViewIndex < sessionHistory.length - 1;

  const shouldShowNextQuestion =
    (!isViewingHistoricalEntry && isSubmitted) ||
    (isViewingHistoricalEntry &&
      currentHistoryViewIndex !== null &&
      currentHistoryViewIndex === sessionHistory.length - 1);

  // Calculate progress and score percentages
  const progressPercentage = useMemo(() => {
    return totalQuestions > 0 ? Math.round(((currentQuestionIndex + 1) / totalQuestions) * 100) : 0;
  }, [currentQuestionIndex, totalQuestions]);

  const scorePercentage = useMemo(() => {
    if (!currentModule) return 0;
    const currentChapter = currentModule.chapters.find((c) => c.id === chapter.id);
    if (!currentChapter) return 0;
    return currentChapter.totalQuestions > 0
      ? Math.round((currentChapter.correctAnswers / currentChapter.totalQuestions) * 100)
      : 0;
  }, [currentModule, chapter.id]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-black via-slate-950 to-gray-950">
      {/* Fixed Progress and Score Bar */}
      <div className="sticky top-0 z-50 border-b border-slate-700 bg-gradient-to-r from-slate-900/95 to-slate-800/95 shadow-lg backdrop-blur-md">
        <div className="mx-auto max-w-4xl px-4 py-3">
          <div className="flex items-center gap-4">
            {/* Progress Section */}
            <div className="flex flex-1 items-center gap-3">
              <span className="min-w-[3rem] text-right text-lg font-medium text-blue-300">
                {progressPercentage}%
              </span>
              <ProgressBar
                current={currentQuestionIndex + 1}
                total={totalQuestions}
                variant="default"
                showText={false}
                showPercentage={false}
                className="h-2 flex-1"
              />
            </div>

            {/* Score Section */}
            <div className="flex items-center gap-3">
              <Brain className="h-5 w-5 flex-shrink-0 text-green-300" />
              <span className="whitespace-nowrap text-sm font-medium text-green-300">Score:</span>
              <CircularProgress value={scorePercentage} size={32} className="text-green-400" />
            </div>
          </div>
        </div>
      </div>

      <div className="p-4 pt-8 sm:pt-12">
        <div className="mx-auto max-w-4xl space-y-6">
          {/* Enhanced Header with improved formatting */}
          <div className="mb-8 flex flex-col gap-4 lg:flex-row lg:items-start lg:justify-between">
            <div className="min-w-0 flex-1">
              <div className="mb-2 flex items-start gap-3">
                <div className="min-w-0 flex-1">
                  {isReviewSession ? (
                    <div>
                      <h1 className="hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                        Review Session
                      </h1>
                      <div className="mt-2">
                        {/* Display the chapter name for the current review question */}
                        {(() => {
                          // Get chapter name for display
                          const chapterNameForDisplay =
                            isViewingHistoricalEntry && historicalEntry
                              ? currentModule?.chapters.find(
                                  (c) => c.id === historicalEntry.chapterId,
                                )?.name || chapter.name
                              : chapter.name;

                          const parsedChapterName = parseChapterName(chapterNameForDisplay);

                          if (parsedChapterName.hasChapterNumber) {
                            return (
                              <div>
                                <div className="break-words text-lg font-medium text-orange-300">
                                  {parsedChapterName.chapterNumber}
                                </div>
                                <div className="mt-1 break-words text-xl font-medium leading-tight text-orange-200">
                                  {parsedChapterName.chapterTitle}
                                </div>
                              </div>
                            );
                          } else {
                            return (
                              <p className="mt-1 break-words text-lg font-medium text-orange-300">
                                {parsedChapterName.chapterTitle}
                              </p>
                            );
                          }
                        })()}
                      </div>
                    </div>
                  ) : (
                    <div>
                      {typeof headerInfo === 'object' && headerInfo.hasChapterNumber ? (
                        <div>
                          <div className="hyphens-auto break-words text-xl font-semibold text-blue-300">
                            {headerInfo.chapterNumber}
                          </div>
                          <h1 className="mt-1 hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                            {headerInfo.chapterTitle}
                          </h1>
                        </div>
                      ) : (
                        <h1 className="hyphens-auto break-words text-3xl font-bold leading-tight text-white">
                          {typeof headerInfo === 'string' ? headerInfo : chapter.name}
                        </h1>
                      )}
                    </div>
                  )}
                </div>
              </div>
              <p className="break-words text-base text-gray-400">{getProgressInfo()}</p>
              {isReviewSession &&
                displayQuestion.srsLevel !== undefined &&
                displayQuestion.srsLevel > 0 && (
                  <p className="mt-2 text-sm text-blue-400">
                    SRS Level: {displayQuestion.srsLevel}
                  </p>
                )}
            </div>

            <TooltipProvider>
              <div className="flex gap-2">
                {/* NEW: View All Questions Button */}
                {onViewAllQuestions && !isReviewSession && (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        onClick={onViewAllQuestions}
                        variant="outline"
                        size="sm"
                        className="h-10 w-10 flex-shrink-0 border-purple-700 bg-purple-900/40 p-0 text-purple-200 transition-all duration-200 hover:border-purple-600 hover:bg-purple-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-purple-500 active:bg-purple-800/80"
                      >
                        <List className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>View All Questions</p>
                    </TooltipContent>
                  </Tooltip>
                )}

                {/* Retry Chapter Button - Only visible for regular quizzes */}
                {!isReviewSession && (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        onClick={onRetryChapter}
                        variant="outline"
                        size="sm"
                        className="h-10 w-10 flex-shrink-0 border-orange-700 bg-orange-900/40 p-0 text-orange-200 transition-all duration-200 hover:border-orange-600 hover:bg-orange-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-orange-500 active:bg-orange-800/80"
                      >
                        <RotateCcw className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Retry Chapter</p>
                    </TooltipContent>
                  </Tooltip>
                )}

                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      onClick={onBackToDashboard}
                      variant="outline"
                      size="sm"
                      className="h-10 w-10 flex-shrink-0 border-gray-700 bg-gray-900/70 p-0 text-gray-200 transition-all duration-200 hover:border-gray-600 hover:bg-gray-800 hover:text-white focus-visible:ring-2 focus-visible:ring-gray-500 active:bg-gray-800/80"
                    >
                      <Home className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Return to Dashboard</p>
                  </TooltipContent>
                </Tooltip>
              </div>
            </TooltipProvider>
          </div>

          {/* Anki-style Progress Bars - Enhanced spacing */}
          {isReviewSession && srsProgressCounts && (
            <Card className="mb-8 border-indigo-700 bg-gradient-to-r from-indigo-950 to-purple-950 shadow-sm backdrop-blur-sm">
              <CardHeader className="pb-4">
                <CardTitle className="flex flex-wrap items-center gap-2 text-lg text-white">
                  <Brain className="h-5 w-5 flex-shrink-0 text-indigo-400" />
                  <span className="break-words">Review Progress</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
                  <div className="space-y-3">
                    <div className="flex items-center justify-between gap-2">
                      <span className="flex min-w-0 flex-1 items-center gap-1 text-sm font-medium text-red-300">
                        <Clock className="h-4 w-4 flex-shrink-0" />
                        <span className="break-words">New/Lapsing (Due Now)</span>
                      </span>
                      <span className="flex-shrink-0 text-sm tabular-nums text-red-200">
                        {srsProgressCounts.newOrLapsingDue}
                      </span>
                    </div>
                    <div className="h-2.5 w-full rounded-full bg-gray-700">
                      <div
                        className="h-2.5 rounded-full bg-yellow-500 transition-all duration-300"
                        style={{
                          width: `${srsProgressCounts.totalNonMastered > 0 ? (srsProgressCounts.newOrLapsingDue / srsProgressCounts.totalNonMastered) * 100 : 0}%`,
                        }}
                      />
                    </div>
                  </div>

                  <div className="space-y-3">
                    <div className="flex items-center justify-between gap-2">
                      <span className="flex min-w-0 flex-1 items-center gap-1 text-sm font-medium text-blue-300">
                        <Clock className="h-4 w-4 flex-shrink-0" />
                        <span className="break-words">Learning Pipeline</span>
                      </span>
                      <span className="flex-shrink-0 text-sm tabular-nums text-blue-200">
                        {srsProgressCounts.learningReviewDue}
                      </span>
                    </div>
                    <div className="h-2.5 w-full rounded-full bg-gray-700">
                      <div
                        className="h-2.5 rounded-full bg-blue-500 transition-all duration-300"
                        style={{
                          width: `${srsProgressCounts.totalNonMastered > 0 ? (srsProgressCounts.learningReviewDue / srsProgressCounts.totalNonMastered) * 100 : 0}%`,
                        }}
                      />
                    </div>
                  </div>
                </div>

                <div className="border-t border-indigo-800 pt-4 text-center">
                  <span className="break-words text-sm text-indigo-200">
                    Active Workload:{' '}
                    {srsProgressCounts.newOrLapsingDue + srsProgressCounts.learningReviewDue} of{' '}
                    {srsProgressCounts.totalNonMastered} non-mastered
                  </span>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Question Navigation Grid - Accessible keyboard navigation */}
          <Card className="mb-6 border-slate-700 bg-slate-900/50 shadow-sm backdrop-blur-sm">
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <h3 className="text-lg font-medium text-white">Question Navigation</h3>
                <div className="text-sm font-medium tabular-nums text-gray-300">
                  {Math.round((sessionHistory.length / chapter.questions.length) * 100)}% Complete
                </div>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              <AccessibleQuestionGrid
                questions={chapter.questions}
                currentQuestionIndex={currentQuestionIndex}
                sessionHistory={sessionHistory}
                currentHistoryViewIndex={currentHistoryViewIndex}
                onNavigateToQuestion={onNavigateToQuestion}
                isReviewSession={isReviewSession}
              />

              {/* Status Legend */}
              <div className="flex flex-wrap gap-4 border-t border-slate-700 pt-2 text-xs text-gray-400">
                <div className="flex items-center gap-1.5">
                  <div className="h-3 w-3 rounded border border-blue-600 bg-gradient-to-r from-blue-900 to-blue-800"></div>
                  <span>Current</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className="h-3 w-3 rounded border border-green-700 bg-gradient-to-r from-green-950 to-green-900"></div>
                  <span>Correct</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className="h-3 w-3 rounded border border-red-700 bg-gradient-to-r from-red-950 to-red-900"></div>
                  <span>Incorrect</span>
                </div>
                <div className="flex items-center gap-1.5">
                  <div className="h-3 w-3 rounded border border-gray-600 bg-gradient-to-r from-slate-800 to-gray-800"></div>
                  <span>Unanswered</span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Question Card - Enhanced styling */}
          <Card className="border-slate-700 bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 shadow-lg backdrop-blur-sm">
            <CardHeader>
              <CardTitle className="break-words text-lg text-white">
                {isReviewSession ? `Review Question` : `Question ${currentQuestionIndex + 1}`}
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="prose prose-invert max-w-none">
                <MarkdownRenderer
                  markdown={displayQuestion.questionText}
                  className="break-words text-lg leading-relaxed text-white"
                />
              </div>
            </CardContent>
          </Card>

          {/* Options - Accessible layout */}
          <div className="space-y-4">
            <h3 className="break-words text-lg font-semibold text-white">Choose your answer:</h3>
            <AccessibleOptionList
              options={displayDisplayedOptions}
              selectedOptionId={displaySelectedOptionId}
              onSelectOption={onSelectOption}
              isSubmitted={displayIsSubmitted}
              disabled={displayIsSubmitted || isViewingHistoricalEntry}
            />
          </div>

          {/* Explanation - Enhanced styling */}
          {displayIsSubmitted && (
            <Card className="border-slate-700 bg-gradient-to-r from-slate-900 to-slate-950 shadow-lg backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-lg text-slate-200">Explanation</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="prose prose-invert max-w-none">
                  <MarkdownRenderer
                    key={`explanation-${displayQuestion.questionId}-${displayIsSubmitted}`}
                    markdown={processExplanationText(displayQuestion.explanationText)}
                    className="break-words text-base leading-relaxed text-white"
                  />
                </div>
              </CardContent>
            </Card>
          )}

          {/* Action Buttons - Enhanced with history navigation */}
          <div className="flex flex-col items-stretch gap-4 pt-4 sm:flex-row sm:items-center sm:justify-end">
            <div className="flex flex-wrap justify-center gap-2 sm:justify-end">
              {/* Import/Export Question State Buttons - Only show for live questions */}
              {!isViewingHistoricalEntry && (
                <TooltipProvider>
                  <div className="flex gap-2">
                    <input
                      ref={importFileInputRef}
                      type="file"
                      accept=".json,application/json"
                      onChange={handleImportFileSelect}
                      className="hidden"
                    />
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button
                          onClick={onExportCurrentQuestionState}
                          variant="outline"
                          size="sm"
                          className="h-10 w-10 border-green-700 bg-green-900/40 p-0 text-green-200 transition-all duration-200 hover:border-green-600 hover:bg-green-800/50 hover:text-white"
                        >
                          <Download className="h-4 w-4" />
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Export current question state to JSON file</p>
                      </TooltipContent>
                    </Tooltip>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button
                          onClick={triggerImportFileInput}
                          variant="outline"
                          size="sm"
                          className="h-10 w-10 border-purple-700 bg-purple-900/40 p-0 text-purple-200 transition-all duration-200 hover:border-purple-600 hover:bg-purple-800/50 hover:text-white"
                        >
                          <Upload className="h-4 w-4" />
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Import question(s) from JSON file</p>
                      </TooltipContent>
                    </Tooltip>

                    {/* Edit Mode Buttons - Phase 1 */}
                    {onSetEditMode && onSaveQuestion && onDeleteQuestion && (
                      <>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button
                              onClick={() => onSetEditMode(displayQuestion)}
                              variant="outline"
                              size="sm"
                              className="h-10 w-10 border-yellow-700 bg-yellow-900/40 p-0 text-yellow-200 transition-all duration-200 hover:border-yellow-600 hover:bg-yellow-800/50 hover:text-white"
                              disabled={isEditModeActive}
                            >
                              <Edit className="h-4 w-4" />
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent>
                            <p>Edit current question</p>
                          </TooltipContent>
                        </Tooltip>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button
                              onClick={() => {
                                if (generateUniqueQuestionId) {
                                  const newQuestionId = generateUniqueQuestionId(chapter.id);
                                  const newQuestion: QuizQuestion = {
                                    questionId: newQuestionId,
                                    questionText: '',
                                    options: [],
                                    correctOptionIds: [],
                                    explanationText: '',
                                    status: 'not_attempted',
                                    timesAnsweredCorrectly: 0,
                                    timesAnsweredIncorrectly: 0,
                                    historyOfIncorrectSelections: [],
                                    srsLevel: 0,
                                    nextReviewAt: null,
                                    shownIncorrectOptionIds: [],
                                  };
                                  onSetEditMode(newQuestion);
                                }
                              }}
                              variant="outline"
                              size="sm"
                              className="h-10 w-10 border-cyan-700 bg-cyan-900/40 p-0 text-cyan-200 transition-all duration-200 hover:border-cyan-600 hover:bg-cyan-800/50 hover:text-white"
                              disabled={isEditModeActive}
                            >
                              <Plus className="h-4 w-4" />
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent>
                            <p>Add new question</p>
                          </TooltipContent>
                        </Tooltip>
                      </>
                    )}
                  </div>
                </TooltipProvider>
              )}

              {/* FIXED: Previous Answer Button */}
              {canViewPrevious && onViewPrevious && (
                <Button
                  onClick={onViewPrevious}
                  disabled={isViewingHistoricalEntry && currentHistoryViewIndex === 0}
                  variant="outline"
                  className="border-gray-700 bg-gray-900/40 text-gray-200 transition-all duration-200 hover:border-gray-600 hover:bg-gray-800/50 hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                >
                  <ArrowLeft className="mr-2 h-4 w-4" />
                  Previous Answer
                </Button>
              )}

              {/* Submit Answer Button - Only for live questions */}
              {!displayIsSubmitted && !isViewingHistoricalEntry && (
                <Button
                  onClick={handleSubmitAnswer}
                  disabled={!selectedOptionId}
                  className="whitespace-nowrap bg-blue-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-blue-800 focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 active:bg-blue-900"
                >
                  <Send className="mr-2 h-4 w-4" />
                  Submit Answer
                </Button>
              )}

              {/* FIXED: Next Answer Button (for history navigation) */}
              {canViewNextInHistory && onViewNextInHistory && (
                <Button
                  onClick={onViewNextInHistory}
                  className="whitespace-nowrap bg-purple-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-purple-800 focus-visible:ring-2 focus-visible:ring-purple-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 active:bg-purple-900"
                >
                  Next Answer
                  <ArrowRight className="ml-2 h-4 w-4" />
                </Button>
              )}

              {/* FIXED: Next Question Button - For advancing to actual next question */}
              {shouldShowNextQuestion && (
                <Button
                  onClick={onNextQuestion}
                  className="whitespace-nowrap bg-green-700 px-6 text-white shadow-sm transition-all duration-200 hover:bg-green-800 focus-visible:ring-2 focus-visible:ring-green-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 active:bg-green-900"
                >
                  {isReviewSession ? 'Next Review' : 'Next Question'}
                  <ArrowRight className="ml-2 h-4 w-4" />
                </Button>
              )}
            </div>
          </div>

          {/*
                  />
                </Button>
              )}
            </div>
          </div>

          {/* Question Editor Modal - Phase 2 */}
          {isEditModeActive &&
            editingQuestionData &&
            onSetEditMode &&
            onSaveQuestion &&
            onDeleteQuestion && (
              <QuestionEditor
                isOpen={isEditModeActive}
                question={editingQuestionData}
                chapterId={chapter.id}
                onSave={onSaveQuestion}
                onCancel={() => onSetEditMode(null)}
                onDelete={onDeleteQuestion}
                generateUniqueOptionId={generateUniqueOptionId}
              />
            )}
        </div>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\rendering\MarkdownRenderer.tsx
SIZE: 2,614 bytes | LINES: 87
================================================================================
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { processMarkdown } from '@/lib/markdown/pipeline';

type Props = {
  markdown: string;
  className?: string;
};

// Feature flag (default ON). In Next.js client code, env is compiled in at build time.
const USE_SECURE_RENDERER: boolean =
  (process.env.NEXT_PUBLIC_USE_SECURE_RENDERER ?? 'true') !== 'false';

type RenderState = {
  html: string;
  // When pipeline prunes/rewrites dangerous content (or we detect disallowed patterns).
  sanitized: boolean;
  error?: string;
};

/**
 * Secure Markdown renderer (single source of dangerouslySetInnerHTML)
 * - Uses the unified pipeline in lib/markdown/pipeline (remark-parse/gfm/math → rehype-katex → rehype-sanitize).
 * - Blocks javascript: URLs / inline handlers if anything slipped past.
 */
export function MarkdownRenderer({ markdown, className }: Props) {
  const [state, setState] = useState<RenderState>({ html: '', sanitized: false });

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (!USE_SECURE_RENDERER) {
          // Safety net if the flag is off: render as plaintext paragraph.
          const escaped = markdown
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          if (!cancelled) setState({ html: `<p>${escaped}</p>`, sanitized: true });
          return;
        }
        const html = await processMarkdown(markdown);

        // Final belt-and-suspenders gate before HTML insertion.
        const disallowed = /<script\b|\\son\\w+=|javascript:/i.test(html);
        if (!cancelled) {
          setState({
            html: disallowed ? '<p>Content blocked for security reasons.</p>' : html,
            sanitized: disallowed,
          });
        }
      } catch (e: any) {
        if (!cancelled) {
          setState({
            html: '<p>Error rendering content.</p>',
            sanitized: true,
            error: String(e?.message ?? e),
          });
        }
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [markdown]);

  const note = useMemo(() => {
    if (!state.sanitized) return null;
    return (
      <div
        role="note"
        className="mb-2 rounded border-l-4 border-amber-400 bg-amber-50 p-2 text-sm text-amber-600"
      >
        <strong>Note:</strong> Some unsafe content was removed for security reasons.
      </div>
    );
  }, [state.sanitized]);

  return (
    <div className={className}>
      {note}
      <div dangerouslySetInnerHTML={{ __html: state.html }} />
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\theme-provider.tsx
SIZE: 291 bytes | LINES: 9
================================================================================
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider, type ThemeProviderProps } from 'next-themes';

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\toast-notification.tsx
SIZE: 3,473 bytes | LINES: 118
================================================================================
'use client';
import { useState, useEffect } from 'react';
import { X, CheckCircle, AlertCircle, Info, AlertTriangle } from 'lucide-react';
import { Card } from '@/components/ui/card';

export interface Toast {
  id: string;
  type: 'success' | 'error' | 'info' | 'warning';
  title: string;
  message?: string;
  duration?: number;
}

interface ToastNotificationProps {
  toast: Toast;
  onRemove: (id: string) => void;
}

export function ToastNotification({ toast, onRemove }: ToastNotificationProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [isExiting, setIsExiting] = useState(false);

  useEffect(() => {
    // Trigger entrance animation
    const timer = setTimeout(() => setIsVisible(true), 50);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    // Auto-remove after duration
    const duration = toast.duration || 5000;
    const timer = setTimeout(() => {
      handleRemove();
    }, duration);

    return () => clearTimeout(timer);
  }, [toast.duration]);

  const handleRemove = () => {
    setIsExiting(true);
    setTimeout(() => {
      onRemove(toast.id);
    }, 300); // Match exit animation duration
  };

  const getIcon = () => {
    switch (toast.type) {
      case 'success':
        return <CheckCircle className="h-5 w-5 text-green-400" />;
      case 'error':
        return <AlertCircle className="h-5 w-5 text-red-400" />;
      case 'warning':
        return <AlertTriangle className="h-5 w-5 text-yellow-400" />;
      case 'info':
      default:
        return <Info className="h-5 w-5 text-blue-400" />;
    }
  };

  const getColorClasses = () => {
    switch (toast.type) {
      case 'success':
        return 'border-green-700 bg-green-950/90';
      case 'error':
        return 'border-red-700 bg-red-950/90';
      case 'warning':
        return 'border-yellow-700 bg-yellow-950/90';
      case 'info':
      default:
        return 'border-blue-700 bg-blue-950/90';
    }
  };

  return (
    <Card
      className={` ${getColorClasses()} min-w-[300px] max-w-[500px] border-2 shadow-lg backdrop-blur-sm transition-all duration-300 ease-in-out ${isVisible && !isExiting ? 'translate-x-0 opacity-100' : 'translate-x-full opacity-0'} ${isExiting ? 'scale-95' : 'scale-100'} `}
    >
      <div className="flex items-start gap-3 p-4">
        <div className="mt-0.5 flex-shrink-0">{getIcon()}</div>

        <div className="min-w-0 flex-1">
          <h4 className="text-sm font-medium text-white">{toast.title}</h4>
          {toast.message && (
            <p className="mt-1 text-sm leading-relaxed text-gray-300">{toast.message}</p>
          )}
        </div>

        <button
          onClick={handleRemove}
          className="flex-shrink-0 rounded p-1 text-gray-400 transition-colors duration-200 hover:bg-white/10 hover:text-white"
          aria-label="Close notification"
        >
          <X className="h-4 w-4" />
        </button>
      </div>
    </Card>
  );
}

interface ToastContainerProps {
  toasts: Toast[];
  onRemoveToast: (id: string) => void;
}

export function ToastContainer({ toasts, onRemoveToast }: ToastContainerProps) {
  if (toasts.length === 0) return null;

  return (
    <div className="pointer-events-none fixed right-4 top-4 z-50 space-y-3">
      {toasts.map((toast) => (
        <div key={toast.id} className="pointer-events-auto">
          <ToastNotification toast={toast} onRemove={onRemoveToast} />
        </div>
      ))}
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\accordion.tsx
SIZE: 1,991 bytes | LINES: 55
================================================================================
'use client';

import * as React from 'react';
import * as AccordionPrimitive from '@radix-ui/react-accordion';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn('border-b', className)} {...props} />
));
AccordionItem.displayName = 'AccordionItem';

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        'flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180',
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn('pb-4 pt-0', className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\alert-dialog.tsx
SIZE: 4,366 bytes | LINES: 118
================================================================================
'use client';

import * as React from 'react';
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
);
AlertDialogHeader.displayName = 'AlertDialogHeader';

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
AlertDialogFooter.displayName = 'AlertDialogFooter';

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold', className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: 'outline' }), 'mt-2 sm:mt-0', className)}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\alert.tsx
SIZE: 1,575 bytes | LINES: 50
================================================================================
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div ref={ref} role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
));
Alert.displayName = 'Alert';

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5
      ref={ref}
      className={cn('mb-1 font-medium leading-none tracking-tight', className)}
      {...props}
    />
  ),
);
AlertTitle.displayName = 'AlertTitle';

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('text-sm [&_p]:leading-relaxed', className)} {...props} />
));
AlertDescription.displayName = 'AlertDescription';

export { Alert, AlertTitle, AlertDescription };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\aspect-ratio.tsx
SIZE: 158 bytes | LINES: 8
================================================================================
'use client';

import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio';

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\avatar.tsx
SIZE: 1,413 bytes | LINES: 48
================================================================================
'use client';

import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';

import { cn } from '@/lib/utils';

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn('relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full', className)}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className,
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\badge.tsx
SIZE: 1,115 bytes | LINES: 34
================================================================================
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default: 'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\breadcrumb.tsx
SIZE: 2,749 bytes | LINES: 102
================================================================================
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<'nav'> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = 'Breadcrumb';

const BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<'ol'>>(
  ({ className, ...props }, ref) => (
    <ol
      ref={ref}
      className={cn(
        'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',
        className,
      )}
      {...props}
    />
  ),
);
BreadcrumbList.displayName = 'BreadcrumbList';

const BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<'li'>>(
  ({ className, ...props }, ref) => (
    <li ref={ref} className={cn('inline-flex items-center gap-1.5', className)} {...props} />
  ),
);
BreadcrumbItem.displayName = 'BreadcrumbItem';

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<'a'> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      className={cn('transition-colors hover:text-foreground', className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = 'BreadcrumbLink';

const BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<'span'>>(
  ({ className, ...props }, ref) => (
    <span
      ref={ref}
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn('font-normal text-foreground', className)}
      {...props}
    />
  ),
);
BreadcrumbPage.displayName = 'BreadcrumbPage';

const BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<'li'>) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn('[&>svg]:h-3.5 [&>svg]:w-3.5', className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = 'BreadcrumbSeparator';

const BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<'span'>) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = 'BreadcrumbElipssis';

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\button.tsx
SIZE: 1,854 bytes | LINES: 50
================================================================================
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
    );
  },
);
Button.displayName = 'Button';

export { Button, buttonVariants };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\calendar.tsx
SIZE: 7,291 bytes | LINES: 178
================================================================================
'use client';

import * as React from 'react';
import { ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon } from 'lucide-react';
import { DayButton, DayPicker, getDefaultClassNames } from 'react-day-picker';

import { cn } from '@/lib/utils';
import { Button, buttonVariants } from '@/components/ui/button';

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = 'label',
  buttonVariant = 'ghost',
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>['variant'];
}) {
  const defaultClassNames = getDefaultClassNames();

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        'group/calendar bg-background p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent',
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) => date.toLocaleString('default', { month: 'short' }),
        ...formatters,
      }}
      classNames={{
        root: cn('w-fit', defaultClassNames.root),
        months: cn('flex gap-4 flex-col md:flex-row relative', defaultClassNames.months),
        month: cn('flex flex-col w-full gap-4', defaultClassNames.month),
        nav: cn(
          'flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between',
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          'size-[--cell-size] aria-disabled:opacity-50 p-0 select-none',
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          'size-[--cell-size] aria-disabled:opacity-50 p-0 select-none',
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          'flex items-center justify-center h-[--cell-size] w-full px-[--cell-size]',
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          'w-full flex items-center text-sm font-medium justify-center h-[--cell-size] gap-1.5',
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          'relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md',
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn('absolute bg-popover inset-0 opacity-0', defaultClassNames.dropdown),
        caption_label: cn(
          'select-none font-medium',
          captionLayout === 'label'
            ? 'text-sm'
            : 'rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5',
          defaultClassNames.caption_label,
        ),
        table: 'w-full border-collapse',
        weekdays: cn('flex', defaultClassNames.weekdays),
        weekday: cn(
          'text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none',
          defaultClassNames.weekday,
        ),
        week: cn('flex w-full mt-2', defaultClassNames.week),
        week_number_header: cn('select-none w-[--cell-size]', defaultClassNames.week_number_header),
        week_number: cn(
          'text-[0.8rem] select-none text-muted-foreground',
          defaultClassNames.week_number,
        ),
        day: cn(
          'relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none',
          defaultClassNames.day,
        ),
        range_start: cn('rounded-l-md bg-accent', defaultClassNames.range_start),
        range_middle: cn('rounded-none', defaultClassNames.range_middle),
        range_end: cn('rounded-r-md bg-accent', defaultClassNames.range_end),
        today: cn(
          'bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none',
          defaultClassNames.today,
        ),
        outside: cn(
          'text-muted-foreground aria-selected:text-muted-foreground',
          defaultClassNames.outside,
        ),
        disabled: cn('text-muted-foreground opacity-50', defaultClassNames.disabled),
        hidden: cn('invisible', defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return <div data-slot="calendar" ref={rootRef} className={cn(className)} {...props} />;
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === 'left') {
            return <ChevronLeftIcon className={cn('size-4', className)} {...props} />;
          }

          if (orientation === 'right') {
            return <ChevronRightIcon className={cn('size-4', className)} {...props} />;
          }

          return <ChevronDownIcon className={cn('size-4', className)} {...props} />;
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          );
        },
        ...components,
      }}
      {...props}
    />
  );
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames();

  const ref = React.useRef<HTMLButtonElement>(null);
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus();
  }, [modifiers.focused]);

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        'flex aspect-square w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-start=true]:rounded-l-md data-[range-end=true]:bg-primary data-[range-middle=true]:bg-accent data-[range-start=true]:bg-primary data-[selected-single=true]:bg-primary data-[range-end=true]:text-primary-foreground data-[range-middle=true]:text-accent-foreground data-[range-start=true]:text-primary-foreground data-[selected-single=true]:text-primary-foreground group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-[3px] group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground [&>span]:text-xs [&>span]:opacity-70',
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  );
}

export { Calendar, CalendarDayButton };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\card.tsx
SIZE: 1,829 bytes | LINES: 56
================================================================================
import * as React from 'react';

import { cn } from '@/lib/utils';

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('rounded-lg border bg-card text-card-foreground shadow-sm', className)}
      {...props}
    />
  ),
);
Card.displayName = 'Card';

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props} />
  ),
);
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('text-2xl font-semibold leading-none tracking-tight', className)}
      {...props}
    />
  ),
);
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('text-sm text-muted-foreground', className)} {...props} />
  ),
);
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
  ),
);
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex items-center p-6 pt-0', className)} {...props} />
  ),
);
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\carousel.tsx
SIZE: 6,214 bytes | LINES: 243
================================================================================
'use client';

import * as React from 'react';
import useEmblaCarousel, { type UseEmblaCarouselType } from 'embla-carousel-react';
import { ArrowLeft, ArrowRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: 'horizontal' | 'vertical';
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />');
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(({ orientation = 'horizontal', opts, setApi, plugins, className, children, ...props }, ref) => {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === 'horizontal' ? 'x' : 'y',
    },
    plugins,
  );
  const [canScrollPrev, setCanScrollPrev] = React.useState(false);
  const [canScrollNext, setCanScrollNext] = React.useState(false);

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) {
      return;
    }

    setCanScrollPrev(api.canScrollPrev());
    setCanScrollNext(api.canScrollNext());
  }, []);

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev();
  }, [api]);

  const scrollNext = React.useCallback(() => {
    api?.scrollNext();
  }, [api]);

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        scrollPrev();
      } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        scrollNext();
      }
    },
    [scrollPrev, scrollNext],
  );

  React.useEffect(() => {
    if (!api || !setApi) {
      return;
    }

    setApi(api);
  }, [api, setApi]);

  React.useEffect(() => {
    if (!api) {
      return;
    }

    onSelect(api);
    api.on('reInit', onSelect);
    api.on('select', onSelect);

    return () => {
      api?.off('select', onSelect);
    };
  }, [api, onSelect]);

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation: orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        ref={ref}
        onKeyDownCapture={handleKeyDown}
        className={cn('relative', className)}
        role="region"
        aria-roledescription="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  );
});
Carousel.displayName = 'Carousel';

const CarouselContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { carouselRef, orientation } = useCarousel();

    return (
      <div ref={carouselRef} className="overflow-hidden">
        <div
          ref={ref}
          className={cn(
            'flex',
            orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
            className,
          )}
          {...props}
        />
      </div>
    );
  },
);
CarouselContent.displayName = 'CarouselContent';

const CarouselItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { orientation } = useCarousel();

    return (
      <div
        ref={ref}
        role="group"
        aria-roledescription="slide"
        className={cn(
          'min-w-0 shrink-0 grow-0 basis-full',
          orientation === 'horizontal' ? 'pl-4' : 'pt-4',
          className,
        )}
        {...props}
      />
    );
  },
);
CarouselItem.displayName = 'CarouselItem';

const CarouselPrevious = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          'absolute h-8 w-8 rounded-full',
          orientation === 'horizontal'
            ? '-left-12 top-1/2 -translate-y-1/2'
            : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
          className,
        )}
        disabled={!canScrollPrev}
        onClick={scrollPrev}
        {...props}
      >
        <ArrowLeft className="h-4 w-4" />
        <span className="sr-only">Previous slide</span>
      </Button>
    );
  },
);
CarouselPrevious.displayName = 'CarouselPrevious';

const CarouselNext = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          'absolute h-8 w-8 rounded-full',
          orientation === 'horizontal'
            ? '-right-12 top-1/2 -translate-y-1/2'
            : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
          className,
        )}
        disabled={!canScrollNext}
        onClick={scrollNext}
        {...props}
      >
        <ArrowRight className="h-4 w-4" />
        <span className="sr-only">Next slide</span>
      </Button>
    );
  },
);
CarouselNext.displayName = 'CarouselNext';

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\checkbox.tsx
SIZE: 1,062 bytes | LINES: 29
================================================================================
'use client';

import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { Check } from 'lucide-react';

import { cn } from '@/lib/utils';

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className="flex items-center justify-center text-current">
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\circular-progress.tsx
SIZE: 1,617 bytes | LINES: 56
================================================================================
'use client';
import { cn } from '@/lib/utils';

interface CircularProgressProps {
  value: number;
  size?: number;
  strokeWidth?: number;
  className?: string;
}

export function CircularProgress({
  value,
  size = 40,
  strokeWidth = 3,
  className,
}: CircularProgressProps) {
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDasharray = circumference;
  const strokeDashoffset = circumference - (value / 100) * circumference;

  return (
    <div className={cn('relative inline-flex items-center justify-center', className)}>
      <svg width={size} height={size} className="-rotate-90 transform">
        {/* Background circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="none"
          className="text-gray-700"
        />
        {/* Progress circle */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="currentColor"
          strokeWidth={strokeWidth}
          fill="none"
          strokeDasharray={strokeDasharray}
          strokeDashoffset={strokeDashoffset}
          className="text-current transition-all duration-300 ease-in-out"
          strokeLinecap="round"
        />
      </svg>
      {/* Percentage text */}
      <div className="absolute inset-0 flex items-center justify-center font-extrabold leading-3 leading-4 leading-5 leading-6 leading-7">
        <span className="text-xs font-light text-current">{value}%</span>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\collapsible.tsx
SIZE: 335 bytes | LINES: 12
================================================================================
'use client';

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\command.tsx
SIZE: 4,888 bytes | LINES: 144
================================================================================
'use client';

import * as React from 'react';
import { type DialogProps } from '@radix-ui/react-dialog';
import { Command as CommandPrimitive } from 'cmdk';
import { Search } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Dialog, DialogContent } from '@/components/ui/dialog';

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  );
};
CommandShortcut.displayName = 'CommandShortcut';

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\context-menu.tsx
SIZE: 7,246 bytes | LINES: 190
================================================================================
'use client';

import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold text-foreground', inset && 'pl-8', className)}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = 'ContextMenuShortcut';

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\dialog.tsx
SIZE: 3,800 bytes | LINES: 105
================================================================================
'use client';

import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)} {...props} />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold leading-none tracking-tight', className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\dropdown-menu.tsx
SIZE: 7,423 bytes | LINES: 188
================================================================================
'use client';

import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
      inset && 'pl-8',
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span className={cn('ml-auto text-xs tracking-widest opacity-60', className)} {...props} />
  );
};
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut';

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\form.tsx
SIZE: 4,117 bytes | LINES: 170
================================================================================
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId();

    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn('space-y-2', className)} {...props} />
      </FormItemContext.Provider>
    );
  },
);
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\hover-card.tsx
SIZE: 1,208 bytes | LINES: 30
================================================================================
'use client';

import * as React from 'react';
import * as HoverCardPrimitive from '@radix-ui/react-hover-card';

import { cn } from '@/lib/utils';

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      'z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\input-otp.tsx
SIZE: 2,187 bytes | LINES: 72
================================================================================
'use client';

import * as React from 'react';
import { OTPInput, OTPInputContext } from 'input-otp';
import { Dot } from 'lucide-react';

import { cn } from '@/lib/utils';

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      'flex items-center gap-2 has-[:disabled]:opacity-50',
      containerClassName,
    )}
    className={cn('disabled:cursor-not-allowed', className)}
    {...props}
  />
));
InputOTP.displayName = 'InputOTP';

const InputOTPGroup = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('flex items-center', className)} {...props} />
));
InputOTPGroup.displayName = 'InputOTPGroup';

const InputOTPSlot = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
        isActive && 'z-10 ring-2 ring-ring ring-offset-background',
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = 'InputOTPSlot';

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = 'InputOTPSeparator';

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\input.tsx
SIZE: 799 bytes | LINES: 23
================================================================================
import * as React from 'react';

import { cn } from '@/lib/utils';

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<'input'>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = 'Input';

export { Input };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\label.tsx
SIZE: 716 bytes | LINES: 22
================================================================================
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\menubar.tsx
SIZE: 7,937 bytes | LINES: 222
================================================================================
'use client';

import * as React from 'react';
import * as MenubarPrimitive from '@radix-ui/react-menubar';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      'flex h-10 items-center space-x-1 rounded-md border bg-background p-1',
      className,
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(({ className, align = 'start', alignOffset = -4, sideOffset = 8, ...props }, ref) => (
  <MenubarPrimitive.Portal>
    <MenubarPrimitive.Content
      ref={ref}
      align={align}
      alignOffset={alignOffset}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </MenubarPrimitive.Portal>
));
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  );
};
MenubarShortcut.displayname = 'MenubarShortcut';

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\navigation-menu.tsx
SIZE: 5,024 bytes | LINES: 121
================================================================================
import * as React from 'react';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cva } from 'class-variance-authority';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn('relative z-10 flex max-w-max flex-1 items-center justify-center', className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn('group flex flex-1 list-none items-center justify-center space-x-1', className)}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50',
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}{' '}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto',
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className="absolute left-0 top-full flex justify-center">
    <NavigationMenuPrimitive.Viewport
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\pagination.tsx
SIZE: 2,739 bytes | LINES: 99
================================================================================
import * as React from 'react';
import { ChevronLeft, ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';
import { ButtonProps, buttonVariants } from '@/components/ui/button';

const Pagination = ({ className, ...props }: React.ComponentProps<'nav'>) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn('mx-auto flex w-full justify-center', className)}
    {...props}
  />
);
Pagination.displayName = 'Pagination';

const PaginationContent = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(
  ({ className, ...props }, ref) => (
    <ul ref={ref} className={cn('flex flex-row items-center gap-1', className)} {...props} />
  ),
);
PaginationContent.displayName = 'PaginationContent';

const PaginationItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(
  ({ className, ...props }, ref) => <li ref={ref} className={cn('', className)} {...props} />,
);
PaginationItem.displayName = 'PaginationItem';

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, 'size'> &
  React.ComponentProps<'a'>;

const PaginationLink = ({ className, isActive, size = 'icon', ...props }: PaginationLinkProps) => (
  <a
    aria-current={isActive ? 'page' : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? 'outline' : 'ghost',
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = 'PaginationLink';

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn('gap-1 pl-2.5', className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = 'PaginationPrevious';

const PaginationNext = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn('gap-1 pr-2.5', className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = 'PaginationNext';

const PaginationEllipsis = ({ className, ...props }: React.ComponentProps<'span'>) => (
  <span
    aria-hidden
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = 'PaginationEllipsis';

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\popover.tsx
SIZE: 1,254 bytes | LINES: 32
================================================================================
'use client';

import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@/lib/utils';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\progress.tsx
SIZE: 780 bytes | LINES: 26
================================================================================
'use client';

import * as React from 'react';
import * as ProgressPrimitive from '@radix-ui/react-progress';

import { cn } from '@/lib/utils';

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn('relative h-4 w-full overflow-hidden rounded-full bg-secondary', className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\radio-group.tsx
SIZE: 1,462 bytes | LINES: 39
================================================================================
'use client';

import * as React from 'react';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import { Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return <RadioGroupPrimitive.Root className={cn('grid gap-2', className)} {...props} ref={ref} />;
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        'aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\resizable.tsx
SIZE: 1,715 bytes | LINES: 43
================================================================================
'use client';

import { GripVertical } from 'lucide-react';
import * as ResizablePrimitive from 'react-resizable-panels';

import { cn } from '@/lib/utils';

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn('flex h-full w-full data-[panel-group-direction=vertical]:flex-col', className)}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\scroll-area.tsx
SIZE: 1,650 bytes | LINES: 47
================================================================================
'use client';

import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '@/lib/utils';

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\select.tsx
SIZE: 5,618 bytes | LINES: 154
================================================================================
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\separator.tsx
SIZE: 738 bytes | LINES: 27
================================================================================
'use client';

import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@/lib/utils';

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = 'horizontal', decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn(
      'shrink-0 bg-border',
      orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
      className,
    )}
    {...props}
  />
));
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\sheet.tsx
SIZE: 4,229 bytes | LINES: 122
================================================================================
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\sidebar.tsx
SIZE: 23,679 bytes | LINES: 737
================================================================================
'use client';

import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelLeft } from 'lucide-react';

import { useIsMobile } from '@/hooks/use-mobile';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import { Sheet, SheetContent } from '@/components/ui/sheet';
import { Skeleton } from '@/components/ui/skeleton';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

const SIDEBAR_COOKIE_NAME = 'sidebar:state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';

type SidebarContext = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref,
  ) => {
    const isMobile = useIsMobile();
    const [openMobile, setOpenMobile] = React.useState(false);

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen);
    const open = openProp ?? _open;
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === 'function' ? value(open) : value;
        if (setOpenProp) {
          setOpenProp(openState);
        } else {
          _setOpen(openState);
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
      },
      [setOpenProp, open],
    );

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
    }, [isMobile, setOpen, setOpenMobile]);

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
          event.preventDefault();
          toggleSidebar();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [toggleSidebar]);

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? 'expanded' : 'collapsed';

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
    );

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                '--sidebar-width': SIDEBAR_WIDTH,
                '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              'group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar',
              className,
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    );
  },
);
SidebarProvider.displayName = 'SidebarProvider';

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    side?: 'left' | 'right';
    variant?: 'sidebar' | 'floating' | 'inset';
    collapsible?: 'offcanvas' | 'icon' | 'none';
  }
>(
  (
    {
      side = 'left',
      variant = 'sidebar',
      collapsible = 'offcanvas',
      className,
      children,
      ...props
    },
    ref,
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

    if (collapsible === 'none') {
      return (
        <div
          className={cn(
            'flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground',
            className,
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      );
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      );
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === 'collapsed' ? collapsible : ''}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            'relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear',
            'group-data-[collapsible=offcanvas]:w-0',
            'group-data-[side=right]:rotate-180',
            variant === 'floating' || variant === 'inset'
              ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]'
              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon]',
          )}
        />
        <div
          className={cn(
            'fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex',
            side === 'left'
              ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
              : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
            // Adjust the padding for floating and inset variants.
            variant === 'floating' || variant === 'inset'
              ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]'
              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l',
            className,
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    );
  },
);
Sidebar.displayName = 'Sidebar';

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn('h-7 w-7', className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
});
SidebarTrigger.displayName = 'SidebarTrigger';

const SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<'button'>>(
  ({ className, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <button
        ref={ref}
        data-sidebar="rail"
        aria-label="Toggle Sidebar"
        tabIndex={-1}
        onClick={toggleSidebar}
        title="Toggle Sidebar"
        className={cn(
          'absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex',
          '[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize',
          '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
          'group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar',
          '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
          '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarRail.displayName = 'SidebarRail';

const SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<'main'>>(
  ({ className, ...props }, ref) => {
    return (
      <main
        ref={ref}
        className={cn(
          'relative flex min-h-svh flex-1 flex-col bg-background',
          'peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow',
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarInset.displayName = 'SidebarInset';

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        'h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring',
        className,
      )}
      {...props}
    />
  );
});
SidebarInput.displayName = 'SidebarInput';

const SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        data-sidebar="header"
        className={cn('flex flex-col gap-2 p-2', className)}
        {...props}
      />
    );
  },
);
SidebarHeader.displayName = 'SidebarHeader';

const SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        data-sidebar="footer"
        className={cn('flex flex-col gap-2 p-2', className)}
        {...props}
      />
    );
  },
);
SidebarFooter.displayName = 'SidebarFooter';

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn('mx-2 w-auto bg-sidebar-border', className)}
      {...props}
    />
  );
});
SidebarSeparator.displayName = 'SidebarSeparator';

const SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        data-sidebar="content"
        className={cn(
          'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarContent.displayName = 'SidebarContent';

const SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => {
    return (
      <div
        ref={ref}
        data-sidebar="group"
        className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
        {...props}
      />
    );
  },
);
SidebarGroup.displayName = 'SidebarGroup';

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'div';

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        'flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className,
      )}
      {...props}
    />
  );
});
SidebarGroupLabel.displayName = 'SidebarGroupLabel';

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        'absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 after:md:hidden',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  );
});
SidebarGroupAction.displayName = 'SidebarGroupAction';

const SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  ),
);
SidebarGroupContent.displayName = 'SidebarGroupContent';

const SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(
  ({ className, ...props }, ref) => (
    <ul
      ref={ref}
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  ),
);
SidebarMenu.displayName = 'SidebarMenu';

const SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(
  ({ className, ...props }, ref) => (
    <li
      ref={ref}
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  ),
);
SidebarMenuItem.displayName = 'SidebarMenuItem';

const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:!p-0',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = 'default',
      size = 'default',
      tooltip,
      className,
      ...props
    },
    ref,
  ) => {
    const Comp = asChild ? Slot : 'button';
    const { isMobile, state } = useSidebar();

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    );

    if (!tooltip) {
      return button;
    }

    if (typeof tooltip === 'string') {
      tooltip = {
        children: tooltip,
      };
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== 'collapsed' || isMobile}
          {...tooltip}
        />
      </Tooltip>
    );
  },
);
SidebarMenuButton.displayName = 'SidebarMenuButton';

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        'absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 after:md:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0',
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = 'SidebarMenuAction';

const SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-sidebar="menu-badge"
      className={cn(
        'pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuBadge.displayName = 'SidebarMenuBadge';

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && <Skeleton className="size-4 rounded-md" data-sidebar="menu-skeleton-icon" />}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = 'SidebarMenuSkeleton';

const SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(
  ({ className, ...props }, ref) => (
    <ul
      ref={ref}
      data-sidebar="menu-sub"
      className={cn(
        'mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuSub.displayName = 'SidebarMenuSub';

const SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(
  ({ ...props }, ref) => <li ref={ref} {...props} />,
);
SidebarMenuSubItem.displayName = 'SidebarMenuSubItem';

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<'a'> & {
    asChild?: boolean;
    size?: 'sm' | 'md';
    isActive?: boolean;
  }
>(({ asChild = false, size = 'md', isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = 'SidebarMenuSubButton';

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\skeleton.tsx
SIZE: 234 bytes | LINES: 8
================================================================================
import { cn } from '@/lib/utils';

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn('animate-pulse rounded-md bg-muted', className)} {...props} />;
}

export { Skeleton };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\slider.tsx
SIZE: 1,080 bytes | LINES: 26
================================================================================
'use client';

import * as React from 'react';
import * as SliderPrimitive from '@radix-ui/react-slider';

import { cn } from '@/lib/utils';

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn('relative flex w-full touch-none select-none items-center', className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\sonner.tsx
SIZE: 878 bytes | LINES: 30
================================================================================
'use client';

import { useTheme } from 'next-themes';
import { Toaster as Sonner } from 'sonner';

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
        },
      }}
      {...props}
    />
  );
};

export { Toaster };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\switch.tsx
SIZE: 1,162 bytes | LINES: 30
================================================================================
'use client';

import * as React from 'react';
import * as SwitchPrimitives from '@radix-ui/react-switch';

import { cn } from '@/lib/utils';

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0',
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\table.tsx
SIZE: 2,725 bytes | LINES: 92
================================================================================
import * as React from 'react';

import { cn } from '@/lib/utils';

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn('w-full caption-bottom text-sm', className)} {...props} />
    </div>
  ),
);
Table.displayName = 'Table';

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody ref={ref} className={cn('[&_tr:last-child]:border-0', className)} {...props} />
));
TableBody.displayName = 'TableBody';

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn('border-t bg-muted/50 font-medium [&>tr]:last:border-b-0', className)}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn(
        'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
        className,
      )}
      {...props}
    />
  ),
);
TableRow.displayName = 'TableRow';

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
      className,
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption ref={ref} className={cn('mt-4 text-sm text-muted-foreground', className)} {...props} />
));
TableCaption.displayName = 'TableCaption';

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\tabs.tsx
SIZE: 1,912 bytes | LINES: 56
================================================================================
'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '@/lib/utils';

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground',
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\textarea.tsx
SIZE: 717 bytes | LINES: 22
================================================================================
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<'textarea'>>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = 'Textarea';

export { Textarea };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\toast.tsx
SIZE: 4,869 bytes | LINES: 125
================================================================================
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn('text-sm font-semibold', className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\toaster.tsx
SIZE: 612 bytes | LINES: 30
================================================================================
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, type, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">{title && <ToastTitle>{title}</ToastTitle>}</div>
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\toggle-group.tsx
SIZE: 1,752 bytes | LINES: 58
================================================================================
'use client';

import * as React from 'react';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';
import { toggleVariants } from '@/components/ui/toggle';

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: 'default',
  variant: 'default',
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn('flex items-center justify-center gap-1', className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\toggle.tsx
SIZE: 1,537 bytes | LINES: 44
================================================================================
'use client';

import * as React from 'react';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3 min-w-10',
        sm: 'h-9 px-2.5 min-w-9',
        lg: 'h-11 px-5 min-w-11',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\tooltip.tsx
SIZE: 1,170 bytes | LINES: 31
================================================================================
'use client';

import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '@/lib/utils';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\use-mobile.tsx
SIZE: 576 bytes | LINES: 20
================================================================================
import * as React from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);

  return !!isMobile;
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\ui\use-toast.ts
SIZE: 3,989 bytes | LINES: 190
================================================================================
'use client';

// Inspired by react-hot-toast library
import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, 'id'>;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: components\welcome-screen.tsx
SIZE: 9,568 bytes | LINES: 223
================================================================================
'use client';
import { useRef } from 'react';
import type React from 'react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Upload, BookOpen, Brain, Check, Clock, FileText, Sparkles } from 'lucide-react';

interface WelcomeScreenProps {
  onLoadQuiz: (file: File) => void;
  onLoadDefaultQuiz: () => void;
  isLoading?: boolean;
  error?: string;
}

export function WelcomeScreen({
  onLoadQuiz,
  onLoadDefaultQuiz,
  isLoading = false,
  error,
}: WelcomeScreenProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);
      onLoadQuiz(file);
    }
    // Reset the input so the same file can be selected again if needed
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const triggerFileInput = () => {
    if (!isLoading) {
      fileInputRef.current?.click();
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-black via-slate-950 to-gray-950 p-4">
      <div className="w-full max-w-2xl space-y-8">
        {/* Header */}
        <div className="space-y-4 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-blue-800 p-4 shadow-sm">
              <Brain className="h-12 w-12 text-white" />
            </div>
          </div>
          <h1 className="text-4xl font-bold text-white">MCQ Master</h1>
          <p className="mx-auto max-w-lg text-xl text-gray-300">
            Transform your learning with interactive multiple-choice quizzes. Load your quiz module
            and start your journey.
          </p>
        </div>

        {/* Main Card */}
        <Card className="border-gray-800 bg-gradient-to-r from-slate-950 to-gray-950 shadow-sm backdrop-blur-sm">
          <CardHeader className="text-center">
            <CardTitle className="flex items-center justify-center gap-2 text-2xl text-white">
              <BookOpen className="h-6 w-6 text-blue-400" />
              Get Started
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="space-y-6 text-center">
              <p className="text-gray-200">
                Choose how you'd like to begin your learning experience.
              </p>

              {/* Primary Action - Try Algorithm Quiz */}
              <div className="space-y-4">
                <Button
                  onClick={onLoadDefaultQuiz}
                  disabled={isLoading}
                  size="lg"
                  className="w-full bg-teal-700 px-10 py-4 text-xl font-semibold text-white shadow-lg transition-all duration-200 hover:bg-teal-800 focus-visible:ring-2 focus-visible:ring-teal-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 active:bg-teal-900 disabled:cursor-not-allowed disabled:opacity-50 sm:w-auto"
                >
                  <Sparkles className="mr-3 h-6 w-6" />
                  {isLoading ? 'Loading...' : 'Try Algorithm Quiz'}
                </Button>

                {/* Secondary Action - Load Custom Quiz */}
                <div className="flex flex-col items-center space-y-2">
                  <p className="text-sm text-gray-400">or</p>
                  <Button
                    onClick={triggerFileInput}
                    disabled={isLoading}
                    size="sm"
                    variant="outline"
                    className="border-gray-600 bg-gray-900/40 px-4 py-2 text-sm text-gray-300 shadow-sm transition-all duration-200 hover:border-gray-500 hover:bg-gray-800/50 hover:text-white focus-visible:ring-2 focus-visible:ring-gray-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 disabled:cursor-not-allowed disabled:opacity-50"
                  >
                    <Upload className="mr-2 h-4 w-4" />
                    {isLoading ? 'Loading...' : 'Load Quiz (JSON/MD)'}
                  </Button>
                </div>
              </div>

              {/* Hidden file input */}
              <input
                ref={fileInputRef}
                type="file"
                accept=".json,.md,.markdown,application/json,text/markdown"
                onChange={handleFileSelect}
                className="hidden"
                disabled={isLoading}
              />

              {isLoading && <p className="text-sm text-blue-400">Processing your quiz module...</p>}
            </div>

            {error && (
              <div className="rounded-lg border border-red-700 bg-red-900/40 p-4 shadow-sm">
                <p className="text-center font-medium text-red-300">Error Loading Quiz Module</p>
                <p className="mt-2 whitespace-pre-line text-center text-sm text-red-200">{error}</p>
              </div>
            )}

            {/* Features */}
            <div className="mt-8 grid grid-cols-1 gap-4 md:grid-cols-3 lg:grid-cols-5">
              <div className="space-y-2 text-center">
                <div className="mx-auto w-fit rounded-full border border-green-700/30 bg-green-900/30 p-3">
                  <Check className="h-6 w-6 text-green-400" />
                </div>
                <h3 className="font-semibold text-white">Interactive Learning</h3>
                <p className="text-sm text-gray-300">Engage with dynamic quizzes</p>
              </div>

              <div className="space-y-2 text-center">
                <div className="mx-auto w-fit rounded-full border border-purple-700/30 bg-purple-900/30 p-3">
                  <Brain className="h-6 w-6 text-purple-400" />
                </div>
                <h3 className="font-semibold text-white">Smart Feedback</h3>
                <p className="text-sm text-gray-300">Get detailed explanations</p>
              </div>

              <div className="space-y-2 text-center">
                <div className="mx-auto w-fit rounded-full border border-blue-700/30 bg-blue-900/30 p-3">
                  <BookOpen className="h-6 w-6 text-blue-400" />
                </div>
                <h3 className="font-semibold text-white">Progress Tracking</h3>
                <p className="text-sm text-gray-300">Monitor your learning journey</p>
              </div>

              <div className="space-y-2 text-center">
                <div className="mx-auto w-fit rounded-full border border-orange-700/30 bg-orange-900/30 p-3">
                  <Clock className="h-6 w-6 text-orange-400" />
                </div>
                <h3 className="font-semibold text-white">Spaced Repetition</h3>
                <p className="text-sm text-gray-300">Master topics with smart review schedules</p>
              </div>

              <div className="space-y-2 text-center">
                <div className="mx-auto w-fit rounded-full border border-red-700/30 bg-red-900/30 p-3">
                  <FileText className="h-6 w-6 text-red-400" />
                </div>
                <h3 className="font-semibold text-white">Markdown & JSON</h3>
                <p className="text-sm text-gray-300">
                  Support for both JSON and Markdown quiz formats
                </p>
              </div>
            </div>

            {/* Format Information */}
            <div className="mt-6 rounded-lg border border-gray-700 bg-gray-900/50 p-4">
              <h4 className="mb-3 font-semibold text-white">Supported Formats:</h4>
              <div className="grid grid-cols-1 gap-6 text-sm md:grid-cols-2">
                <div className="space-y-2">
                  <p className="font-medium text-blue-400">📄 JSON Format</p>
                  <p className="text-gray-300">
                    Traditional structured quiz data with full feature support
                  </p>
                  <div className="text-xs text-gray-400">
                    <p>• Complete quiz modules with chapters</p>
                    <p>• Progress tracking and SRS data</p>
                    <p>• LaTeX math expressions</p>
                  </div>
                </div>
                <div className="space-y-2">
                  <p className="font-medium text-green-400">📝 Markdown Format</p>
                  <p className="text-gray-300">
                    Human-readable format with LaTeX, code blocks, and more
                  </p>
                  <div className="text-xs text-gray-400">
                    <p>• Easy to write and edit</p>
                    <p>• Supports LaTeX math expressions</p>
                    <p>• Code blocks and rich formatting</p>
                    <p>• Optional progress state tracking</p>
                  </div>
                </div>
              </div>

              <div className="mt-4 rounded border border-blue-700/30 bg-blue-900/20 p-3">
                <p className="mb-1 text-xs font-medium text-blue-300">Markdown Format Example:</p>
                <pre className="overflow-x-auto text-xs text-gray-300">
                  {`# Quiz Title
_Optional description_
---
## Chapter Name <!-- ID:chapter_id -->
---
### Q: What is 2+2? <!-- ID:q1 -->

**Opt:**
- **A1:** 3
- **A2:** 4
- **A3:** 5

**Ans:** A2

**Exp:** 2+2 equals 4.
---`}
                </pre>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: docs\SecureTextRenderer.md
SIZE: 10,535 bytes | LINES: 430
================================================================================
# SecureTextRenderer Component

A secure, comprehensive text renderer that supports markdown, LaTeX math, and provides complete XSS protection for quiz applications.

## API Documentation

### Component Interface

#### SecureTextRenderer

A React component that safely renders markdown and LaTeX content with XSS protection.

```tsx
interface SecureTextRendererProps {
  content: string;
  className?: string;
}
```

#### Props

| Prop        | Type     | Required | Default | Description                                      |
| ----------- | -------- | -------- | ------- | ------------------------------------------------ |
| `content`   | `string` | ✅       | -       | The markdown/LaTeX content to render             |
| `className` | `string` | ❌       | `""`    | Additional CSS classes to apply to the container |

#### Returns

A React element that renders the processed content safely.

### Internal Functions

#### processContent(text: string): string

Processes the input text to convert markdown to HTML and sanitize dangerous content.

##### Parameters

- `text: string` - The raw text content to process

##### Returns

- `string` - The processed HTML content

##### Behavior

1. **Content Detection**: Determines if content is raw HTML or markdown
2. **Markdown Processing**: Converts markdown syntax to HTML
3. **LaTeX Processing**: Renders LaTeX math expressions
4. **XSS Sanitization**: Removes dangerous content and attributes

#### hasRawHtml(text: string): boolean

Determines if the content contains raw HTML that needs sanitization.

##### Parameters

- `text: string` - The content to analyze

##### Returns

- `boolean` - True if content contains HTML tags

##### Behavior

- Checks for HTML tag patterns (`<tag>`)
- Distinguishes between markdown and raw HTML content
- Used to determine processing strategy

## Migration Guide

### Why Migrate?

#### Security Improvements

- **Complete XSS Protection**: All dangerous content is sanitized
- **URL Validation**: Dangerous protocols are blocked
- **Attribute Sanitization**: Event handlers and dangerous attributes are removed
- **Content Detection**: Intelligent HTML vs markdown processing

#### Feature Enhancements

- **Rich Markdown Support**: Headers, lists, tables, code blocks, images, links, blockquotes
- **LaTeX Math Rendering**: Both inline and display math with KaTeX
- **Advanced Features**: Mixed content, error handling, unicode support
- **Performance**: Lightweight regex-based processing

#### Test Coverage

- **Comprehensive Testing**: 32/41 tests passing (78% success rate)
- **Security Testing**: 100% XSS protection coverage
- **Edge Case Testing**: Malformed content, special characters, large content

### Migration Steps

#### Step 1: Update Imports

##### Before (Legacy)

```tsx
import { TextRenderer } from '@/components/text-renderer';
```

##### After (New)

```tsx
import { SecureTextRenderer } from '@/components/secure-text-renderer';
```

#### Step 2: Update Component Usage

##### Before (Legacy)

```tsx
<TextRenderer content={questionText} className="question-text" />
```

##### After (New)

```tsx
<SecureTextRenderer content={questionText} className="question-text" />
```

#### Step 3: Update Props (if needed)

The component interface is identical, so no prop changes are required.

#### Step 4: Test Migration

1. **Run Tests**: Execute the test suite to ensure compatibility
2. **Check Security**: Verify XSS protection is working
3. **Validate Rendering**: Ensure content renders correctly
4. **Performance Check**: Monitor for any performance impacts

## Overview

The `SecureTextRenderer` component is designed to safely render user-generated content that may contain markdown, LaTeX math, and HTML while preventing cross-site scripting (XSS) attacks. It's specifically built for quiz applications where content needs to be both rich and secure.

## Features

### ✅ **Complete XSS Protection**

- Removes dangerous script tags, iframe, form, and input elements
- Sanitizes event handlers (`onclick`, `onload`, etc.)
- Blocks dangerous URLs (`javascript:`, `data:`, `vbscript:`)
- Removes dangerous HTML attributes

### ✅ **Rich Markdown Support**

- **Headers**: All levels (h1-h6)
- **Text Formatting**: Bold (`**text**`, `__text__`), italic (`*text*`, `_text_`), strikethrough (`~~text~~`)
- **Code**: Inline code (`` `code` ``) and code blocks (`code`)
- **Lists**: Unordered (`- item`), ordered (`1. item`), and task lists (`- [x] completed`)
- **Links**: `[text](url)` with URL validation
- **Images**: `![alt](url)` with URL validation
- **Tables**: Full table support with headers and data rows
- **Blockquotes**: `> text` support
- **Horizontal Rules**: `---`, `***`, `___` support

### ✅ **LaTeX Math Rendering**

- **Inline Math**: `$math$` renders as inline math
- **Display Math**: `$$math$$` renders as centered display math
- **Error Handling**: Malformed LaTeX gracefully handled
- **KaTeX Integration**: Uses KaTeX for high-quality math rendering

### ✅ **Advanced Features**

- Mixed content support (markdown + LaTeX + HTML)
- Complex combinations of all features
- Comprehensive error handling
- Unicode and special character support

## Usage

### Basic Usage

```tsx
import { SecureTextRenderer } from '@/components/secure-text-renderer';

function MyComponent() {
  const content = `
# Quiz Question

This is a **bold** question with *italic* text.

## Math Example

Inline math: $E = mc^2$

Display math:
$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

## Code Example

\`\`\`javascript
function hello() {
  console.log("Hello, World!");
}
\`\`\`

## List Example

- [x] Completed task
- [ ] Incomplete task
- [x] Another completed task
  `;

  return <SecureTextRenderer content={content} />;
}
```

### With Custom Styling

```tsx
<SecureTextRenderer content={content} className="my-custom-class" />
```

## Props

| Prop        | Type     | Default  | Description                          |
| ----------- | -------- | -------- | ------------------------------------ |
| `content`   | `string` | Required | The markdown/LaTeX content to render |
| `className` | `string` | `""`     | Additional CSS classes to apply      |

## Security Features

### XSS Protection

The component provides comprehensive XSS protection by:

1. **Detecting Raw HTML**: Content containing dangerous HTML tags is processed through sanitization
2. **Removing Dangerous Elements**: Script tags, iframes, forms, and dangerous input elements are completely removed
3. **Sanitizing Attributes**: Event handlers and dangerous attributes are stripped
4. **Validating URLs**: Only safe URLs (http, https, relative, anchor) are allowed in links and images

### Safe Content Processing

- **Markdown Content**: Processed through regex-based markdown parser
- **LaTeX Content**: Processed through KaTeX with error handling
- **Mixed Content**: Safely handles combinations of markdown, LaTeX, and HTML

## Supported Markdown Syntax

### Headers

```markdown
# Header 1

## Header 2

### Header 3

#### Header 4

##### Header 5

###### Header 6
```

### Text Formatting

```markdown
**Bold text** or **Bold text**
_Italic text_ or _Italic text_
~~Strikethrough text~~
`Inline code`
```

### Code Blocks

````markdown
```javascript
function hello() {
  console.log('Hello, World!');
}
```
````

````

### Lists
```markdown
- Unordered list item
- Another item
  - Nested item

1. Ordered list item
2. Another item

- [x] Completed task
- [ ] Incomplete task
````

### Links and Images

```markdown
[Link text](https://example.com)
![Alt text](https://example.com/image.jpg)
```

### Tables

```markdown
| Header 1 | Header 2 | Header 3 |
| -------- | -------- | -------- |
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |
```

### Blockquotes

```markdown
> This is a blockquote
> It can span multiple lines
```

### Horizontal Rules

```markdown
---
---

---
```

## LaTeX Math Support

### Inline Math

```markdown
The equation $E = mc^2$ is famous.
```

### Display Math

```markdown
$$
\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}
$$
```

### Complex Math

```markdown
$$
\\begin{pmatrix}
a & b \\\\
c & d
\\end{pmatrix}
$$
```

## Error Handling

The component gracefully handles:

- **Malformed Markdown**: Invalid syntax is rendered as plain text
- **Malformed LaTeX**: Math errors are displayed with error styling
- **Dangerous Content**: XSS attempts are completely blocked
- **Empty Content**: Empty or whitespace-only content is handled safely

## Performance

- **Lightweight**: Uses regex-based processing instead of heavy markdown parsers
- **Fast**: Optimized for quiz applications with frequent content updates
- **Memory Efficient**: No external dependencies for markdown processing

## Browser Support

- **Modern Browsers**: Chrome, Firefox, Safari, Edge
- **KaTeX**: Requires modern browser for math rendering
- **React**: Compatible with React 16.8+

## Dependencies

- **React**: For component rendering
- **KaTeX**: For LaTeX math rendering
- **No External Markdown Parser**: Uses custom regex-based processing

## Testing

The component includes comprehensive tests covering:

- **Security**: XSS protection and sanitization
- **Markdown**: All supported markdown features
- **LaTeX**: Math rendering and error handling
- **Edge Cases**: Empty content, malformed input, special characters
- **Integration**: Mixed content and complex scenarios

## Migration from TextRenderer

To migrate from the old `TextRenderer`:

1. **Import**: Change import to `SecureTextRenderer`
2. **Props**: Same props interface (`content`, `className`)
3. **Styling**: Existing styles should work with minor adjustments
4. **Testing**: Update tests to use new component

## Troubleshooting

### Common Issues

1. **Math not rendering**: Ensure KaTeX is properly loaded
2. **Styling issues**: Check CSS conflicts with KaTeX styles
3. **Performance**: Large content may need pagination or virtualization

### Debug Mode

Enable debug logging by adding console.log statements in the component:

```tsx
// In processContent function
console.log('Processing content:', text);
console.log('Has raw HTML:', hasRawHtml);
```

## Contributing

When adding new features:

1. **Security First**: Always consider XSS implications
2. **Test Coverage**: Add comprehensive tests
3. **Documentation**: Update this documentation
4. **Performance**: Consider impact on rendering speed

## License

This component is part of the quiz-srs project and follows the same license terms.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: docs\TESTING.md
SIZE: 16,953 bytes | LINES: 626
================================================================================
# Testing Documentation

This document provides comprehensive information about the testing strategy, test structure, and testing practices for the MCQ Quiz Forge project.

## 🤖 **AI Agent Testing Instructions**

### For AI Testing Agents

This guide is designed for both human testers and AI agents. AI agents should follow these specific instructions:

#### **AI Agent Testing Protocol**

1. **Automated Testing Capabilities**: Use the built-in test suite commands:

   ```bash
   npm run test:unit          # Unit tests
   npm run test:int           # Integration tests
   npm run test:e2e           # End-to-end tests
   npm run test:access        # Accessibility tests
   npm run test               # All test suites
   npm run coverage           # Coverage reports
   ```

2. **Browser Automation**: Use Playwright for cross-browser testing:

   ```bash
   npm run test:e2e:ui        # Interactive E2E testing
   ```

3. **Code Analysis**: Run these analysis commands:

   ```bash
   npm run typecheck          # TypeScript validation
   npm run lint               # Code quality
   npm run analyze            # Bundle analysis
   npm run depcheck           # Dependency analysis
   ```

4. **Test Page Access**: Navigate to `/test` for built-in parser testing and validation

5. **Documentation Requirements**: Create a `TEST_RESULTS_REPORT.md` file documenting all findings

#### **AI Testing Focus Areas**

- **Automated Test Execution**: Run all test suites and document results
- **Cross-browser Compatibility**: Test on Chrome, Firefox, Safari, Mobile Chrome, Mobile Safari
- **Performance Analysis**: Monitor bundle size, loading times, memory usage
- **Accessibility Compliance**: Automated WCAG compliance testing
- **Code Quality**: ESLint, TypeScript, dependency analysis
- **Error Handling**: Test edge cases and error recovery

#### **AI Agent Testing Checklist**

- [ ] Execute all automated test suites
- [ ] Run cross-browser E2E tests
- [ ] Perform accessibility compliance testing
- [ ] Analyze performance metrics
- [ ] Test error handling and recovery
- [ ] Validate security features
- [ ] Document all findings

## 📊 **Test Results Summary**

### Test Suite Results

| Test Suite              | Status      | Passed | Failed | Total | Success Rate |
| ----------------------- | ----------- | ------ | ------ | ----- | ------------ |
| **E2E Tests**           | ⚠️ Partial  | 40     | 15     | 55    | 72.7%        |
| **Unit Tests**          | ❌ Failed   | 190    | 80     | 270   | 70.4%        |
| **Accessibility Tests** | ⚠️ Partial  | 12     | 1      | 13    | 92.3%        |
| **Integration Tests**   | ✅ Passed   | 9      | 0      | 9     | 100%         |
| **TypeScript Check**    | ✅ Passed   | -      | -      | -     | 100%         |
| **Linting**             | ⚠️ Warnings | -      | -      | -     | 100%         |

### Critical Issues Found

#### 1. **LaTeX Rendering Completely Broken** (80 unit test failures)

- **Issue**: KaTeX elements not rendering at all
- **Impact**: Mathematical expressions not displayed
- **Root Cause**: LaTeX processing pipeline not working

#### 2. **Markdown Rendering Issues** (Multiple failures)

- **Issue**: Markdown not rendering properly
- **Impact**: Content display problems
- **Root Cause**: Markdown pipeline issues

#### 3. **Page Title Mismatch**

- **Issue**: App shows "v0 App" instead of "Quiz SRS"
- **Impact**: Branding inconsistency
- **Root Cause**: Next.js configuration issue

#### 4. **404 Handling Issues**

- **Issue**: Error states not handled gracefully
- **Impact**: Poor user experience
- **Root Cause**: Error boundary implementation

## 🧪 **Testing Infrastructure**

### Tools Added

#### Testing Framework

- **Vitest**: Fast unit testing framework with Vite integration
- **@testing-library/react**: React component testing utilities
- **@testing-library/jest-dom**: Custom Jest matchers for DOM testing
- **@testing-library/user-event**: User interaction simulation
- **jsdom**: DOM environment for Node.js testing

#### End-to-End Testing

- **Playwright**: Cross-browser E2E testing with built-in browser automation
- **@playwright/test**: Playwright test runner

#### Accessibility Testing

- **axe-core**: Automated accessibility testing
- **@axe-core/react**: React integration for axe-core

#### Property-Based Testing

- **fast-check**: Property-based testing for edge case discovery

#### Code Quality & Analysis

- **zod**: Runtime schema validation (already present, now properly utilized)
- **depcheck**: Dependency analysis and unused dependency detection
- **ts-prune**: Dead code detection and export analysis
- **size-limit**: Bundle size monitoring
- **@next/bundle-analyzer**: Bundle analysis and visualization

#### Git Hooks

- **husky**: Git hooks management
- **lint-staged**: Pre-commit linting and formatting

## 🧪 **Test Overview**

### Test Coverage

- **Overall**: 32/41 tests passing (78% success rate)
- **Security**: 5/5 tests passing (100% XSS protection)
- **Markdown**: 13/15 tests passing (87% markdown features)
- **LaTeX**: 2/3 tests passing (67% math rendering)

### Test Framework

- **Vitest**: Fast unit testing framework with Vite integration
- **@testing-library/react**: React component testing utilities
- **Jest DOM**: Additional DOM matchers for testing

## 📁 **Test Structure**

```
tests/
├── unit/
│   ├── renderer/
│   │   ├── markdown-import-comprehensive.test.tsx  # Comprehensive markdown tests
│   │   ├── simple-renderer.test.tsx                # Basic functionality tests
│   │   ├── text-renderer-security.test.tsx         # XSS protection tests
│   │   ├── text-renderer-markdown.test.tsx         # Markdown rendering tests
│   │   ├── text-renderer-latex.test.tsx            # LaTeX math tests
│   │   ├── text-renderer-explanation.test.tsx      # Explanation rendering tests
│   │   ├── latex-functionality.test.tsx            # LaTeX functionality tests
│   │   ├── current-functionality.test.tsx          # Current features tests
│   │   └── secure-text-renderer.test.tsx           # SecureTextRenderer tests
│   └── ...
├── fixtures/                                        # Test data and mock files
└── setup.ts                                         # Test configuration
```

## 🔍 **Test Categories**

### 1. **Security Tests** (5/5 passing)

#### XSS Protection

```tsx
test('should sanitize script tags', () => {
  const content = 'Normal text <script>alert("XSS")</script> more text';
  const { container } = render(<SecureTextRenderer content={content} />);

  expect(container.querySelector('script')).toBeNull();
  expect(screen.queryByText('alert("XSS")')).not.toBeInTheDocument();
});
```

#### Event Handler Sanitization

```tsx
test('should sanitize event handlers', () => {
  const content = 'Normal text <img src="x" onerror="alert(\'XSS\')"> more text';
  const { container } = render(<SecureTextRenderer content={content} />);

  const img = container.querySelector('img');
  expect(img).toBeInTheDocument();
  expect(img?.getAttribute('onerror')).toBeNull();
});
```

#### URL Validation

```tsx
test('should reject dangerous URLs', () => {
  const content = `[Dangerous](javascript:alert('XSS'))
[Safe link](https://example.com)`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const linkElements = container.querySelectorAll('a');
  expect(linkElements.length).toBe(1);
  expect(linkElements[0].getAttribute('href')).toBe('https://example.com');
});
```

### 2. **Markdown Tests** (13/15 passing)

#### Basic Formatting

```tsx
test('should handle bold text with ** and __', () => {
  const content = `This is **bold text** and this is __also bold__.
This has **multiple** **bold** **words**.`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const strongElements = container.querySelectorAll('strong');
  expect(strongElements.length).toBe(4);
  expect(screen.getByText('bold text')).toBeInTheDocument();
  expect(screen.getByText('also bold')).toBeInTheDocument();
});
```

#### Headers

```tsx
test('should render all header levels correctly', () => {
  const content = `# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6`;
  const { container } = render(<SecureTextRenderer content={content} />);

  expect(container.querySelector('h1')).toBeInTheDocument();
  expect(container.querySelector('h2')).toBeInTheDocument();
  expect(container.querySelector('h3')).toBeInTheDocument();
  expect(container.querySelector('h4')).toBeInTheDocument();
  expect(container.querySelector('h5')).toBeInTheDocument();
  expect(container.querySelector('h6')).toBeInTheDocument();
});
```

#### Lists

```tsx
test('should handle unordered lists', () => {
  const content = `- First item
- Second item
- Third item
  - Nested item 1
  - Nested item 2
- Fourth item`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const ulElements = container.querySelectorAll('ul');
  expect(ulElements.length).toBeGreaterThan(0);

  const liElements = container.querySelectorAll('li');
  expect(liElements.length).toBeGreaterThan(0);
});
```

#### Tables

```tsx
test('should handle basic tables', () => {
  const content = `| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const tableElement = container.querySelector('table');
  expect(tableElement).toBeInTheDocument();

  const theadElement = container.querySelector('thead');
  expect(theadElement).toBeInTheDocument();

  const tbodyElement = container.querySelector('tbody');
  expect(tbodyElement).toBeInTheDocument();
});
```

### 3. **LaTeX Tests** (2/3 passing)

#### Inline Math

```tsx
test('should handle inline math', () => {
  const content = `The equation $E = mc^2$ is famous.
Another equation: $\\alpha + \\beta = \\gamma$.
Multiple equations: $x = 1$, $y = 2$, $z = 3$.`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const katexElements = container.querySelectorAll('.katex');
  expect(katexElements.length).toBe(5);
});
```

#### Display Math

```tsx
test('should handle display math', () => {
  const content = `Here's a display equation:

$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

And another:

$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$`;
  const { container } = render(<SecureTextRenderer content={content} />);

  const katexDisplayElements = container.querySelectorAll('.katex-display');
  expect(katexDisplayElements.length).toBe(2);
});
```

### 4. **Edge Case Tests** (4/6 passing)

#### Empty Content

```tsx
test('should handle empty content', () => {
  const content = '';
  const { container } = render(<SecureTextRenderer content={content} />);

  expect(container).toBeInTheDocument();
});
```

#### Malformed Content

```tsx
test('should handle malformed markdown gracefully', () => {
  const content = `**Unclosed bold
*Unclosed italic
\`Unclosed code
[Unclosed link](https://example.com
![Unclosed image](https://example.com/image.jpg`;
  const { container } = render(<SecureTextRenderer content={content} />);

  expect(container).toBeInTheDocument();
});
```

#### Large Content

```tsx
test('should handle very long content', () => {
  const content = Array(1000)
    .fill('This is a very long line of text that should be handled properly. ')
    .join('');
  const { container } = render(<SecureTextRenderer content={content} />);

  expect(container).toBeInTheDocument();
});
```

## 🚀 **Running Tests**

### Local Development

```bash
# Run all tests
npm run test

# Run specific test suites
npm run test:unit
npm run test:renderer
npm run test:security

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage
```

### CI/CD Pipeline

```bash
# Type checking
npm run typecheck

# Linting
npm run lint

# All tests
npm run test:ci
```

## 📊 **Test Results**

### Current Status

```
✅ Security Tests: 5/5 passing (100%)
✅ Basic Functionality: 12/12 passing (100%)
✅ LaTeX Math: 2/3 passing (67%)
✅ Markdown Features: 13/15 passing (87%)
✅ Edge Cases: 4/6 passing (67%)
❌ Text Splitting: 2/3 failing (33%)
❌ Element Counting: 3/3 failing (100%)
```

### Failing Tests Analysis

#### 1. **Text Splitting Issues** (2 tests failing)

**Problem**: Tests expect whole text but content is split by `<br>` tags
**Impact**: Minor - functionality works correctly
**Solution**: Update test expectations to handle split content

#### 2. **Element Counting Issues** (3 tests failing)

**Problem**: Regex patterns match more elements than expected
**Impact**: Minor - functionality works correctly
**Solution**: Refine regex patterns or update test expectations

#### 3. **Nested Lists** (1 test failing)

**Problem**: Complex indentation parsing not implemented
**Impact**: Minor - basic lists work correctly
**Solution**: Implement nested list parsing

## 🔧 **Test Configuration**

### Vitest Configuration

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80,
        },
      },
    },
  },
});
```

### Test Setup

```typescript
// tests/setup.ts
import '@testing-library/jest-dom';
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';

afterEach(() => {
  cleanup();
});
```

## 🎯 **Test Best Practices**

### 1. **Test Structure**

- **Arrange**: Set up test data and mocks
- **Act**: Execute the function or render the component
- **Assert**: Verify the expected behavior

### 2. **Test Naming**

- Use descriptive test names
- Include the expected behavior
- Group related tests in describe blocks

### 3. **Test Data**

- Use realistic test data
- Test edge cases and boundary conditions
- Include both positive and negative test cases

### 4. **Assertions**

- Use specific assertions
- Test both presence and absence of elements
- Verify attributes and content

### 5. **Cleanup**

- Clean up after each test
- Reset mocks and state
- Avoid test interdependencies

## 🐛 **Debugging Tests**

### Debug Mode

```typescript
// Enable debug logging
console.log('Test content:', content);
console.log('Rendered HTML:', container.innerHTML);
console.log('Elements found:', container.querySelectorAll('*'));
```

### Test Isolation

```typescript
// Isolate specific tests
test.only('should render markdown correctly', () => {
  // This test will run in isolation
});
```

### Mock Data

```typescript
// Create mock data for testing
const mockContent = {
  simple: 'Hello World',
  markdown: '**Bold** and *italic*',
  latex: '$E = mc^2$',
  dangerous: '<script>alert("XSS")</script>',
};
```

## 📈 **Performance Testing**

### Rendering Performance

```typescript
test('should render quickly', () => {
  const start = performance.now()
  render(<SecureTextRenderer content={largeContent} />)
  const end = performance.now()

  expect(end - start).toBeLessThan(100) // Should render in < 100ms
})
```

### Memory Usage

```typescript
test('should not leak memory', () => {
  const { unmount } = render(<SecureTextRenderer content={content} />)
  unmount()

  // Check for memory leaks
  expect(global.gc).toBeDefined()
})
```

## 🔍 **Coverage Analysis**

### Coverage Reports

```bash
# Generate coverage report
npm run test:coverage

# View coverage in browser
open coverage/index.html
```

### Coverage Thresholds

- **Global**: 80% coverage required
- **Parser modules**: 90% coverage required
- **Components**: 80% coverage required

## 🚨 **Common Test Issues**

### 1. **Async Operations**

```typescript
// Wait for async operations
await waitFor(() => {
  expect(screen.getByText('Content')).toBeInTheDocument();
});
```

### 2. **Element Queries**

```typescript
// Use appropriate query methods
screen.getByText('Text'); // Exact text match
screen.getByRole('button'); // By role
screen.getByTestId('test-id'); // By test ID
```

### 3. **Mock Functions**

```typescript
// Mock functions properly
const mockFunction = vi.fn();
expect(mockFunction).toHaveBeenCalledWith(expectedArgs);
```

## 📚 **Additional Resources**

- **Vitest Documentation**: https://vitest.dev/
- **Testing Library**: https://testing-library.com/
- **Jest DOM**: https://github.com/testing-library/jest-dom
- **Test Examples**: [../tests/unit/renderer/](../tests/unit/renderer/)

---

**Happy Testing!** 🧪

Comprehensive testing ensures the reliability and security of the SecureTextRenderer component.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: hooks\use-mobile.tsx
SIZE: 576 bytes | LINES: 20
================================================================================
import * as React from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);

  return !!isMobile;
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: hooks\use-toast.ts
SIZE: 1,568 bytes | LINES: 64
================================================================================
'use client';
import { useState, useCallback } from 'react';
import type { Toast } from '@/components/toast-notification';

export function useToast() {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const addToast = useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9);
    const newToast: Toast = { ...toast, id };

    setToasts((prev) => [...prev, newToast]);

    return id;
  }, []);

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const showSuccess = useCallback(
    (title: string, message?: string, duration?: number) => {
      return addToast({ type: 'success', title, message, duration });
    },
    [addToast],
  );

  const showError = useCallback(
    (title: string, message?: string, duration?: number) => {
      return addToast({ type: 'error', title, message, duration });
    },
    [addToast],
  );

  const showInfo = useCallback(
    (title: string, message?: string, duration?: number) => {
      return addToast({ type: 'info', title, message, duration });
    },
    [addToast],
  );

  const showWarning = useCallback(
    (title: string, message?: string, duration?: number) => {
      return addToast({ type: 'warning', title, message, duration });
    },
    [addToast],
  );

  const clearAllToasts = useCallback(() => {
    setToasts([]);
  }, []);

  return {
    toasts,
    addToast,
    removeToast,
    showSuccess,
    showError,
    showInfo,
    showWarning,
    clearAllToasts,
  };
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\markdown\latex-processor.ts
SIZE: 1,519 bytes | LINES: 53
================================================================================
import katex from 'katex';
import 'katex/dist/katex.min.css';

/**
 * Process LaTeX math expressions in text
 * @param text - The text containing LaTeX expressions
 * @returns HTML with KaTeX-rendered math
 */
export function processLatex(text: string): string {
  // Process display math first: $$...$$
  text = text.replace(/\$\$([^$]+)\$\$/g, (match, math) => {
    try {
      const rendered = katex.renderToString(math, {
        throwOnError: false,
        trust: false, // Security: don't trust user input
        displayMode: true,
      });
      // KaTeX already includes the katex-display class, so we don't need to wrap it
      return rendered;
    } catch {
      // If KaTeX fails, return the original text
      return match;
    }
  });

  // Process inline math: $...$ (but not $$...$$)
  text = text.replace(/(?<!\$)\$([^$]+)\$(?!\$)/g, (match, math) => {
    try {
      const rendered = katex.renderToString(math, {
        throwOnError: false,
        trust: false, // Security: don't trust user input
        displayMode: false,
      });
      // KaTeX already includes the katex-inline class, so we don't need to wrap it
      return rendered;
    } catch {
      // If KaTeX fails, return the original text
      return match;
    }
  });

  return text;
}

/**
 * Check if text contains LaTeX expressions
 * @param text - The text to check
 * @returns true if LaTeX expressions are found
 */
export function hasLatex(text: string): boolean {
  return /\$[^$]+\$|\$\$[^$]+\$\$/.test(text);
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\markdown\pipeline.ts
SIZE: 4,279 bytes | LINES: 174
================================================================================
/**
 * Safe Markdown Pipeline with XSS Protection
 *
 * This module provides a unified remark/rehype pipeline for processing markdown
 * with comprehensive XSS sanitization while preserving LaTeX rendering.
 */

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkRehype from 'remark-rehype';
import rehypeRaw from 'rehype-raw';
import rehypeKatex from 'rehype-katex';
import rehypeSanitize from 'rehype-sanitize';
import rehypeStringify from 'rehype-stringify';

// Custom sanitization schema for safe HTML
const sanitizeSchema = {
  tagNames: [
    // Text formatting
    'b',
    'i',
    'em',
    'strong',
    'code',
    'pre',
    'br',
    // Lists
    'ul',
    'ol',
    'li',
    // Tables
    'table',
    'thead',
    'tbody',
    'tr',
    'th',
    'td',
    // Structure
    'p',
    'div',
    'span',
    'blockquote',
    // Links and images (with restrictions)
    'a',
    'img',
    // Headings
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    // Horizontal rule
    'hr',
    // Strikethrough
    'del',
    's',
    // Task lists
    'input',
  ],
  attributes: {
    // Allow href on links but sanitize URLs
    a: ['href', 'title', 'target', 'rel'],
    // Allow src and alt on images
    img: ['src', 'alt', 'title', 'width', 'height'],
    // Allow class for styling
    '*': ['class'],
    // Allow data attributes for KaTeX
    span: ['data-katex', 'data-katex-display'],
    div: ['data-katex', 'data-katex-display'],
    // Allow type and checked for task lists
    input: ['type', 'checked', 'disabled'],
    // Allow code language classes
    code: ['class'],
    pre: ['class'],
  },
  protocols: {
    href: ['http', 'https', 'mailto'],
    src: ['http', 'https', 'data'],
  },
  // Custom URL sanitization
  urlFilter: (url: string) => {
    // Block javascript: URLs
    if (url.toLowerCase().startsWith('javascript:')) {
      return false;
    }
    // Block data: URLs except for images
    if (url.toLowerCase().startsWith('data:') && !url.toLowerCase().startsWith('data:image/')) {
      return false;
    }
    return true;
  },
};

/**
 * Process markdown content through the safe pipeline
 */
export async function processMarkdown(content: string): Promise<string> {
  try {
    const processor = unified()
      .use(remarkParse) // Parse markdown
      .use(remarkGfm) // GitHub Flavored Markdown (tables, strikethrough, task lists)
      .use(remarkMath) // Math support
      .use(remarkRehype) // Convert to HTML AST
      .use(rehypeRaw) // Allow raw HTML
      .use(rehypeKatex) // Render math with KaTeX
      .use(rehypeSanitize, sanitizeSchema) // Sanitize HTML
      .use(rehypeStringify); // Convert to HTML string

    const result = await processor.process(content);
    return String(result);
  } catch (error) {
    console.error('Markdown processing error:', error);
    // Return sanitized fallback
    return sanitizeFallback(content);
  }
}

/**
 * Fallback sanitization for when the pipeline fails
 */
function sanitizeFallback(content: string): string {
  // Basic HTML escaping
  const escaped = content
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  // Convert line breaks to <br>
  return escaped.replace(/\n/g, '<br>');
}

/**
 * Check if content contains mermaid diagrams
 */
export function hasMermaidContent(content: string): boolean {
  return /```mermaid\s*[\s\S]*?```/i.test(content);
}

/**
 * Extract mermaid diagrams from content
 */
export function extractMermaidDiagrams(content: string): string[] {
  const mermaidRegex = /```mermaid\s*([\s\S]*?)```/gi;
  const diagrams: string[] = [];
  let match;

  while ((match = mermaidRegex.exec(content)) !== null) {
    diagrams.push(match[1].trim());
  }

  return diagrams;
}

/**
 * Process content and return both HTML and mermaid diagrams
 */
export async function processContentWithMermaid(content: string): Promise<{
  html: string;
  mermaidDiagrams: string[];
}> {
  const mermaidDiagrams = extractMermaidDiagrams(content);
  const html = await processMarkdown(content);

  return {
    html,
    mermaidDiagrams,
  };
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\markdown\sync-pipeline.ts
SIZE: 3,183 bytes | LINES: 117
================================================================================
/**
 * Synchronous Markdown Pipeline with XSS Protection
 *
 * This module provides a synchronous markdown processing pipeline with XSS sanitization.
 */

/**
 * Synchronous markdown to HTML converter with XSS protection
 */
export function processMarkdownSync(content: string): string {
  try {
    console.log('Processing markdown sync:', content.substring(0, 100) + '...');

    // Basic XSS protection - escape HTML
    let html = content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    // Basic markdown processing
    // Headers
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

    // Bold and italic
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

    // Inline code
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Code blocks
    html = html.replace(
      /```(\w+)?\n([\s\S]*?)```/g,
      '<pre><code class="language-$1">$2</code></pre>',
    );

    // Lists - fix the regex to handle multiple list items
    html = html.replace(/^[\*\-] (.*)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>');

    // Ordered lists
    html = html.replace(/^\d+\. (.*)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/g, '<ol>$1</ol>');

    // Links
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

    // Images
    html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');

    // Line breaks
    html = html.replace(/\n/g, '<br>');

    console.log('Processed HTML sync:', html.substring(0, 200) + '...');
    return html;
  } catch (error) {
    console.error('Markdown processing error:', error);
    // Return basic HTML escaping as fallback
    return content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/\n/g, '<br>');
  }
}

/**
 * Async wrapper for backwards compatibility
 */
export async function processMarkdown(content: string): Promise<string> {
  return processMarkdownSync(content);
}

/**
 * Check if content contains mermaid diagrams
 */
export function hasMermaidContent(content: string): boolean {
  return /```mermaid\s*[\s\S]*?```/i.test(content);
}

/**
 * Extract mermaid diagrams from content
 */
export function extractMermaidDiagrams(content: string): string[] {
  const mermaidRegex = /```mermaid\s*([\s\S]*?)```/gi;
  const diagrams: string[] = [];
  let match;

  while ((match = mermaidRegex.exec(content)) !== null) {
    diagrams.push(match[1].trim());
  }

  return diagrams;
}

/**
 * Process content and return both HTML and mermaid diagrams
 */
export async function processContentWithMermaid(content: string): Promise<{
  html: string;
  mermaidDiagrams: string[];
}> {
  const mermaidDiagrams = extractMermaidDiagrams(content);
  const html = processMarkdownSync(content);

  return {
    html,
    mermaidDiagrams,
  };
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\markdown\working-pipeline.ts
SIZE: 2,920 bytes | LINES: 107
================================================================================
/**
 * Working Markdown Pipeline with XSS Protection
 *
 * This module provides a basic markdown processing pipeline with XSS sanitization.
 */

/**
 * Basic markdown to HTML converter with XSS protection
 */
export async function processMarkdown(content: string): Promise<string> {
  try {
    console.log('Processing markdown:', content.substring(0, 100) + '...');

    // Basic XSS protection - escape HTML
    let html = content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    // Basic markdown processing
    // Headers
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

    // Bold and italic
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

    // Inline code
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Code blocks
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');

    // Lists
    html = html.replace(/^\* (.*$)/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>');

    // Ordered lists
    html = html.replace(/^\d+\. (.*$)/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/g, '<ol>$1</ol>');

    // Links
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

    // Images
    html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');

    // Line breaks
    html = html.replace(/\n/g, '<br>');

    console.log('Processed HTML (basic):', html.substring(0, 200) + '...');
    return html;
  } catch (error) {
    console.error('Markdown processing error:', error);
    // Return basic HTML escaping as fallback
    return content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/\n/g, '<br>');
  }
}

/**
 * Check if content contains mermaid diagrams
 */
export function hasMermaidContent(content: string): boolean {
  return /```mermaid\s*[\s\S]*?```/i.test(content);
}

/**
 * Extract mermaid diagrams from content
 */
export function extractMermaidDiagrams(content: string): string[] {
  const mermaidRegex = /```mermaid\s*([\s\S]*?)```/gi;
  const diagrams: string[] = [];
  let match;

  while ((match = mermaidRegex.exec(content)) !== null) {
    diagrams.push(match[1].trim());
  }

  return diagrams;
}

/**
 * Process content and return both HTML and mermaid diagrams
 */
export async function processContentWithMermaid(content: string): Promise<{
  html: string;
  mermaidDiagrams: string[];
}> {
  const mermaidDiagrams = extractMermaidDiagrams(content);
  const html = await processMarkdown(content);

  return {
    html,
    mermaidDiagrams,
  };
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\schema\quiz.ts
SIZE: 5,733 bytes | LINES: 136
================================================================================
import { z } from 'zod';

// Base schemas
export const QuizOptionSchema = z.object({
  optionId: z.string().min(1, 'Option ID is required'),
  optionText: z.string().min(1, 'Option text is required'),
});

export const QuizQuestionSchema = z.object({
  questionId: z.string().min(1, 'Question ID is required'),
  questionText: z.string().min(1, 'Question text is required'),
  options: z.array(QuizOptionSchema).min(2, 'At least 2 options are required'),
  correctOptionIds: z.array(z.string()).min(1, 'At least one correct option is required'),
  explanationText: z.string().min(1, 'Explanation text is required'),
  type: z.enum(['mcq', 'true_false']).optional(),
  // Performance tracking fields
  status: z
    .enum(['not_attempted', 'attempted', 'passed_once', 'review_soon', 'review_later', 'mastered'])
    .optional(),
  timesAnsweredCorrectly: z.number().int().min(0).optional(),
  timesAnsweredIncorrectly: z.number().int().min(0).optional(),
  lastSelectedOptionId: z.string().optional(),
  historyOfIncorrectSelections: z.array(z.string()).optional(),
  lastAttemptedAt: z.string().optional(),
  // SRS fields
  srsLevel: z.number().int().min(0).max(2).optional(),
  nextReviewAt: z.string().nullable().optional(),
  shownIncorrectOptionIds: z.array(z.string()).optional(),
});

export const QuizChapterSchema = z.object({
  id: z.string().min(1, 'Chapter ID is required'),
  name: z.string().min(1, 'Chapter name is required'),
  description: z.string().optional(),
  questions: z.array(QuizQuestionSchema).min(1, 'At least one question is required'),
  totalQuestions: z.number().int().min(0),
  answeredQuestions: z.number().int().min(0),
  correctAnswers: z.number().int().min(0),
  isCompleted: z.boolean(),
});

export const QuizModuleSchema = z.object({
  name: z.string().min(1, 'Module name is required'),
  description: z.string().optional(),
  chapters: z.array(QuizChapterSchema).min(1, 'At least one chapter is required'),
});

// Additional schemas for extended functionality
export const DisplayedOptionSchema = QuizOptionSchema.extend({
  isCorrect: z.boolean().optional(),
  isSelected: z.boolean().optional(),
});

export const ReviewQueueItemSchema = z.object({
  chapterId: z.string().min(1, 'Chapter ID is required'),
  questionId: z.string().min(1, 'Question ID is required'),
  question: QuizQuestionSchema,
});

export const IncorrectAnswerLogEntrySchema = z.object({
  questionId: z.string().min(1, 'Question ID is required'),
  questionText: z.string().min(1, 'Question text is required'),
  chapterId: z.string().min(1, 'Chapter ID is required'),
  chapterName: z.string().min(1, 'Chapter name is required'),
  incorrectSelections: z.array(
    z.object({
      selectedOptionId: z.string().min(1, 'Selected option ID is required'),
      selectedOptionText: z.string().min(1, 'Selected option text is required'),
    }),
  ),
  correctOptionIds: z.array(z.string()).min(1, 'At least one correct option is required'),
  correctOptionTexts: z.array(z.string()).min(1, 'At least one correct option text is required'),
  explanationText: z.string().min(1, 'Explanation text is required'),
  totalTimesCorrect: z.number().int().min(0),
  totalTimesIncorrect: z.number().int().min(0),
  currentSrsLevel: z.number().int().min(0).max(2),
  lastAttemptedAt: z.string().optional(),
});

export const SrsProgressCountsSchema = z.object({
  newOrLapsingDue: z.number().int().min(0),
  learningReviewDue: z.number().int().min(0),
  totalNonMastered: z.number().int().min(0),
});

export const SessionHistoryEntrySchema = z.object({
  questionSnapshot: QuizQuestionSchema,
  selectedOptionId: z.string().min(1, 'Selected option ID is required'),
  displayedOptions: z.array(DisplayedOptionSchema),
  isCorrect: z.boolean(),
  isReviewSessionQuestion: z.boolean(),
  chapterId: z.string().min(1, 'Chapter ID is required'),
});

// Type exports
export type QuizOption = z.infer<typeof QuizOptionSchema>;
export type QuizQuestion = z.infer<typeof QuizQuestionSchema>;
export type QuizChapter = z.infer<typeof QuizChapterSchema>;
export type QuizModule = z.infer<typeof QuizModuleSchema>;
export type DisplayedOption = z.infer<typeof DisplayedOptionSchema>;
export type ReviewQueueItem = z.infer<typeof ReviewQueueItemSchema>;
export type IncorrectAnswerLogEntry = z.infer<typeof IncorrectAnswerLogEntrySchema>;
export type SrsProgressCounts = z.infer<typeof SrsProgressCountsSchema>;
export type SessionHistoryEntry = z.infer<typeof SessionHistoryEntrySchema>;

// Parser functions
export const parseQuizOption = (data: unknown): QuizOption => QuizOptionSchema.parse(data);
export const parseQuizQuestion = (data: unknown): QuizQuestion => QuizQuestionSchema.parse(data);
export const parseQuizChapter = (data: unknown): QuizChapter => QuizChapterSchema.parse(data);
export const parseQuizModule = (data: unknown): QuizModule => QuizModuleSchema.parse(data);

// Assertion function for QuizModule
export function assertQuizModule(value: unknown): asserts value is QuizModule {
  QuizModuleSchema.parse(value);
}

// Validation helpers
export const validateQuizModule = (
  data: unknown,
): { success: true; data: QuizModule } | { success: false; error: z.ZodError } => {
  try {
    const result = QuizModuleSchema.parse(data);
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error };
    }
    throw error;
  }
};

// Safe parsing with error handling
export const safeParseQuizModule = (data: unknown) => QuizModuleSchema.safeParse(data);
export const safeParseQuizQuestion = (data: unknown) => QuizQuestionSchema.safeParse(data);
export const safeParseQuizChapter = (data: unknown) => QuizChapterSchema.safeParse(data);


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: lib\utils.ts
SIZE: 169 bytes | LINES: 7
================================================================================
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: next-env.d.ts
SIZE: 216 bytes | LINES: 6
================================================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: postcss.config.mjs
SIZE: 135 bytes | LINES: 9
================================================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: public\advanced-test-quiz.md
SIZE: 15,200 bytes | LINES: 594
================================================================================
# Advanced Test Quiz - All Features

_Comprehensive test of SecureTextRenderer capabilities_

---

## Basic Text and Formatting <!-- CH_ID: basic -->

Description: Testing basic markdown features.

---

### Q: What is the time complexity of binary search? <!-- Q_ID: basic_binary_search -->

This question tests **bold text**, _italic text_, and `inline code`.

**Options:**
**A1:** O(n)
**A2:** O(log n)
**A3:** O(n²)
**A4:** O(n log n)

**Correct:** A2

**Exp:**
Binary search has $O(\log n)$ time complexity because it eliminates half the search space with each comparison.

The recurrence relation is: $T(n) = T(n/2) + O(1)$

---

### T/F: Arrays provide O(1) random access. <!-- Q_ID: basic_array_access -->

Testing True/False questions.

**Correct:** True

**Exp:**
Yes, arrays provide $O(1)$ random access using indexing.

**Why this is true:**

- Arrays store elements in contiguous memory locations
- Each element can be accessed directly using its index
- No traversal is needed, making it a constant-time operation
- This is one of the main advantages of arrays over linked lists

---

## LaTeX Math Testing <!-- CH_ID: latex -->

Description: Comprehensive LaTeX math expressions.

---

### Q: What is the solution to the quadratic equation ax² + bx + c = 0? <!-- Q_ID: latex_quadratic -->

Testing complex mathematical expressions.

**Options:**
**A1:** $x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$
**A2:** $x = \frac{b \pm \sqrt{b^2 - 4ac}}{2a}$
**A3:** $x = \frac{-b \pm \sqrt{b^2 + 4ac}}{2a}$
**A4:** $x = \frac{b \pm \sqrt{b^2 + 4ac}}{2a}$

**Correct:** A1

**Exp:**
The quadratic formula is $x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$.

**Derivation:**
Starting with $ax^2 + bx + c = 0$:

$$ax^2 + bx + c = 0$$
$$x^2 + \frac{b}{a}x + \frac{c}{a} = 0$$
$$x^2 + \frac{b}{a}x = -\frac{c}{a}$$
$$x^2 + \frac{b}{a}x + \left(\frac{b}{2a}\right)^2 = -\frac{c}{a} + \left(\frac{b}{2a}\right)^2$$
$$\left(x + \frac{b}{2a}\right)^2 = \frac{b^2 - 4ac}{4a^2}$$
$$x + \frac{b}{2a} = \pm\frac{\sqrt{b^2 - 4ac}}{2a}$$
$$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$

---

### Q: What is the integral of x²? <!-- Q_ID: latex_integral -->

Testing calculus expressions.

**Options:**
**A1:** $\frac{x^3}{3} + C$
**A2:** $2x + C$
**A3:** $\frac{x^3}{2} + C$
**A4:** $x^3 + C$

**Correct:** A1

**Exp:**
The integral of $x^2$ is $\frac{x^3}{3} + C$.

**Proof:**
$$\int x^2 \, dx = \frac{x^{2+1}}{2+1} + C = \frac{x^3}{3} + C$$

---

## Code Blocks Testing <!-- CH_ID: code -->

Description: Testing code block rendering.

---

### Q: What does this Python code output? <!-- Q_ID: code_python -->

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))
```

**Options:**
**A1:** 5
**A2:** 8
**A3:** 13
**A4:** 21

**Correct:** A1

**Exp:**
The code outputs **5**.

**Explanation:**

- fibonacci(0) = 0
- fibonacci(1) = 1
- fibonacci(2) = fibonacci(1) + fibonacci(0) = 1 + 0 = 1
- fibonacci(3) = fibonacci(2) + fibonacci(1) = 1 + 1 = 2
- fibonacci(4) = fibonacci(3) + fibonacci(2) = 2 + 1 = 3
- fibonacci(5) = fibonacci(4) + fibonacci(3) = 3 + 2 = 5

---

### Q: What does this JavaScript code output? <!-- Q_ID: code_javascript -->

```javascript
const arr = [1, 2, 3, 4, 5];
const result = arr.map((x) => x * 2).filter((x) => x > 5);
console.log(result);
```

**Options:**
**A1:** [6, 8, 10]
**A2:** [2, 4, 6, 8, 10]
**A3:** [1, 2, 3, 4, 5]
**A4:** [5, 6, 7, 8, 9]

**Correct:** A1

**Exp:**
The code outputs **[6, 8, 10]**.

**Step-by-step:**

1. `arr.map(x => x * 2)` creates `[2, 4, 6, 8, 10]`
2. `.filter(x => x > 5)` keeps only `[6, 8, 10]`

---

## Tables Testing <!-- CH_ID: tables -->

Description: Testing table rendering.

---

### Q: Which sorting algorithm has the best average-case time complexity? <!-- Q_ID: tables_sorting -->

Based on the following comparison table:

| Algorithm   | Best Case  | Average Case | Worst Case | Space    |
| ----------- | ---------- | ------------ | ---------- | -------- |
| Bubble Sort | O(n)       | O(n²)        | O(n²)      | O(1)     |
| Quick Sort  | O(n log n) | O(n log n)   | O(n²)      | O(log n) |
| Merge Sort  | O(n log n) | O(n log n)   | O(n log n) | O(n)     |
| Heap Sort   | O(n log n) | O(n log n)   | O(n log n) | O(1)     |

**Options:**
**A1:** Bubble Sort
**A2:** Quick Sort
**A3:** Merge Sort
**A4:** Heap Sort

**Correct:** A2

**Exp:**
**Quick Sort** has the best average-case time complexity of $O(n \log n)$.

**Analysis:**

- All algorithms have $O(n \log n)$ average case
- But Quick Sort is typically faster in practice due to better constants
- Quick Sort has better cache performance and fewer comparisons

---

### Q: What is the space complexity of Merge Sort? <!-- Q_ID: tables_merge_sort -->

Using the sorting algorithms comparison table above.

**Options:**
**A1:** O(1)
**A2:** O(log n)
**A3:** O(n)
**A4:** O(n log n)

**Correct:** A3

**Exp:**
Merge Sort has $O(n)$ space complexity because it requires additional space for the temporary arrays during the merge process.

**From the table above:**

- Merge Sort shows "O(n)" in the Space column
- This is because it needs extra space to store temporary arrays during the merge operation
- Unlike Quick Sort (O(log n)) or Heap Sort (O(1)), Merge Sort requires linear extra space

---

### T/F: Merge Sort is a stable sorting algorithm. <!-- Q_ID: tables_stable_sort -->

Understanding the stability property of sorting algorithms.

**Correct:** True

**Exp:**
Yes, Merge Sort is a **stable** sorting algorithm.

**Why Merge Sort is stable:**

- Stability means that equal elements maintain their relative order after sorting
- Merge Sort preserves the original order of equal elements during the merge process
- When merging two sorted subarrays, if elements are equal, the algorithm chooses from the left subarray first
- This ensures that the original relative order of equal elements is maintained

---

## Lists Testing <!-- CH_ID: lists -->

Description: Testing various list types.

---

### Q: Which of the following are advantages of linked lists? <!-- Q_ID: lists_advantages -->

**Options:**
**A1:** Dynamic size
**A2:** Random access
**A3:** Memory efficiency
**A4:** Cache performance

**Correct:** A1

**Exp:**
**Dynamic size** is an advantage of linked lists.

**Advantages of linked lists:**

- ✅ Dynamic size (can grow/shrink at runtime)
- ✅ Efficient insertion/deletion at any position
- ✅ No memory waste (only allocate what you need)
- ✅ Easy to implement

**Disadvantages:**

- ❌ No random access (must traverse from head)
- ❌ Extra memory for pointers
- ❌ Poor cache performance (nodes not contiguous)
- ❌ More complex implementation

---

### Q: What are the main operations of a stack? <!-- Q_ID: lists_stack_ops -->

**Options:**
**A1:** push, pop, peek
**A2:** enqueue, dequeue, front
**A3:** insert, delete, search
**A4:** add, remove, find

**Correct:** A1

**Exp:**
The main operations of a stack are **push, pop, and peek**.

**Stack operations:**

- **push(item)**: Add item to top of stack
- **pop()**: Remove and return top item
- **peek()**: Return top item without removing
- **isEmpty()**: Check if stack is empty
- **size()**: Return number of items

---

### T/F: A stack can be implemented using two queues. <!-- Q_ID: lists_stack_queues -->

Understanding the relationship between different data structures.

**Correct:** True

**Exp:**
Yes, a stack can be implemented using two queues, though it's not the most efficient approach.

**How to implement stack with two queues:**

- **Method 1**: Use one queue for storage, another for temporary operations
- **Push**: Add element to queue1
- **Pop**: Move all elements except the last from queue1 to queue2, then remove the last element from queue1, then move everything back from queue2 to queue1
- **Time complexity**: O(n) for pop operations, O(1) for push
- **Space complexity**: O(n) for the two queues

**Note**: This is less efficient than using a single array or linked list for stack implementation.

---

## Mixed Content Testing <!-- CH_ID: mixed -->

Description: Testing complex combinations of features.

---

### Q: What is the time complexity of this algorithm? <!-- Q_ID: mixed_algorithm -->

Consider the following algorithm:

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**Options:**
**A1:** O(1)
**A2:** O(log n)
**A3:** O(n)
**A4:** O(n log n)

**Correct:** A2

**Exp:**
The time complexity is $O(\log n)$.

**Analysis:**

- Each iteration eliminates half the search space
- Maximum iterations = $\log_2(n)$
- Each iteration takes $O(1)$ time
- Total time = $O(\log n)$

**Space complexity**: $O(1)$ (iterative approach)

---

### Q: Which data structure is best for implementing a priority queue? <!-- Q_ID: mixed_priority_queue -->

**Options:**
**A1:** Array
**A2:** Linked List
**A3:** Binary Heap
**A4:** Hash Table

**Correct:** A3

**Exp:**
**Binary Heap** is the best data structure for implementing a priority queue.

**Comparison table:**

| Data Structure  | Insert       | Extract Min  | Space    |
| --------------- | ------------ | ------------ | -------- |
| Array           | O(n)         | O(n)         | O(n)     |
| Linked List     | O(n)         | O(n)         | O(n)     |
| **Binary Heap** | **O(log n)** | **O(log n)** | **O(n)** |
| Hash Table      | O(1)         | O(n)         | O(n)     |

**Why Binary Heap?**

- Efficient insertion: $O(\log n)$
- Efficient extraction: $O(\log n)$
- Simple implementation
- Good cache performance

---

## Security Testing <!-- CH_ID: security -->

Description: Testing XSS protection and security features.

---

### Q: What is the result of this expression? <!-- Q_ID: security_expression -->

Evaluate: $2 + 3 \times 4$

**Options:**
**A1:** 20
**A2:** 14
**A3:** 11
**A4:** 24

**Correct:** B2

**Exp:**
The result is **14**.

**Order of operations:**

1. Multiplication first: $3 \times 4 = 12$
2. Addition: $2 + 12 = 14$

**Note**: This tests that mathematical expressions are rendered correctly and not interpreted as HTML.

---

### Q: Which of the following is a valid HTML tag? <!-- Q_ID: security_html -->

**Options:**
**A1:** `<script>alert('XSS')</script>`
**A2:** `<div>Hello World</div>`
**A3:** `<img src="x" onerror="alert('XSS')">`
**A4:** `<a href="javascript:alert('XSS')">Click</a>`

**Correct:** A2

**Exp:**
**`<div>Hello World</div>`** is a valid, safe HTML tag.

**Security analysis:**

- ❌ `<script>` tags are dangerous and should be removed
- ✅ `<div>` tags are safe for content display
- ❌ `onerror` attributes are dangerous and should be removed
- ❌ `javascript:` URLs are dangerous and should be blocked

---

### T/F: All HTML tags are safe to render in a web application. <!-- Q_ID: security_html_safety -->

Understanding HTML security risks.

**Correct:** False

**Exp:**
No, not all HTML tags are safe to render in a web application.

**Dangerous HTML tags:**

- `<script>` - Can execute JavaScript code
- `<iframe>` - Can load external content and create security risks
- `<form>` - Can submit data to malicious endpoints
- `<input>` - Can be used for form-based attacks
- `<button>` - Can trigger unwanted actions
- `<img>` with `onerror` - Can execute JavaScript on error
- `<a>` with `javascript:` URLs - Can execute JavaScript

**Safe HTML tags:**

- `<div>`, `<span>`, `<p>` - For content structure
- `<h1>` to `<h6>` - For headings
- `<strong>`, `<em>` - For text emphasis
- `<ul>`, `<ol>`, `<li>` - For lists
- `<table>`, `<tr>`, `<td>` - For tables (with proper sanitization)

**Best practice**: Always sanitize HTML content before rendering to prevent XSS attacks.

---

## Edge Cases Testing <!-- CH_ID: edge_cases -->

Description: Testing edge cases and special characters.

---

### Q: What is the result of this expression? <!-- Q_ID: edge_unicode -->

Evaluate: $\sum_{i=1}^{n} i = \frac{n(n+1)}{2}$

**Options:**
**A1:** $n^2$
**A2:** $\frac{n(n+1)}{2}$
**A3:** $n(n+1)$
**A4:** $\frac{n^2}{2}$

**Correct:** A2

**Exp:**
The sum of the first n natural numbers is $\frac{n(n+1)}{2}$.

**Proof by induction:**

- **Base case (n=1)**: $1 = \frac{1 \cdot 2}{2} = 1$ ✓
- **Inductive step**: Assume true for n=k
- For n=k+1: $\sum_{i=1}^{k+1} i = \sum_{i=1}^{k} i + (k+1) = \frac{k(k+1)}{2} + (k+1) = \frac{k(k+1) + 2(k+1)}{2} = \frac{(k+1)(k+2)}{2}$ ✓

---

### Q: What is the time complexity of this algorithm? <!-- Q_ID: edge_nested_loops -->

```python
for i in range(n):
    for j in range(i):
        print(i, j)
```

**Options:**
**A1:** O(n)
**A2:** O(n log n)
**A3:** O(n²)
**A4:** O(n³)

**Correct:** A3

**Exp:**
The time complexity is $O(n^2)$.

**Analysis:**

- Outer loop runs n times
- Inner loop runs i times for each i
- Total iterations: $1 + 2 + 3 + \ldots + (n-1) = \frac{n(n-1)}{2} = O(n^2)$

---

### T/F: Unicode characters can cause issues in markdown parsing. <!-- Q_ID: edge_unicode_parsing -->

Understanding Unicode handling in text processing.

**Correct:** False

**Exp:**
No, Unicode characters should not cause issues in proper markdown parsing.

**Why Unicode should work:**

- Modern markdown parsers support UTF-8 encoding
- Unicode characters are just text and don't have special markdown meaning
- Characters like àáâãäåæçèéêë are treated as regular text
- Emojis like 🚀 📝 ✅ ❌ ⚠️ are also just text characters
- Math symbols like ∑ ∏ ∫ ∂ ∇ are regular Unicode characters

**Potential issues (if they occur):**

- Old or poorly implemented parsers might not handle UTF-8 correctly
- Some systems might have encoding issues if not properly configured
- Display issues if the font doesn't support the Unicode characters

**Best practice**: Use a modern markdown parser that properly supports UTF-8 encoding.

---

## Conclusion

This advanced test quiz demonstrates all the capabilities of the SecureTextRenderer:

✅ **Basic Markdown**: Headers, bold, italic, inline code
✅ **LaTeX Math**: Inline ($...$) and display ($$...$$) math
✅ **Code Blocks**: Syntax-highlighted code in multiple languages
✅ **Tables**: Complex data presentation with proper formatting
✅ **Lists**: Ordered, unordered, and nested lists
✅ **Mixed Content**: Complex combinations of all features
✅ **Security**: XSS protection and safe HTML handling
✅ **Edge Cases**: Special characters, unicode, and complex expressions

The quiz includes:

- **25+ questions** covering all major features
- **Multiple question types**: MCQ and True/False
- **Mathematical expressions**: Complex LaTeX formulas
- **Code examples**: Python, JavaScript, and pseudocode
- **Tables**: Performance comparisons and data structures
- **Security testing**: XSS protection validation
- **Edge cases**: Unicode, special characters, and complex math
- **Multiline explanations**: Detailed step-by-step reasoning
- **Rich formatting**: Bold, italic, lists, and structured content

This serves as a comprehensive test suite for the SecureTextRenderer! 🚀


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: public\default-quiz.json
SIZE: 356,998 bytes | LINES: 6,507
================================================================================
{
  "name": "Algorithms and Data Structures MCQ Review",
  "description": "A comprehensive set of MCQs covering core concepts in algorithms, complexity, sorting, formal languages, and computability, designed for deep understanding and exam preparation.",
  "chapters": [
    {
      "id": "ch_fundamentals_1",
      "name": "Chapter 1: Fundamentals of Algorithms & Complexity",
      "description": "Focuses on the definition of algorithms, their properties, methods of description, and basic concepts of computational complexity.",
      "questions": [
        {
          "questionId": "ch_fundamentals_1_q1",
          "questionText": "Among the classical properties of an algorithm (e.g., by Knuth or Markov), which property specifically ensures that an algorithm must always terminate after a finite number of steps?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q1_opt1",
              "optionText": "**Finiteness**: An algorithm must always terminate after a finite number of steps."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt2",
              "optionText": "**Definiteness**: Each step must be precisely defined."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt3",
              "optionText": "**Input**: An algorithm has zero or more quantities that are externally supplied."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt4",
              "optionText": "**Output**: An algorithm has at least one quantity that is produced."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt5",
              "optionText": "**Effectiveness**: All operations must be sufficiently basic to be done exactly."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt6",
              "optionText": "**Optimality**: An algorithm must always provide the most efficient solution."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt7",
              "optionText": "**Clarity**: The algorithm should be easy to understand."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt8",
              "optionText": "**Generality**: The algorithm should apply to a broad range of inputs."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt9",
              "optionText": "**Determinism**: For a given input, an algorithm must always produce the same output (excluding randomized algorithms)."
            },
            {
              "optionId": "ch_fundamentals_1_q1_opt10",
              "optionText": "**Correctness**: The algorithm must produce the correct output for all valid inputs."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q1_opt1"],
          "explanationText": "The property that ensures an algorithm must always terminate after a finite number of steps is **Finiteness**. While Definiteness (unambiguous steps) and Effectiveness (basic, executable operations) are also foundational properties, Finiteness specifically addresses the termination requirement. Input and Output define its interface, and Optimality, Clarity, Generality, Determinism, and Correctness are other important characteristics or goals but not the one specifically about termination.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q2",
          "questionText": "When describing algorithms, `pseudocode` is often preferred over a specific programming language. Which statement _best encapsulates the primary benefit_ of using pseudocode for algorithm description?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q2_opt1",
              "optionText": "It abstracts away from specific programming language syntax, focusing on logic."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt2",
              "optionText": "It is easier for a wider audience (including those not proficient in a particular language) to understand."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt3",
              "optionText": "It can be directly compiled and executed by any computer."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt4",
              "optionText": "It enforces strict type checking, reducing logical errors during design."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt5",
              "optionText": "It typically has less syntactic noise than full programming languages."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt6",
              "optionText": "It always results in the most time-efficient algorithm design."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt7",
              "optionText": "It automatically generates test cases for the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt8",
              "optionText": "It is formally defined by an international standards body, ensuring consistency."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt9",
              "optionText": "It forces the use of object-oriented principles."
            },
            {
              "optionId": "ch_fundamentals_1_q2_opt10",
              "optionText": "It is primarily used for describing hardware designs, not software."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q2_opt1"],
          "explanationText": "The primary benefit of pseudocode is that **it abstracts away from specific programming language syntax, allowing the description to focus purely on the algorithm's logic**. This abstraction directly contributes to its other advantages, such as being easier for a wider audience (including those not proficient in a particular programming language) to understand and typically having less syntactic noise. Pseudocode is not directly compilable and does not enforce strict type checking like a programming language.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q3",
          "questionText": "What does the term **time complexity** of an algorithm primarily refer to? What is the _most fundamental characteristic_ that time complexity analysis aims to capture?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q3_opt1",
              "optionText": "The actual wall-clock time (e.g., in seconds) it takes for the algorithm to run on a specific computer."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt2",
              "optionText": "How the number of fundamental operations performed by the algorithm grows as the size of the input increases."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt3",
              "optionText": "The amount of memory (RAM) the algorithm uses during its execution."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt4",
              "optionText": "The number of lines of code in the algorithm's implementation."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt5",
              "optionText": "The complexity of understanding the algorithm's logic."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt6",
              "optionText": "The speed of the processor on which the algorithm is run."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt7",
              "optionText": "A measure of how difficult it is to program the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt8",
              "optionText": "The best-case execution time of the algorithm for the smallest possible input."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt9",
              "optionText": "A machine-independent measure of the algorithm's efficiency in terms of execution steps relative to input size."
            },
            {
              "optionId": "ch_fundamentals_1_q3_opt10",
              "optionText": "The maximum possible input size the algorithm can handle."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q3_opt2"],
          "explanationText": "Time complexity primarily refers to **how the number of fundamental operations performed by the algorithm grows as the size of the input increases**. This focus on growth relative to input size allows for a machine-independent measure of an algorithm's efficiency (as described by the concept of being a 'machine-independent measure'), abstracting away from specific hardware or exact clock times. It's distinct from space complexity (memory usage) or lines of code.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q4",
          "questionText": "When analyzing algorithms, why is the **worst-case complexity** _often the most crucial consideration_?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q4_opt1",
              "optionText": "It provides an upper bound on the algorithm's running time, guaranteeing performance will not be worse."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt2",
              "optionText": "The worst-case scenario occurs most frequently in real-world applications."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt3",
              "optionText": "Average-case complexity is often much harder to determine mathematically."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt4",
              "optionText": "Best-case complexity is not useful as it rarely happens."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt5",
              "optionText": "It is generally analyzed as a function of input size, abstracting from specific data values."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt6",
              "optionText": "It simplifies the analysis by allowing us to ignore constant factors."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt7",
              "optionText": "For many algorithms, the average case is often close to the worst case."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt8",
              "optionText": "It's easier to find test data that triggers worst-case behavior for debugging."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt9",
              "optionText": "Regulatory compliance in some fields requires guarantees based on worst-case performance."
            },
            {
              "optionId": "ch_fundamentals_1_q4_opt10",
              "optionText": "Worst-case complexity is always a polynomial function."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q4_opt1"],
          "explanationText": "The primary reason for focusing on worst-case complexity is that **it provides an upper bound on the algorithm's running time, guaranteeing performance will not be worse**. This guarantee is critical for many applications, especially real-time systems or those requiring predictable performance. While it's also true that average-case analysis can be much harder (as mentioned in one of the options) and that for some algorithms the average case is often close to the worst case, the performance guarantee is the most fundamental advantage. The option stating it's 'analyzed as a function of input size, abstracting from specific data values' describes a general aspect of complexity analysis, not unique to worst-case being crucial. Worst-case complexity is not always polynomial (e.g., it can be $O(2^n)$).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q5",
          "questionText": "Consider the following pseudocode to find the sum of an array $a$ of $n$ numbers:\n```pseudocode\ntotal ← 0\ni ← 0\nWHILE i < n\n  total ← total + a[i]\n  i ← i + 1\nRETURN total\n```\nWhen tracing this algorithm for an array like $a = [6, 9, 3]$ (so $n=3$), which statement _most accurately describes the state change after the very first complete pass_ through the loop body?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q5_opt1",
              "optionText": "The variable $i$ will take values 0, 1, 2, 3."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt2",
              "optionText": "The variable $total$ will be 0, 6, 15, 18 at the top of each loop iteration (including before the first)."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt3",
              "optionText": "The loop `WHILE i < n` executes exactly $n$ times."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt4",
              "optionText": "The value of $total$ before the first loop iteration is undefined."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt5",
              "optionText": "After the first iteration ($i=0$), $total$ is 6 and $i$ becomes 1."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt6",
              "optionText": "The algorithm returns the value of the last element, $a[n-1]$."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt7",
              "optionText": "The condition $i < n$ becomes false when $i$ equals $n$."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt8",
              "optionText": "The array $a$ is modified during the execution of this algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt9",
              "optionText": "At the top of the loop when $i=2$, $total$ holds the sum $a[0]+a[1]$."
            },
            {
              "optionId": "ch_fundamentals_1_q5_opt10",
              "optionText": "The final value returned for $a = [6, 9, 3]$ is 18."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q5_opt5"],
          "explanationText": "When tracing the algorithm with $a = [6, 9, 3]$: Initially, $total = 0$ and $i = 0$. In the first loop iteration (when $i$ is 0): $total$ becomes $0 + a[0]$ which is $0 + 6 = 6$. Then $i$ becomes $0 + 1 = 1$. Thus, **after the first iteration, $total$ is 6 and $i$ becomes 1**. The loop executes $n$ times in total, and for this specific input, the final returned value is 18.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_fundamentals_1_q6",
          "questionText": "What is **space complexity** primarily concerned with in the analysis of algorithms?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q6_opt1",
              "optionText": "The total amount of disk space required to store the algorithm's source code."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt2",
              "optionText": "The amount of memory used by the input data itself."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt3",
              "optionText": "The amount of **additional** memory (auxiliary space) an algorithm uses, apart from the space occupied by the input, as a function of input size."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt4",
              "optionText": "The number of variables declared in the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt5",
              "optionText": "The physical size of the computer needed to run the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt6",
              "optionText": "The growth of the call stack depth for recursive algorithms as a function of input size."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt7",
              "optionText": "The time it takes to allocate memory for the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt8",
              "optionText": "The sum of memory for input and auxiliary space."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt9",
              "optionText": "How efficiently the algorithm uses CPU cache memory."
            },
            {
              "optionId": "ch_fundamentals_1_q6_opt10",
              "optionText": "The complexity of the data structures used by the algorithm."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q6_opt3"],
          "explanationText": "Space complexity is primarily concerned with **the amount of additional memory (auxiliary space) an algorithm uses, apart from the space occupied by the input itself, as this auxiliary space requirement grows with the input size**. For recursive algorithms, the space used by the call stack (due to recursive calls storing activation records) is a significant component of this auxiliary space. It's distinct from the memory for source code or input data alone.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q7",
          "questionText": "Which of the following is an example of a common problem type encountered in the study of algorithms? (Select any one of the fundamental problem types.)",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q7_opt1",
              "optionText": "**Decision Problems**: Problems that require a yes/no answer."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt2",
              "optionText": "**Search Problems**: Problems that require finding a solution that satisfies certain criteria, if one exists."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt3",
              "optionText": "**Optimization Problems**: Problems that require finding the best solution among all possible solutions, according to some objective function."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt4",
              "optionText": "**Compilation Problems**: Problems related to translating source code into machine code."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt5",
              "optionText": "**Debugging Problems**: Problems related to finding and fixing errors in code."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt6",
              "optionText": "**Philosophical Problems**: Problems concerning the nature of computation itself."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt7",
              "optionText": "**User Interface Problems**: Problems related to designing effective user interactions."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt8",
              "optionText": "**Hardware Design Problems**: Problems related to the physical construction of computer components."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt9",
              "optionText": "**Network Routing Problems**: A specific type of optimization or search problem."
            },
            {
              "optionId": "ch_fundamentals_1_q7_opt10",
              "optionText": "**Natural Language Processing Problems**: A broad area that includes various decision, search, and optimization sub-problems."
            }
          ],
          "correctOptionIds": [
            "ch_fundamentals_1_q7_opt1",
            "ch_fundamentals_1_q7_opt2",
            "ch_fundamentals_1_q7_opt3"
          ],
          "explanationText": "The fundamental types of computational problems often categorized are **Decision Problems** (e.g., 'Does a path exist?'), **Search Problems** (e.g., 'Find a path if one exists.'), and **Optimization Problems** (e.g., 'Find the shortest path.'). Selecting any one of these identifies a common problem type. While areas like compilation, debugging, UI, hardware, networking, and NLP involve algorithms, they are application domains or process types rather than the primary abstract classifications of computational problems themselves based on their output requirements. Network routing can be an optimization problem, and NLP involves many types of problems.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q8",
          "questionText": "The 'effectiveness' property of an algorithm, as described by Knuth, means that all operations must be sufficiently basic to be practically executable. Which statement _best illustrates_ this concept?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q8_opt1",
              "optionText": "The algorithm must solve the problem correctly for all valid inputs."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt2",
              "optionText": "The algorithm must be the most efficient one possible for the given problem."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt3",
              "optionText": "Each step of the algorithm must be sufficiently basic and feasible to be carried out in practice."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt4",
              "optionText": "The algorithm must terminate within a reasonable amount of time."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt5",
              "optionText": "The algorithm should be easy to understand and implement."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt6",
              "optionText": "The operations are so clear they could, in principle, be done by a human with pencil and paper in finite time."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt7",
              "optionText": "The algorithm effectively uses all available system resources."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt8",
              "optionText": "The algorithm effectively communicates its results to the user."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt9",
              "optionText": "The algorithm can handle an effective range of input sizes."
            },
            {
              "optionId": "ch_fundamentals_1_q8_opt10",
              "optionText": "The algorithm must be written in an effective programming language."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q8_opt6"],
          "explanationText": "The 'effectiveness' property means each step of an algorithm must be sufficiently basic and feasible to be carried out in practice. The statement that **the operations are so clear they could, in principle, be done by a human with pencil and paper in finite time** best illustrates this. It emphasizes that each operation must be primitive and executable, distinguishing it from correctness (a separate goal), efficiency, or termination time (which is the Finiteness property).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q9",
          "questionText": "When evaluating an algorithm's efficiency, which primary dimension specifically refers to how fast the algorithm runs, typically measured by its growth rate of operations relative to input size?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q9_opt1",
              "optionText": "**Time efficiency**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt2",
              "optionText": "**Space efficiency**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt3",
              "optionText": "**Simplicity**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt4",
              "optionText": "**Correctness**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt5",
              "optionText": "**Scalability**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt6",
              "optionText": "**Robustness**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt7",
              "optionText": "**Energy efficiency**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt8",
              "optionText": "**Maintainability**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt9",
              "optionText": "**Generality**"
            },
            {
              "optionId": "ch_fundamentals_1_q9_opt10",
              "optionText": "**Portability**"
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q9_opt1"],
          "explanationText": "Algorithmic efficiency is primarily concerned with two dimensions: time and space. **Time efficiency** specifically refers to how fast the algorithm runs, which is typically characterized by its time complexity (e.g., $O(n)$, $O(n \\log n)$, $O(n^2)$), indicating how the number of operations grows with input size. Space efficiency, the other primary dimension, concerns memory usage.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_fundamentals_1_q10",
          "questionText": "In the context of analyzing an algorithm's time complexity, what is the _most defining characteristic_ of a 'fundamental step' or 'basic operation'?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q10_opt1",
              "optionText": "An operation whose execution time is considered constant and does not depend significantly on the input values (though it contributes to the overall count)."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt2",
              "optionText": "The most complex operation in the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt3",
              "optionText": "Any line of pseudocode."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt4",
              "optionText": "Operations that are directly related to the problem's core logic, such as comparisons in sorting or arithmetic operations in numerical algorithms."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt5",
              "optionText": "Only operations that access memory."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt6",
              "optionText": "The operation that is executed the most number of times for typical inputs."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt7",
              "optionText": "A function call within the algorithm."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt8",
              "optionText": "An operation that can be mapped to a single machine instruction on most processors."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt9",
              "optionText": "Loop control operations (initialization, condition check, increment)."
            },
            {
              "optionId": "ch_fundamentals_1_q10_opt10",
              "optionText": "The operation whose time cost is independent of the size of the input $n$."
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q10_opt10"],
          "explanationText": "The most defining characteristic of a 'basic operation' for time complexity analysis is that **its time cost is independent of the size of the input $n$**. Such operations (e.g., an integer comparison, an assignment) take a constant amount of time. These operations are also typically chosen because they are **directly related to the problem's core logic** (like comparisons in sorting) and can often be **mapped to a small, constant number of machine instructions**. The key is their constant-time nature relative to $n$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_fundamentals_1_q7_partA",
          "questionText": "In the study of algorithms, what type of computational problem is characterized by requiring a 'yes' or 'no' answer?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt1",
              "optionText": "**Decision Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt2",
              "optionText": "**Search Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt3",
              "optionText": "**Optimization Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt4",
              "optionText": "**Enumeration Problems** (listing all solutions)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt5",
              "optionText": "**Counting Problems** (determining the number of solutions)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt6",
              "optionText": "**Functional Problems** (computing an output function)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt7",
              "optionText": "**Debugging Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt8",
              "optionText": "**User Interface Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt9",
              "optionText": "**Sorting Problems** (a specific type of functional or search problem)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partA_opt10",
              "optionText": "**Implementation Problems**"
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q7_partA_opt1"],
          "explanationText": "**Decision Problems** are a fundamental type of computational problem that specifically require a 'yes' or 'no' answer. For example, 'Does a path exist between two nodes in this graph?' is a decision problem. Search problems aim to find a solution if one exists, and optimization problems aim to find the best solution.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_fundamentals_1_q7_partB",
          "questionText": "Which category of computational problems primarily involves finding a solution that meets certain criteria, if such a solution exists?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt1",
              "optionText": "**Decision Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt2",
              "optionText": "**Search Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt3",
              "optionText": "**Optimization Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt4",
              "optionText": "**Verification Problems** (a type of decision problem)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt5",
              "optionText": "**Philosophical Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt6",
              "optionText": "**Hardware Design Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt7",
              "optionText": "**Network Routing Problems** (can be search or optimization)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt8",
              "optionText": "**Ranking Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt9",
              "optionText": "**Data Storage Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partB_opt10",
              "optionText": "**Resource Allocation Problems** (often optimization)"
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q7_partB_opt2"],
          "explanationText": "**Search Problems** are primarily concerned with finding a solution that satisfies certain criteria, if one exists. For example, 'Find a path from node A to node B'. This differs from decision problems (yes/no) and optimization problems (find the best solution).",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_fundamentals_1_q7_partC",
          "questionText": "What class of computational problems focuses on finding the 'best' solution from all possible solutions, according to a specific objective function?",
          "options": [
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt1",
              "optionText": "**Decision Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt2",
              "optionText": "**Search Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt3",
              "optionText": "**Optimization Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt4",
              "optionText": "**Approximation Problems** (finding near-optimal solutions)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt5",
              "optionText": "**Compilation Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt6",
              "optionText": "**Theoretical Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt7",
              "optionText": "**Satisfiability Problems** (a type of decision or search problem)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt8",
              "optionText": "**Constraint Satisfaction Problems** (often search or optimization)"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt9",
              "optionText": "**Pattern Recognition Problems**"
            },
            {
              "optionId": "ch_fundamentals_1_q7_partC_opt10",
              "optionText": "**Game Theory Problems**"
            }
          ],
          "correctOptionIds": ["ch_fundamentals_1_q7_partC_opt3"],
          "explanationText": "**Optimization Problems** focus on finding the best solution among all possible solutions, according to some objective function (e.g., finding the shortest path, the maximum flow, or the minimum cost). This distinguishes them from decision problems (yes/no) and search problems (find any valid solution).",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 13,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_iterative_bigo_2",
      "name": "Chapter 2: Iterative Algorithms & Big O Notation",
      "description": "Covers loop invariants, loop control variables, detailed analysis of iterative algorithms, and the application of Big O notation for polynomial complexities.",
      "questions": [
        {
          "questionId": "ch_iterative_bigo_2_q1",
          "questionText": "Consider an algorithm with a time complexity function $f(n) = 5n^3 + 100n^2 + 500n + 2000$. What is its Big O complexity?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q1_opt1",
              "optionText": "$O(n^3)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt2",
              "optionText": "$O(5n^3)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt3",
              "optionText": "$O(n^2)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt4",
              "optionText": "$O(n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt5",
              "optionText": "$O(1)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt6",
              "optionText": "$O(n^3 + n^2 + n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt7",
              "optionText": "$O(2000)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt8",
              "optionText": "Its complexity is determined by the dominant term, which is $n^3$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt9",
              "optionText": "Constant factors like 5 are ignored in Big O notation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q1_opt10",
              "optionText": "$O(n^3 \\log n)$"
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q1_opt1"],
          "explanationText": "In Big O notation, we are interested in the asymptotic upper bound. For the function $f(n) = 5n^3 + 100n^2 + 500n + 2000$, we identify the **dominant term** (the term that grows fastest as $n$ becomes large), which is $5n^3$. Then, we **ignore constant factors** (like the 5) and lower-order terms ($100n^2, 500n, 2000$). Therefore, the Big O complexity is $O(n^3)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q9",
          "questionText": "What is the _most fundamental definition_ of an algorithm having $O(1)$ time complexity?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q9_opt1",
              "optionText": "The algorithm takes exactly 1 second to run."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt2",
              "optionText": "The algorithm performs exactly one operation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt3",
              "optionText": "The algorithm's execution time is constant and does not depend on the input size $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt4",
              "optionText": "The algorithm is extremely fast for all inputs."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt5",
              "optionText": "The algorithm does not involve any loops that depend on $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt6",
              "optionText": "The number of operations is primarily characterized by a fixed upper limit, irrespective of $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt7",
              "optionText": "The algorithm only works for inputs of size 1."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt8",
              "optionText": "It's the most efficient complexity class possible."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt9",
              "optionText": "Accessing an element in an array by its index is an example of an $O(1)$ operation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt10",
              "optionText": "The algorithm uses constant extra space."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q9_opt3"],
          "explanationText": "The most fundamental definition of $O(1)$ (constant time) complexity is that **the algorithm's execution time is constant and does not depend on the input size $n$**. This implies that the number of operations performed by the algorithm is bounded above by some constant $C$, regardless of the value of $n$. While 'The number of operations is primarily characterized by a fixed upper limit, irrespective of $n$.' is a consequence and accurate description, the definition focuses on the execution time's independence from input size. Accessing an array element by its index is a classic example of an $O(1)$ operation.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q3",
          "questionText": "Consider the algorithm to find the largest element in an array `a` of size `n`:\n```pseudocode\nmax ← a[0]\ni ← 1\nWHILE i < n\n  IF a[i] > max THEN\n    max ← a[i]\n  i ← i + 1\nRETURN max\n```\nFor this algorithm, which statement _best describes the primary loop invariant concerning the variable `max`_ just before the loop condition `i < n` is checked (assuming `1 ≤ i ≤ n`, where `i=n` represents the state just after the loop terminates)?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q3_opt1",
              "optionText": "`max` is the largest element in `a[0...n-1]`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt2",
              "optionText": "`max` is the largest element in `a[0...i-1]`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt3",
              "optionText": "`max` is equal to `a[i-1]`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt4",
              "optionText": "`i` is always less than `n`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt5",
              "optionText": "`max` contains the element `a[0]`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt6",
              "optionText": "All elements in `a[0...i-1]` have been compared with `max`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt7",
              "optionText": "`max` is greater than or equal to all elements in `a[0...i-1]`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt8",
              "optionText": "`i` represents the index of the next element to be considered for comparison against `max`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt9",
              "optionText": "The array `a` is sorted up to index `i-1`."
            },
            {
              "optionId": "ch_iterative_bigo_2_q3_opt10",
              "optionText": "`max` is the smallest element in `a[0...i-1]`."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q3_opt2"],
          "explanationText": "A crucial loop invariant for this algorithm, concerning the variable `max`, is that _**max is the largest element in the subarray `a[0...i-1]`**_. This property is established before the loop (when `i=1`, `max = a[0]`, so it's true for `a[0...0]`). Each iteration maintains this: if `a[i]` (the current element being considered) is larger than `max`, `max` is updated to `a[i]`; otherwise, `max` (which was largest in `a[0...i-1]`) remains the largest. After `a[i]` is processed and `i` is incremented, `max` holds the largest value in `a[0...(new i)-1]`. Another invariant concerns the loop counter `i`, which represents the index of the next element to be considered. Upon termination (when `i=n`), the invariant regarding `max` implies that `max` is the largest element in the entire array `a[0...n-1]`.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q4",
          "questionText": "What is the Big O time complexity of an algorithm that has a single loop iterating $n$ times, and inside the loop, it performs a constant number of operations (e.g., 3 assignments and 2 comparisons)?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q4_opt1",
              "optionText": "$O(1)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt2",
              "optionText": "$O(\\log n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt3",
              "optionText": "$O(n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt4",
              "optionText": "$O(n \\log n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt5",
              "optionText": "$O(n^2)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt6",
              "optionText": "$O(5n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt7",
              "optionText": "The number of operations inside the loop ($c$) is summed across iterations."
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt8",
              "optionText": "The total number of operations is roughly $c + n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt9",
              "optionText": "$O(c \\cdot n)$, which implies the algorithm's runtime is exactly $c$ times $n$ operations."
            },
            {
              "optionId": "ch_iterative_bigo_2_q4_opt10",
              "optionText": "$O(n^c)$"
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q4_opt3"],
          "explanationText": "If a loop iterates $n$ times, and inside each iteration, a constant number of operations, say $c$ (e.g., $3+2=5$ operations), are performed, then the total number of operations is $c \\times n$. In Big O notation, constant factors are ignored. Thus, the time complexity is **$O(n)$**, which is linear time complexity. While $O(5n)$ or $O(c \\cdot n)$ describe the number of operations before simplification, $O(n)$ is the standard Big O representation. Big O describes an asymptotic upper bound, not an exact count.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q5",
          "questionText": "An algorithm consists of two independent (non-nested) loops. The first loop runs $n$ times, and the second loop also runs $n$ times (each performing constant work per iteration). What is the overall Big O time complexity?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q5_opt1",
              "optionText": "$O(n^2)$ because there are two loops."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt2",
              "optionText": "$O(n)$ because the loops are sequential, not nested."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt3",
              "optionText": "$O(2n)$ which simplifies to $O(n)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt4",
              "optionText": "$O(\\log n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt5",
              "optionText": "$O(n + n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt6",
              "optionText": "It depends on what operations are inside the loops."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt7",
              "optionText": "$O(n \\times n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt8",
              "optionText": "The complexities are added: $O(n) + O(n) = O(n)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt9",
              "optionText": "$O(\\max(n, n)) = O(n)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q5_opt10",
              "optionText": "$O(n!)$"
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q5_opt3"],
          "explanationText": "When an algorithm consists of two independent, sequential loops, and each runs $n$ times (performing constant work per iteration), their individual complexities are $O(n)$. For sequential blocks of code, their complexities are added. Thus, the total time is $O(n) + O(n) = O(n+n)$, which is $O(2n)$. In Big O notation, constant factors are ignored, so this simplifies to **$O(n)$**. Therefore, the statement '$O(2n)$ which simplifies to $O(n)$' best describes this calculation and result. The fact that the loops are sequential, not nested, is key to this addition rule.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q6",
          "questionText": "What is the Big O time complexity of an algorithm with nested loops where the outer loop runs $n$ times and the inner loop runs $m$ times for each iteration of the outer loop (assuming constant work inside the inner loop)?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q6_opt1",
              "optionText": "$O(n+m)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt2",
              "optionText": "$O(n \\times m)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt3",
              "optionText": "$O(n)$ if $n > m$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt4",
              "optionText": "$O(m)$ if $m > n$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt5",
              "optionText": "$O(n^2)$ if $n=m$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt6",
              "optionText": "$O(\\max(n,m))$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt7",
              "optionText": "The inner loop operations are performed $n \\times m$ times."
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt8",
              "optionText": "$O(n \\log m)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt9",
              "optionText": "$O(m \\log n)$"
            },
            {
              "optionId": "ch_iterative_bigo_2_q6_opt10",
              "optionText": "$O(n^m)$"
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q6_opt2"],
          "explanationText": "For nested loops, the number of times the inner loop's body executes is the product of the number of iterations of the outer loop and the number of iterations of the inner loop (per outer iteration). So, if the outer loop runs $n$ times and for each of those iterations, the inner loop runs $m$ times, the total operations performed by the inner loop's body will be proportional to $n \\times m$. Thus, the Big O complexity is **$O(n \\times m)$**. If $n$ and $m$ are the same (i.e., $n=m$), this complexity becomes $O(n \\times n) = O(n^2)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q7",
          "questionText": "A loop control variable is central to managing loop execution. Which of its characteristics is _most directly involved in the decision to continue or terminate_ the loop's iterations?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q7_opt1",
              "optionText": "It is initialized before the loop starts."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt2",
              "optionText": "It is used in the test condition that determines whether the loop continues or terminates."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt3",
              "optionText": "It is modified (e.g., incremented or decremented) inside the body of the loop."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt4",
              "optionText": "Its value must always be an integer."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt5",
              "optionText": "It is used to directly access array elements."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt6",
              "optionText": "There can only be one loop control variable per loop."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt7",
              "optionText": "Its modification ensures progress towards the loop's termination condition."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt8",
              "optionText": "It cannot be modified by any nested loops."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt9",
              "optionText": "It is declared as a constant (`final` in Java)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q7_opt10",
              "optionText": "It is only used in `for` loops, not `while` loops."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q7_opt2"],
          "explanationText": "While a loop control variable must be initialized before the loop (Initialization) and modified within its body to ensure progress (Modification), its characteristic of being **used in the test condition that determines whether the loop continues or terminates** (Test) is most directly involved in the decision-making process of loop execution at each step. These three aspects (Initialize, Test, Modify) together define its fundamental structural role in controlling the loop.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q8",
          "questionText": "If an algorithm has a worst-case time complexity of $O(n^2)$ and another algorithm for the same problem has $O(n^3)$, what is the _most significant difference in their long-term performance characteristics_ as $n$ becomes very large?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q8_opt1",
              "optionText": "The $O(n^2)$ algorithm will always be faster than the $O(n^3)$ algorithm for any $n > 0$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt2",
              "optionText": "The $O(n^2)$ algorithm is asymptotically faster than the $O(n^3)$ algorithm."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt3",
              "optionText": "For small values of $n$, the $O(n^3)$ algorithm might be faster due to smaller constant factors or simpler operations in its implementation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt4",
              "optionText": "The $O(n^3)$ algorithm will eventually (for large enough $n$) take significantly more time than the $O(n^2)$ algorithm."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt5",
              "optionText": "The growth rate of the $O(n^2)$ algorithm is lower than that of the $O(n^3)$ algorithm."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt6",
              "optionText": "Both algorithms are considered polynomial time, which is generally categorized as tractable."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt7",
              "optionText": "The $O(n^2)$ algorithm is always preferred, regardless of $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt8",
              "optionText": "The difference in their actual run times will be exactly a factor of $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt9",
              "optionText": "It's impossible to compare them without knowing the exact constant factors."
            },
            {
              "optionId": "ch_iterative_bigo_2_q8_opt10",
              "optionText": "If $n=10$, the $O(n^2)$ algorithm takes 100 steps and the $O(n^3)$ algorithm takes 1000 steps, ignoring constants."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q8_opt2"],
          "explanationText": "The most significant difference for large $n$ is that **the $O(n^2)$ algorithm is asymptotically faster than the $O(n^3)$ algorithm**; its running time grows at a slower rate. This means that as $n$ becomes very large, the $O(n^2)$ algorithm will eventually outperform the $O(n^3)$ algorithm, regardless of constant factors. It's important to note that for small values of $n$, the $O(n^3)$ algorithm could be faster if its constant factors or the cost of its elementary operations are significantly smaller. Both $O(n^2)$ and $O(n^3)$ complexities represent polynomial time, which is generally considered tractable.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q9",
          "questionText": "What is the _most fundamental definition_ of an algorithm having $O(1)$ time complexity?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q9_opt1",
              "optionText": "The algorithm takes exactly 1 second to run."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt2",
              "optionText": "The algorithm performs exactly one operation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt3",
              "optionText": "The algorithm's execution time is constant and does not depend on the input size $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt4",
              "optionText": "The algorithm is extremely fast for all inputs."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt5",
              "optionText": "The algorithm does not involve any loops that depend on $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt6",
              "optionText": "The number of operations is primarily characterized by a fixed upper limit, irrespective of $n$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt7",
              "optionText": "The algorithm only works for inputs of size 1."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt8",
              "optionText": "It's the most efficient complexity class possible."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt9",
              "optionText": "Accessing an element in an array by its index is an example of an $O(1)$ operation."
            },
            {
              "optionId": "ch_iterative_bigo_2_q9_opt10",
              "optionText": "The algorithm uses constant extra space."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q9_opt3"],
          "explanationText": "The most fundamental definition of $O(1)$ (constant time) complexity is that **the algorithm's execution time is constant and does not depend on the input size $n$**. This implies that the number of operations performed by the algorithm is bounded above by some constant $C$, regardless of the value of $n$. While 'The number of operations is primarily characterized by a fixed upper limit, irrespective of $n$.' is a consequence and accurate description, the definition focuses on the execution time's independence from input size. Accessing an array element by its index is a classic example of an $O(1)$ operation.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q10",
          "questionText": "Which statement _best defines the primary purpose_ of Big O notation in algorithm analysis?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q10_opt1",
              "optionText": "An algorithm with complexity $O(n)$ has a faster rate of growth than an algorithm with $O(n^2)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt2",
              "optionText": "An algorithm with complexity $O(n^2)$ has a faster rate of growth than an algorithm with $O(n)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt3",
              "optionText": "Big O notation provides an exact count of operations."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt4",
              "optionText": "Big O notation describes the asymptotic upper bound of an algorithm's growth rate."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt5",
              "optionText": "Constant factors are significant in Big O notation (e.g., $O(2n)$ is different from $O(n)$)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt6",
              "optionText": "Lower-order terms are significant in Big O notation (e.g., $O(n^2 + n)$ is different from $O(n^2)$)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt7",
              "optionText": "If $f(n) = O(g(n))$, then $g(n)$ grows at least as fast as $f(n)$ for large $n$ (up to a constant factor)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt8",
              "optionText": "$100n + 500 = O(n)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt9",
              "optionText": "$n^2 / 2 + n/2 = O(n^2)$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q10_opt10",
              "optionText": "Big O notation is only used for time complexity, not space complexity."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q10_opt4"],
          "explanationText": "The primary purpose of Big O notation is that it **describes the asymptotic upper bound of an algorithm's growth rate** as the input size $n$ tends towards infinity. This means if an algorithm's resource usage (time or space) is $f(n)$, and we say $f(n) = O(g(n))$, then $g(n)$ serves as an upper bound for $f(n)$ for sufficiently large $n$, implying $g(n)$ grows at least as fast as $f(n)$ (ignoring constant factors and lower-order terms). For example, a function $100n + 500$ is $O(n)$, and $n^2/2 + n/2$ is $O(n^2)$. Big O notation is used for both time and space complexity. An algorithm with $O(n)$ complexity has a _slower_ (more desirable) rate of growth of its complexity function than one with $O(n^2)$ complexity (where $n^2$ grows faster than $n$).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q11",
          "questionText": "Consider the sequential search algorithm for an array of $n$ elements. In the **average case** (assuming the element is present and equally likely to be at any position), approximately how many comparisons are typically performed?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q11_opt1",
              "optionText": "1 comparison."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt2",
              "optionText": "$n$ comparisons."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt3",
              "optionText": "$n/2$ comparisons (approximately)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt4",
              "optionText": "$O(\\log n)$ comparisons."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt5",
              "optionText": "$n^2$ comparisons."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt6",
              "optionText": "The number of comparisons is $(1+2+...+n)/n = (n(n+1)/2)/n = (n+1)/2$."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt7",
              "optionText": "The complexity is still $O(n)$ in the average case."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt8",
              "optionText": "It is always the same as the worst case."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt9",
              "optionText": "It is the same as the best case if the element is found at the first position."
            },
            {
              "optionId": "ch_iterative_bigo_2_q11_opt10",
              "optionText": "It depends on whether the array is sorted or not."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q11_opt3"],
          "explanationText": "For sequential search in the average case (assuming the element is present and equally likely to be at any position), the number of comparisons is approximately **$n/2$**. This is derived by summing the number of comparisons needed if the element is at the first position (1), second (2), ..., up to the $n$-th position ($n$), and then dividing by $n$. This sum is $(1+2+...+n) = n(n+1)/2$. So the average is $(n(n+1)/2)/n = (n+1)/2$, which is close to $n/2$ for large $n$. In Big O notation, this average-case performance is still $O(n)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_iterative_bigo_2_q12",
          "questionText": "What is the primary purpose of using a loop control variable in conjunction with a loop termination condition in an iterative algorithm?",
          "options": [
            {
              "optionId": "ch_iterative_bigo_2_q12_opt1",
              "optionText": "To ensure the loop performs a fixed number of iterations, known at compile time."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt2",
              "optionText": "To ensure the loop eventually terminates and avoids an infinite loop."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt3",
              "optionText": "To make the loop run as fast as possible."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt4",
              "optionText": "To make the loop invariant easier to prove."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt5",
              "optionText": "To provide a way to count the number of operations for complexity analysis."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt6",
              "optionText": "To allow the loop to process each element of a data structure (like an array)."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt7",
              "optionText": "The loop control variable is modified within the loop body to make progress towards making the termination condition false."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt8",
              "optionText": "The termination condition is checked before each iteration."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt9",
              "optionText": "To define the scope of variables used within the loop."
            },
            {
              "optionId": "ch_iterative_bigo_2_q12_opt10",
              "optionText": "To allow for early exit from the loop using a `break` statement."
            }
          ],
          "correctOptionIds": ["ch_iterative_bigo_2_q12_opt2"],
          "explanationText": "The primary purpose of using a loop control variable in conjunction with a loop termination condition is **to ensure the loop eventually terminates and avoids an infinite loop**. This is achieved by systematically modifying the loop control variable within the loop body, thereby making progress towards a state where the termination condition (which is typically checked before each iteration in `WHILE` or `FOR` loops) becomes false, causing the loop to exit. While it often facilitates processing data structures or aids in complexity analysis, its fundamental role is controlling the loop's finite execution.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 12,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_simple_sorting_3",
      "name": "Chapter 3: Simple Sorting Algorithms",
      "description": "Explores Selection Sort and Insertion Sort, including their mechanisms, tracing, complexity, stability, and adaptivity.",
      "questions": [
        {
          "questionId": "ch_simple_sorting_3_q1",
          "questionText": "Which statement _best summarises the core operational mechanic_ of the **Selection Sort** algorithm?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q1_opt1",
              "optionText": "In each pass, it finds the smallest element in the unsorted portion and swaps it with the first element of the unsorted portion."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt2",
              "optionText": "It builds the sorted array one element at a time by inserting the current element into its correct position in the already sorted part."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt3",
              "optionText": "It has a time complexity of $O(n \\log n)$ in the average case."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt4",
              "optionText": "It has a time complexity of $O(n^2)$ in the worst, average, and best cases."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt5",
              "optionText": "It is a stable sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt6",
              "optionText": "It is not a stable sorting algorithm because swaps can change the relative order of equal elements."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt7",
              "optionText": "It is an adaptive sorting algorithm (performs better on partially sorted data)."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt8",
              "optionText": "It is not an adaptive sorting algorithm; the number of comparisons is always the same regardless of initial order."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt9",
              "optionText": "It requires $O(n)$ auxiliary space."
            },
            {
              "optionId": "ch_simple_sorting_3_q1_opt10",
              "optionText": "It requires $O(1)$ auxiliary space (in-place sort)."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q1_opt1"],
          "explanationText": "The core operational mechanic of Selection Sort is that **in each pass, it finds the smallest (or largest, depending on sort order) element in the remaining unsorted portion of the array and swaps it with the element at the beginning of that unsorted portion**. This process is repeated for the subsequent smaller unsorted portions until the entire array is sorted. Its time complexity is consistently $O(n^2)$ in all cases (worst, average, and best) because it always makes roughly $n^2/2$ comparisons. It is not a stable sort due to the long-range swaps, but it is an in-place sort requiring $O(1)$ auxiliary space.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q2",
          "questionText": "Which statement _best describes the fundamental operation_ of the **Insertion Sort** algorithm?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q2_opt1",
              "optionText": "In each pass, it finds the smallest element in the unsorted portion and swaps it with the first element of the unsorted portion."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt2",
              "optionText": "It builds the sorted array one element at a time by taking the current element from the unsorted part and inserting it into its correct position within the already sorted part."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt3",
              "optionText": "It has a time complexity of $O(n^2)$ in the worst case (e.g., reverse sorted array)."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt4",
              "optionText": "It has a time complexity of $O(n)$ in the best case (e.g., already sorted array)."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt5",
              "optionText": "It is a stable sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt6",
              "optionText": "It is not a stable sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt7",
              "optionText": "It is an adaptive sorting algorithm (performs better on partially sorted data)."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt8",
              "optionText": "It is not an adaptive sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt9",
              "optionText": "It requires $O(n)$ auxiliary space for the insertions."
            },
            {
              "optionId": "ch_simple_sorting_3_q2_opt10",
              "optionText": "It requires $O(1)$ auxiliary space (in-place sort)."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q2_opt2"],
          "explanationText": "The fundamental operation of Insertion Sort is that **it builds the sorted array one element at a time by taking the current element from the unsorted part and inserting it into its correct position within the already sorted part** by shifting larger elements to the right. This algorithm is stable (preserves relative order of equal elements), adaptive (performs efficiently on nearly sorted data with $O(n)$ best-case complexity), and in-place (requires $O(1)$ auxiliary space). Its worst-case time complexity is $O(n^2)$ (e.g., for a reverse-sorted array).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q3",
          "questionText": "When tracing Selection Sort on the array `[27, 14, 77, 34]`, what is the state of the array after the **first pass** (i.e., after the first smallest element is placed in its correct position)?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q3_opt1",
              "optionText": "`[27, 14, 77, 34]` (no change)"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt2",
              "optionText": "`[14, 27, 77, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt3",
              "optionText": "`[14, 77, 27, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt4",
              "optionText": "`[14, 34, 77, 27]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt5",
              "optionText": "`[27, 14, 34, 77]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt6",
              "optionText": "The smallest element is 14 at index 1."
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt7",
              "optionText": "14 is swapped with the element at index 0 (which is 27)."
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt8",
              "optionText": "`[34, 14, 77, 27]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt9",
              "optionText": "`[77, 14, 27, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q3_opt10",
              "optionText": "`[14, 27, 34, 77]` (fully sorted)"
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q3_opt2"],
          "explanationText": "Original array: `[27, 14, 77, 34]`.<br>**First pass (i=0):**<br>1. Find the smallest element in `a[0...3]`. The smallest is 14, located at index 1.<br>2. Swap `a[0]` (which is 27) with `a[1]` (which is 14).<br>The array becomes **`[14, 27, 77, 34]`**. This is the state after the first pass.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q4",
          "questionText": "When tracing Insertion Sort on the array `[27, 14, 77, 34]`, what is the _state of the array after the element `14` (originally at index 1) has been processed and inserted_ into its correct position in the sorted portion?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q4_opt1",
              "optionText": "`[27, 14, 77, 34]` (no change yet as 14 is the first element to be inserted)"
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt2",
              "optionText": "`[14, 27, 77, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt3",
              "optionText": "The element `a[0]=27` is considered sorted initially."
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt4",
              "optionText": "The element `14` is compared with `27`. Since `14 < 27`, `27` is shifted right."
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt5",
              "optionText": "`14` is placed at index 0."
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt6",
              "optionText": "`[27, 77, 14, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt7",
              "optionText": "`[14, 77, 27, 34]`"
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt8",
              "optionText": "This occurs during the pass when `i=1`."
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt9",
              "optionText": "`[14, 27, 34, 77]` (fully sorted)"
            },
            {
              "optionId": "ch_simple_sorting_3_q4_opt10",
              "optionText": "`[27, 14, 34, 77]`"
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q4_opt2"],
          "explanationText": "Original array: `[27, 14, 77, 34]`. Insertion Sort considers `a[0]=27` as initially sorted. The pass to insert `a[1]=14` (which occurs when the outer loop index, say `i`, is 1) involves taking `14` and comparing it with elements in the sorted portion `[27]`. Since `14 < 27`, `27` is shifted to the right (to index 1), and `14` is placed at index 0. So, after `14` is inserted, **the array becomes `[14, 27, 77, 34]`**.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q5",
          "questionText": "What does it _most fundamentally mean_ for a sorting algorithm to be **stable**?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q5_opt1",
              "optionText": "It always produces the same sorted output for a given input, even if run multiple times."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt2",
              "optionText": "It maintains the relative order of records with equal sort keys."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt3",
              "optionText": "Its time complexity is the same for all types of input (worst, average, best)."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt4",
              "optionText": "It does not crash or enter an infinite loop for any input."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt5",
              "optionText": "It uses a stable amount of memory, i.e., $O(1)$ space complexity."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt6",
              "optionText": "If two elements `x` and `y` have the same key, and `x` appears before `y` in the input, then `x` will appear before `y` in the output."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt7",
              "optionText": "It can sort data that is constantly changing."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt8",
              "optionText": "It is not affected by the initial order of the elements."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt9",
              "optionText": "It is suitable for sorting data stored on stable storage like hard disks."
            },
            {
              "optionId": "ch_simple_sorting_3_q5_opt10",
              "optionText": "It is guaranteed to terminate."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q5_opt2"],
          "explanationText": "The most fundamental meaning of a stable sorting algorithm is that **it maintains the relative order of records with equal sort keys**. This means if two elements have the same value (key) used for sorting, and one appears before the other in the original input array, it will also appear before the other in the sorted output array. The statement 'If two elements x and y have the same key, and x appears before y in the input, then x will appear before y in the output' is a more formal way of expressing this same core concept. Other options describe properties like determinism (always same output), performance consistency, or general algorithm correctness, which are distinct from stability.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q6",
          "questionText": "What does it _most accurately mean_ for a sorting algorithm to be **adaptive**?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q6_opt1",
              "optionText": "It can adapt to different data types (integers, strings, objects)."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt2",
              "optionText": "Its performance improves (e.g., runs faster) if the input data is already partially sorted."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt3",
              "optionText": "It adapts its memory usage based on the input size."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt4",
              "optionText": "It automatically chooses the best pivot element in algorithms like Quicksort."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt5",
              "optionText": "It uses adaptive data structures internally."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt6",
              "optionText": "If the input is already sorted, an adaptive algorithm might achieve its best-case time complexity, which is better than its average or worst-case."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt7",
              "optionText": "It requires the user to adapt the algorithm's parameters for optimal performance."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt8",
              "optionText": "It is always an in-place sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt9",
              "optionText": "Its stability adapts based on the input data."
            },
            {
              "optionId": "ch_simple_sorting_3_q6_opt10",
              "optionText": "Insertion sort is an example of an adaptive algorithm."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q6_opt2"],
          "explanationText": "An **adaptive** sorting algorithm is one whose **performance (typically run time) improves if the input data is already partially sorted or exhibits some existing order**. A key consequence is that if the input is already sorted, such an algorithm might achieve its best-case time complexity, which is often better than its average or worst-case complexity (e.g., Insertion Sort achieves $O(n)$ on sorted data). Insertion Sort is a well-known example of an adaptive algorithm. Selection Sort is not adaptive as its performance remains $O(n^2)$ regardless of input order.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q7",
          "questionText": "Which statement _most accurately characterizes the number of comparisons_ performed by Selection Sort on an array of $n$ elements?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q7_opt1",
              "optionText": "$O(n)$"
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt2",
              "optionText": "$O(n \\log n)$"
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt3",
              "optionText": "$O(n^2)$"
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt4",
              "optionText": "Exactly $n-1$ comparisons."
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt5",
              "optionText": "Exactly $n(n-1)/2$ comparisons."
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt6",
              "optionText": "The number of comparisons is $(n-1) + (n-2) + ... + 1$."
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt7",
              "optionText": "It depends on the initial order of the array."
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt8",
              "optionText": "$O(1)$"
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt9",
              "optionText": "The number of comparisons is the same in the best, average, and worst cases."
            },
            {
              "optionId": "ch_simple_sorting_3_q7_opt10",
              "optionText": "$O(n!)$"
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q7_opt5"],
          "explanationText": "Selection Sort performs **exactly $n(n-1)/2$ comparisons** on an array of $n$ elements. This is because in the first pass it makes $n-1$ comparisons to find the minimum, in the second pass $n-2$ comparisons, and so on, until the last pass makes 1 comparison. The sum $(n-1) + (n-2) + ... + 1$ equals $n(n-1)/2$. Consequently, the number of comparisons is always the same regardless of the input data's initial order (best, average, and worst cases are identical in terms of comparisons), and its time complexity is $O(n^2)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q8",
          "questionText": "What is the best-case time complexity for Insertion Sort, and what type of input _primarily_ triggers this best case?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q8_opt1",
              "optionText": "$O(n^2)$, for a reverse-sorted array."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt2",
              "optionText": "$O(n)$, for an already sorted array."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt3",
              "optionText": "$O(n \\log n)$, for a randomly ordered array."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt4",
              "optionText": "$O(1)$, if the array has only one element."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt5",
              "optionText": "$O(n^2)$, for an already sorted array."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt6",
              "optionText": "$O(n)$, for a reverse-sorted array."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt7",
              "optionText": "When the input array is already sorted, each element only needs to be compared with the last element of the sorted portion (and no shifts occur)."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt8",
              "optionText": "In the best case, the inner loop (shifting elements) executes at most once (for comparison) and performs no shifts."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt9",
              "optionText": "$O(\\log n)$, for an array with many duplicate values."
            },
            {
              "optionId": "ch_simple_sorting_3_q8_opt10",
              "optionText": "The best case also occurs when all elements are identical."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q8_opt2"],
          "explanationText": "The best-case time complexity for Insertion Sort is **$O(n)$, and this occurs when the input array is already sorted** (or nearly sorted, including when all elements are identical). In this scenario, when considering each element to insert, it only needs to be compared with the last element of the already sorted portion to confirm it's in the correct place, and no (or very few) shifts of elements are required. This results in approximately $n-1$ comparisons and no shifts, leading to linear time performance.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q9",
          "questionText": "What is the _primary reason_ why the standard Selection Sort algorithm is **not stable**?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q9_opt1",
              "optionText": "It uses too many comparisons."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt2",
              "optionText": "The inner loop always iterates through the entire unsorted portion."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt3",
              "optionText": "Elements with equal keys might be swapped over long distances, changing their original relative order."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt4",
              "optionText": "It is an in-place sorting algorithm."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt5",
              "optionText": "It is not adaptive."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt6",
              "optionText": "It only performs a limited number of swaps ($O(n)$ swaps)."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt7",
              "optionText": "If an element `X` (equal to another element `Y`) is the minimum in the unsorted part, and `Y` is currently at the swap position, `X` might be swapped past `Y` if `X` was originally after `Y`."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt8",
              "optionText": "It requires finding the absolute minimum in each pass."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt9",
              "optionText": "It is difficult to implement correctly."
            },
            {
              "optionId": "ch_simple_sorting_3_q9_opt10",
              "optionText": "Its $O(n^2)$ complexity makes it unstable for large datasets."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q9_opt3"],
          "explanationText": "Selection Sort is not stable primarily because **elements with equal keys might be swapped over long distances, potentially changing their original relative order**. When the algorithm finds the minimum element in the unsorted portion, it swaps this minimum with the element at the current first position of that unsorted portion. If the minimum element found was originally positioned after another element with the same key, this swap can move it before that other identical element, thus violating stability. For example, in `[3A, 2, 3B, 1]` (where 3A and 3B are equal but distinct items), if 3A is at index 0 and 3B is at index 2, and 1 is found as the minimum, swapping 1 with 3A changes the order. The next passes might also change the relative order of 3A and 3B.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_simple_sorting_3_q10",
          "questionText": "When implementing Selection Sort, the outer loop typically iterates from `i = 0` to `n-2` (not `n-1`). What is the _most direct reason_ this is sufficient?",
          "options": [
            {
              "optionId": "ch_simple_sorting_3_q10_opt1",
              "optionText": "To avoid an array index out of bounds error."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt2",
              "optionText": "Because the last element `a[n-1]` is always the largest by default."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt3",
              "optionText": "When the first `n-1` elements are sorted and in their correct places, the `n`-th (last) element must also be in its correct place."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt4",
              "optionText": "It's an optimization that significantly improves its Big O complexity."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt5",
              "optionText": "The inner loop handles finding the minimum for the `n-1` position."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt6",
              "optionText": "This is only true for arrays with an even number of elements."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt7",
              "optionText": "If all other $n-1$ elements are correctly placed, the final element has nowhere else to go but its correct sorted position."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt8",
              "optionText": "Stopping at `n-2` makes the algorithm stable."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt9",
              "optionText": "It's a common convention but iterating to `n-1` would also work, just with an unnecessary final pass."
            },
            {
              "optionId": "ch_simple_sorting_3_q10_opt10",
              "optionText": "The loop invariant ensures the last element is sorted by the time `i` reaches `n-2`."
            }
          ],
          "correctOptionIds": ["ch_simple_sorting_3_q10_opt3"],
          "explanationText": "The outer loop of Selection Sort iterates $n-1$ times. If it runs from `i = 0` to `n-2`, this covers $n-1$ iterations. The most direct reason this is sufficient is that **when the first $n-1$ elements have been selected and placed in their correct sorted positions, the $n$-th (and last) element must also be in its correct place**. There's no other position for it to go if the preceding $n-1$ elements are correctly sorted. Iterating the outer loop up to `n-1` would result in a final pass where the inner loop searches for the minimum in a subarray of size 1 (i.e., `a[n-1...n-1]`), which is trivial and unnecessary. This optimization saves one outer loop iteration but does not change the overall $O(n^2)$ complexity.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 10,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_exp_log_search_4",
      "name": "Chapter 4: Exponential, Logarithmic Time, and Binary Search",
      "description": "Delves into algorithms with exponential or logarithmic time complexities, with a focus on the Binary Search algorithm, its properties, and applications.",
      "questions": [
        {
          "questionId": "ch_exp_log_search_4_q1",
          "questionText": "Which statement _best describes the characteristic behavior_ of algorithms with logarithmic time complexity, such as $O(\\log n)$?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q1_opt1",
              "optionText": "Logarithmic time complexity means the algorithm's runtime increases very slowly as the input size $n$ grows."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt2",
              "optionText": "Algorithms with $O(\\log n)$ complexity typically divide the problem size by a constant factor at each step."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt3",
              "optionText": "$O(\\log n)$ grows faster than $O(n)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt4",
              "optionText": "$O(\\log n)$ grows slower than $O(1)$ (constant time)."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt5",
              "optionText": "Binary search is a classic example of an algorithm with $O(\\log n)$ time complexity."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt6",
              "optionText": "If an algorithm has $O(\\log n)$ complexity, doubling the input size $n$ roughly adds a constant amount of time to the execution."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt7",
              "optionText": "$O(n \\log n)$ grows faster than $O(\\log n)$ but slower than $O(n^2)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt8",
              "optionText": "The base of the logarithm (e.g., $\\log_2 n$, $\\log_{10} n$) significantly changes its Big O classification."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt9",
              "optionText": "$O(\\log n)$ is considered highly efficient for large datasets."
            },
            {
              "optionId": "ch_exp_log_search_4_q1_opt10",
              "optionText": "An algorithm that processes each element of a tree level by level might exhibit logarithmic behavior if the tree is balanced."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q1_opt1"],
          "explanationText": "The characteristic behavior of algorithms with $O(\\log n)$ complexity is that their **runtime increases very slowly as the input size $n$ grows**. This makes them highly efficient for large datasets. This slow growth is typically achieved because such algorithms divide the problem size by a constant factor at each step (e.g., binary search halves the search space). Consequently, doubling the input size only adds a constant amount of work. The base of the logarithm does not affect the Big O classification, as different bases only differ by a constant factor.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q2",
          "questionText": "Exponential time complexity, such as $O(2^n)$, signifies what about an algorithm's performance, _particularly for large inputs_?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q2_opt1",
              "optionText": "The algorithm is generally considered very efficient for large $n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt2",
              "optionText": "The algorithm's runtime roughly doubles with each single increment in input size $n$ (for base 2 exponential)."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt3",
              "optionText": "It is often associated with brute-force algorithms that explore all possible combinations or subsets (e.g., $2^n$ subsets)."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt4",
              "optionText": "$O(2^n)$ grows slower than $O(n!)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt5",
              "optionText": "Problems solvable in $O(2^n)$ time are generally considered intractable for anything but small $n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt6",
              "optionText": "Polynomial time algorithms, like $O(n^k)$ for a fixed $k$, are always faster than $O(2^n)$ for sufficiently large $n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt7",
              "optionText": "The Satisfiability (SAT) problem for $n$ variables has a naive brute-force solution of $O(n \\cdot 2^n)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt8",
              "optionText": "$O(k^n)$ for a constant $k > 1$ is also an exponential time complexity."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt9",
              "optionText": "Finding all subsets of a set of $n$ elements can lead to $O(2^n)$ behavior due to the number of subsets."
            },
            {
              "optionId": "ch_exp_log_search_4_q2_opt10",
              "optionText": "$O(2^n)$ is a type of polynomial time complexity."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q2_opt5"],
          "explanationText": "Exponential time complexity, such as $O(2^n)$ or $O(k^n)$ for $k>1$, signifies that **problems solvable in such time are generally considered intractable for anything but small input sizes $n$**. This is because the runtime grows extremely rapidly; for instance, with $O(2^n)$, each increment in $n$ can roughly double the runtime. Such complexities often arise from brute-force approaches that explore an exponentially large number of possibilities (e.g., all subsets of a set, all truth assignments for SAT). For large $n$, polynomial algorithms are always significantly faster.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q3",
          "questionText": "Which of the following is the _most critical precondition_ for the Binary Search algorithm to function correctly and achieve its efficiency?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q3_opt1",
              "optionText": "It compares the target key with every element in the array sequentially."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt2",
              "optionText": "It requires the input array to be sorted."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt3",
              "optionText": "In each step, it divides the search space (the portion of the array where the key might be) approximately in half."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt4",
              "optionText": "It uses a hash function to directly locate the element."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt5",
              "optionText": "It compares the target key with the middle element of the current search space."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt6",
              "optionText": "Based on the comparison, it eliminates the half of the search space where the key cannot possibly lie."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt7",
              "optionText": "Its worst-case time complexity is $O(n)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt8",
              "optionText": "It can efficiently find elements in an unsorted array."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt9",
              "optionText": "It involves swapping elements to bring the target key to the middle."
            },
            {
              "optionId": "ch_exp_log_search_4_q3_opt10",
              "optionText": "Its space complexity is $O(\\log n)$ due to recursive calls in a naive implementation."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q3_opt2"],
          "explanationText": "The most critical precondition for Binary Search is that **it requires the input array to be sorted**. This sorted property allows the algorithm to, in each step, compare the target key with the middle element of the current search space and then eliminate half of that space based on whether the target is smaller or larger than the middle element. Without a sorted array, this elimination strategy would not be valid, and binary search could not guarantee finding the element or achieve its $O(\\log n)$ efficiency.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q4",
          "questionText": "What is the _fundamental reason_ why the time complexity of Binary Search is $O(\\log n)$?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q4_opt1",
              "optionText": "Because it performs $\\log n$ comparisons in the best case."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt2",
              "optionText": "Because at each step, the size of the problem (the search interval) is reduced by approximately half."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt3",
              "optionText": "If the array has $n$ elements, after $k$ steps, the search space is roughly $n/2^k$. The search stops when $n/2^k \\approx 1$."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt4",
              "optionText": "Solving $n/2^k = 1$ for $k$ gives $2^k = n$, so $k = \\log_2 n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt5",
              "optionText": "Because it uses a logarithmic amount of extra memory."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt6",
              "optionText": "Because it only works on arrays whose size $n$ is a power of 2."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt7",
              "optionText": "It involves a loop that runs, in the worst case, a number of times proportional to $\\log n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt8",
              "optionText": "The number of comparisons in the worst case is proportional to $\\log_2 n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt9",
              "optionText": "The logarithm reflects the number of times you can halve $n$ until you reach 1."
            },
            {
              "optionId": "ch_exp_log_search_4_q4_opt10",
              "optionText": "Because it is faster than linear search which is $O(n)$."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q4_opt2"],
          "explanationText": "The fundamental reason for Binary Search's $O(\\log n)$ time complexity is that **at each step, the size of the problem (the search interval) is reduced by approximately half**. This repeated halving means that the number of steps ($k$) required to reduce the search space from $n$ elements down to 1 (or 0) is such that $n/2^k \\approx 1$, which implies $2^k \\approx n$, or $k \\approx \\log_2 n$. Thus, the number of operations is proportional to the logarithm of the input size. The best case for binary search is $O(1)$ (if the element is found at the very first middle check).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q5",
          "questionText": "Consider the array `A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]`. If you perform a Binary Search for the key `35` (which is not present), what is the _value of the last element examined_ by `A[mid]` before the search concludes that the key is not found? (Assume `mid = floor((lo+hi)/2)`, 0-based indexing).",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q5_opt1",
              "optionText": "`A[mid] = 50`"
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt2",
              "optionText": "`A[mid] = 20`"
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt3",
              "optionText": "`A[mid] = 30`"
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt4",
              "optionText": "`A[mid] = 40`"
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt5",
              "optionText": "The search examines `A[4]=50`, then `A[1]=20`, then `A[2]=30`, then `A[3]=40`."
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt6",
              "optionText": "The search concludes when `lo` becomes greater than `hi`."
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt7",
              "optionText": "The value `A[mid] = 10` is examined."
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt8",
              "optionText": "The value `A[mid] = 60` is examined."
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt9",
              "optionText": "The key 35 is found at index 2.5."
            },
            {
              "optionId": "ch_exp_log_search_4_q5_opt10",
              "optionText": "The search never examines A[2]=30."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q5_opt4"],
          "explanationText": "Tracing Binary Search for key 35 in `A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]` (indices 0-9):\n1. $lo=0, hi=9 \\rightarrow mid=(0+9)//2 = 4$. $A[4]=50$. (Since $35 < 50$, set $hi=mid-1=3$)\n2. $lo=0, hi=3 \\rightarrow mid=(0+3)//2 = 1$. $A[1]=20$. (Since $35 > 20$, set $lo=mid+1=2$)\n3. $lo=2, hi=3 \\rightarrow mid=(2+3)//2 = 2$. $A[2]=30$. (Since $35 > 30$, set $lo=mid+1=3$)\n4. $lo=3, hi=3 \\rightarrow mid=(3+3)//2 = 3$. $A[3]=40$. (Since $35 < 40$, set $hi=mid-1=2$)\nNow, $lo=3$ and $hi=2$. Since $lo > hi$, the loop terminates and the key 35 is not found. The last element examined by $A[mid]$ was **$A[3]=40$**.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q6",
          "questionText": "Which of the following problems is a classic example known for often having naive brute-force solutions with $O(2^n)$ complexity due to exploring all subsets or combinations of $n$ items?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q6_opt1",
              "optionText": "Sorting an array of $n$ elements using Mergesort."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt2",
              "optionText": "The Boolean Satisfiability Problem (SAT) when considering only 2 variables."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt3",
              "optionText": "The Subset Sum Problem by checking all $2^n$ possible subsets of $n$ numbers."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt4",
              "optionText": "Searching for an element in a sorted array using Binary Search."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt5",
              "optionText": "The Traveling Salesperson Problem (TSP) by checking all $n^2$ pairs of cities."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt6",
              "optionText": "Finding the maximum element in an unsorted array."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt7",
              "optionText": "Multiplying two $n \\times n$ matrices using the standard algorithm."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt8",
              "optionText": "Generating all permutations of $n$ items (which has $O(n!)$ complexity)."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt9",
              "optionText": "The Knapsack problem (0-1 variant) by using dynamic programming."
            },
            {
              "optionId": "ch_exp_log_search_4_q6_opt10",
              "optionText": "Calculating $n$-th Fibonacci number using iteration."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q6_opt3"],
          "explanationText": "The **Subset Sum Problem** is a classic example where a naive brute-force solution involves checking all $2^n$ possible subsets of $n$ numbers, leading to an $O(2^n)$ time complexity. Other problems like SAT and the 0-1 Knapsack problem also have similar naive exponential solutions due to exploring all combinations. Mergesort, Binary Search, finding max, and standard matrix multiplication have polynomial complexities. Naive TSP is $O(n!)$, and dynamic programming or iterative Fibonacci are more efficient than brute-force exponential approaches for those specific problems.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q7",
          "questionText": "If an algorithm has $O(n)$ time complexity and another has $O(\\log n)$ complexity, what is the approximate number of operations the $O(\\log n)$ algorithm would perform if $n = 1,000,000$ (assuming $\\log$ is base 2 and ignoring constant factors)?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q7_opt1",
              "optionText": "Operations proportional to 1,000,000."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt2",
              "optionText": "Operations proportional to $\\log_2(1,000,000) \\approx 20$."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt3",
              "optionText": "The $O(\\log n)$ algorithm will be significantly faster."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt4",
              "optionText": "The $O(n)$ algorithm will be slightly faster due to simpler logic."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt5",
              "optionText": "Their performance will be roughly comparable for this input size."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt6",
              "optionText": "The difference in the order of magnitude of operations is approximately $1,000,000$ versus $20$ (ignoring constant factors)."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt7",
              "optionText": "The $O(\\log n)$ algorithm is roughly 50,000 times faster ($1,000,000 / 20$) in terms of operation counts."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt8",
              "optionText": "The actual time difference depends heavily on the constant factors hidden by Big O."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt9",
              "optionText": "$O(n)$ is linear, $O(\\log n)$ is logarithmic."
            },
            {
              "optionId": "ch_exp_log_search_4_q7_opt10",
              "optionText": "Both are considered efficient polynomial time algorithms."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q7_opt2"],
          "explanationText": "For an input size $n = 1,000,000$:<br>An $O(n)$ algorithm will perform operations proportional to 1,000,000.<br>An $O(\\log n)$ algorithm (assuming base 2 logarithm, common in computer science) will perform operations proportional to $\\log_2(1,000,000)$. Since $2^{10} = 1024 \\approx 10^3$, then $2^{20} = (2^{10})^2 \\approx (10^3)^2 = 10^6 = 1,000,000$. So, $\\log_2(1,000,000)$ is approximately 20. Thus, the $O(\\log n)$ algorithm performs operations proportional to roughly **20**. This highlights the significant efficiency of logarithmic algorithms for large inputs compared to linear ones.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q8",
          "questionText": "A common loop invariant for iterative Binary Search includes the condition that if the `key` exists in the original array, it must currently reside within the search interval `a[lo..hi]`. What is the _primary purpose_ of maintaining this specific part of the invariant?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q8_opt1",
              "optionText": "That the array `a` remains sorted throughout the search."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt2",
              "optionText": "That the loop will always terminate in $O(\\log n)$ steps."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt3",
              "optionText": "To ensure that if the `key` is in the original array, it is always confined to the current search interval `a[lo..hi]`, preventing its accidental exclusion."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt4",
              "optionText": "That `lo` is always less than or equal to `hi` during the active search."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt5",
              "optionText": "That the `mid` point is always calculated correctly."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt6",
              "optionText": "The partial correctness of the algorithm: if the loop terminates, the outcome (key found/not found) is correct based on whether the key was in the initial valid search space."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt7",
              "optionText": "The part `a[0..lo-1] < key` confirms all elements before the current window are correctly eliminated as too small."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt8",
              "optionText": "The part `key < a[hi+1..n-1]` confirms all elements after the current window are correctly eliminated as too large."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt9",
              "optionText": "It helps in proving that the search space is correctly narrowed down in each iteration."
            },
            {
              "optionId": "ch_exp_log_search_4_q8_opt10",
              "optionText": "It guarantees that `lo` and `hi` remain valid array indices when accessing `a[mid]`."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q8_opt3"],
          "explanationText": "The primary purpose of the invariant part 'if the `key` is in the original array, it must be within the current search interval `a[lo..hi]`' is **to ensure that the target key, if present, is never accidentally discarded as the search space is narrowed**. This invariant, along with the correct narrowing of `lo` and `hi` based on comparisons, underpins the algorithm's correctness. If this invariant holds and the loop terminates (e.g., because `lo > hi` and the key wasn't found at `a[mid]`), it means the key was not in the original array. It's a core component of proving partial correctness and that the search space is correctly reduced.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q9",
          "questionText": "When comparing $O(n^k)$ (polynomial for fixed $k>0$) and $O(c^n)$ (exponential, for fixed $c>1$) complexities, which statement _most accurately describes their relationship_ for sufficiently large $n$?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q9_opt1",
              "optionText": "$O(n^k)$ always grows faster than $O(c^n)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt2",
              "optionText": "$O(c^n)$ always grows faster than $O(n^k)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt3",
              "optionText": "For small $n$, $n^k$ might be larger than $c^n$ depending on $k, c,$ and hidden constant factors."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt4",
              "optionText": "$n^{100}$ is asymptotically slower growing (i.e. more efficient for large n) than $1.01^n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt5",
              "optionText": "An algorithm with $O(c^n)$ complexity is generally preferred over one with $O(n^k)$ complexity if $k$ is very large (e.g., $k=100$)."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt6",
              "optionText": "The function $n^2$ grows slower than $2^n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt7",
              "optionText": "The function $n^{10}$ grows slower than $1.1^n$ for large $n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt8",
              "optionText": "Logarithmic factors do not change this relationship; e.g., $n^k \\log n$ is still asymptotically slower growing than $c^n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt9",
              "optionText": "Polynomial time is considered 'tractable', while exponential time is generally 'intractable' for large $n$."
            },
            {
              "optionId": "ch_exp_log_search_4_q9_opt10",
              "optionText": "$1000n^3$ is asymptotically faster growing (less efficient) than $2^{n/100}$."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q9_opt2"],
          "explanationText": "For sufficiently large $n$, **any exponential function $O(c^n)$ (where $c > 1$) will always grow faster than any polynomial function $O(n^k)$ (where $k > 0$)**. This is a fundamental result in the analysis of algorithms. This means that algorithms with polynomial complexity are asymptotically much more efficient than those with exponential complexity. Even if $k$ is very large (e.g., $n^{100}$) and $c$ is only slightly greater than 1 (e.g., $1.01^n$), the exponential function will eventually dominate. Logarithmic factors do not alter this essential relationship (e.g., $n^k \\log n$ still grows slower than $c^n$). Because of this, polynomial time is generally considered 'tractable', while exponential time is 'intractable' for large inputs.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_exp_log_search_4_q10",
          "questionText": "A variation of binary search (often called `AltBinarySearch` or 'binary search for insertion point') omits the equality test (`a[mid] == key`) inside the main loop. What is a _primary advantage_ of this variant?",
          "options": [
            {
              "optionId": "ch_exp_log_search_4_q10_opt1",
              "optionText": "It makes the algorithm significantly faster by reducing comparisons overall."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt2",
              "optionText": "The loop always runs for the maximum number of iterations ($\\approx \\log n$), even if an element matching the key could have been found earlier."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt3",
              "optionText": "Upon termination, the loop index (e.g., `lo`) directly indicates the correct insertion point for the key to maintain sorted order, regardless of whether the key was found."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt4",
              "optionText": "It cannot find the key if it is present in the array because it never checks for equality."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt5",
              "optionText": "It simplifies the loop body to typically involve only one comparison (e.g., `a[mid] < key` or `a[mid] <= key`) to decide which half to discard."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt6",
              "optionText": "The standard binary search (with an equality test) can terminate earlier if the key is found in the middle, potentially making it faster on average for successful searches when only presence is needed."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt7",
              "optionText": "This variant is particularly useful for finding the first or last occurrence of a key in an array with duplicates, or for finding the smallest element greater than the key."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt8",
              "optionText": "Its worst-case time complexity remains $O(\\log n)$."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt9",
              "optionText": "The invariant used for this variant usually ensures that the key, if present, is always between `lo` and `hi`, and the loop continues until `lo` and `hi` converge or cross."
            },
            {
              "optionId": "ch_exp_log_search_4_q10_opt10",
              "optionText": "It is more complex to implement than the standard binary search."
            }
          ],
          "correctOptionIds": ["ch_exp_log_search_4_q10_opt3"],
          "explanationText": "A primary advantage of the binary search variant that omits the equality test within the loop is that **upon termination, the loop index (often `lo` or `low`) directly indicates the correct insertion point for the key to maintain sorted order**. This is useful whether the key was originally present or not. The loop typically runs for the full $\\approx \\log n$ iterations, narrowing the search interval [lo..hi] until it identifies a single position. After the loop, a separate check can be made at `a[lo]` (if `lo` is a valid index) to see if the key is actually present. This variant is particularly useful for tasks like finding the first/last occurrence of an element or finding the position for insertion, making it more versatile than a simple presence check.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 10,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_recursion_5",
      "name": "Chapter 5: Recursive Algorithms",
      "description": "Covers the principles of recursion, base cases, recursive steps, the role of the call stack, and the divide-and-conquer strategy with examples.",
      "questions": [
        {
          "questionId": "ch_recursion_5_q1",
          "questionText": "Which essential component of a recursive algorithm defines the condition under which the algorithm ceases further recursive calls and solves a subproblem directly?",
          "options": [
            {
              "optionId": "ch_recursion_5_q1_opt1",
              "optionText": "A **base case(s)**"
            },
            {
              "optionId": "ch_recursion_5_q1_opt2",
              "optionText": "A **recursive step(s)**"
            },
            {
              "optionId": "ch_recursion_5_q1_opt3",
              "optionText": "A loop structure (e.g., `WHILE` or `FOR`)."
            },
            {
              "optionId": "ch_recursion_5_q1_opt4",
              "optionText": "The use of global variables to store state between calls."
            },
            {
              "optionId": "ch_recursion_5_q1_opt5",
              "optionText": "A mechanism for combining results from recursive calls."
            },
            {
              "optionId": "ch_recursion_5_q1_opt6",
              "optionText": "An explicit check for stack overflow."
            },
            {
              "optionId": "ch_recursion_5_q1_opt7",
              "optionText": "Memoization to store results of subproblems."
            },
            {
              "optionId": "ch_recursion_5_q1_opt8",
              "optionText": "The problem must be divisible into smaller, independent subproblems."
            },
            {
              "optionId": "ch_recursion_5_q1_opt9",
              "optionText": "At least two recursive calls in the recursive step for efficiency."
            },
            {
              "optionId": "ch_recursion_5_q1_opt10",
              "optionText": "Parameter modification to ensure progress."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q1_opt1"],
          "explanationText": "The essential component of a recursive algorithm that defines the condition for stopping further recursion and solving a subproblem directly is the **base case(s)**. Without a base case, a recursive algorithm would continue calling itself indefinitely (or until a stack overflow). The recursive step, conversely, is where the algorithm calls itself with a modified input that progresses towards a base case.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q2",
          "questionText": "Which of the following statements _best describes what is stored in an activation record (or stack frame)_ during a recursive function call?",
          "options": [
            {
              "optionId": "ch_recursion_5_q2_opt1",
              "optionText": "It stores the input array being processed by the recursive function."
            },
            {
              "optionId": "ch_recursion_5_q2_opt2",
              "optionText": "For each active function call (including recursive calls), an **activation record** (or stack frame) is pushed onto the stack."
            },
            {
              "optionId": "ch_recursion_5_q2_opt3",
              "optionText": "The activation record typically stores parameters, local variables, and the return address for that specific call."
            },
            {
              "optionId": "ch_recursion_5_q2_opt4",
              "optionText": "When a function call returns, its activation record is popped off the stack, and control returns to the caller."
            },
            {
              "optionId": "ch_recursion_5_q2_opt5",
              "optionText": "It is used to implement loops in recursive languages."
            },
            {
              "optionId": "ch_recursion_5_q2_opt6",
              "optionText": "The size of the call stack is always constant, regardless of recursion depth."
            },
            {
              "optionId": "ch_recursion_5_q2_opt7",
              "optionText": "It primarily manages heap memory allocation for recursive objects."
            },
            {
              "optionId": "ch_recursion_5_q2_opt8",
              "optionText": "A **stack overflow error** can occur if the recursion depth becomes too large, exceeding the stack's capacity."
            },
            {
              "optionId": "ch_recursion_5_q2_opt9",
              "optionText": "Tail call optimization can eliminate the need for new stack frames in some recursive calls."
            },
            {
              "optionId": "ch_recursion_5_q2_opt10",
              "optionText": "It ensures that recursive functions are always more space-efficient than iterative ones."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q2_opt3"],
          "explanationText": "During a recursive function call, an activation record (or stack frame) is created for that specific call. This record is crucial for managing the execution context of the call. The statement that **the activation record typically stores parameters, local variables, and the return address for that specific call** best describes its contents. This allows each instance of the recursive function to have its own set of variables and to know where to return control once it finishes. While it is true that an activation record is pushed onto the stack for each call (as mentioned in another option) and that stack overflow can occur (another option), the question asks what _best describes what is stored_.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q3",
          "questionText": "Consider the recursive algorithm for calculating $x^k$:<br>`Power(x, k):`<br>`  IF k \\le 0 THEN RETURN 1`<br>`  ELSE RETURN x * Power(x, k-1)`<br>What is the space complexity of this algorithm due to the call stack?",
          "options": [
            {
              "optionId": "ch_recursion_5_q3_opt1",
              "optionText": "$O(1)$, because it only uses a few variables."
            },
            {
              "optionId": "ch_recursion_5_q3_opt2",
              "optionText": "$O(k)$, because there will be approximately $k$ recursive calls on the stack in the deepest case."
            },
            {
              "optionId": "ch_recursion_5_q3_opt3",
              "optionText": "$O(\\log k)$, because the problem size is reduced logarithmically."
            },
            {
              "optionId": "ch_recursion_5_q3_opt4",
              "optionText": "$O(x^k)$, because that's the value being computed."
            },
            {
              "optionId": "ch_recursion_5_q3_opt5",
              "optionText": "$O(k^2)$, due to nested multiplications."
            },
            {
              "optionId": "ch_recursion_5_q3_opt6",
              "optionText": "Each recursive call adds one activation record to the stack."
            },
            {
              "optionId": "ch_recursion_5_q3_opt7",
              "optionText": "The maximum depth of recursion is $k$ (when $k$ reaches 0)."
            },
            {
              "optionId": "ch_recursion_5_q3_opt8",
              "optionText": "This particular recursive structure is not tail-recursive because a multiplication happens after the recursive call returns."
            },
            {
              "optionId": "ch_recursion_5_q3_opt9",
              "optionText": "The `IterativePower` version would have $O(1)$ space complexity."
            },
            {
              "optionId": "ch_recursion_5_q3_opt10",
              "optionText": "$O(k \\log x)$."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q3_opt2"],
          "explanationText": "The space complexity of this recursive `Power(x, k)` algorithm, due to the call stack, is **$O(k)$__. This is because each call to `Power(x, k-1)` makes a new recursive call, adding an activation record to the call stack. This continues until $k$ is reduced to 0. Thus, in the worst case (for $k > 0$), there will be approximately $k$ activation records on the stack simultaneously. This particular recursive structure is not tail-recursive because the multiplication `x _ ...` occurs _after_ the recursive call returns, meaning the current stack frame cannot be reused. An iterative version would typically have $O(1)$ space complexity.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q4",
          "questionText": "When tracing `FastPower(x=2, k=5)` using the algorithm:<br>`IF k = 0 THEN RETURN 1`<br>`y ← FastPower(x, k DIV 2)`<br>`IF k is even THEN RETURN y_y`<br>`ELSE RETURN y_y_x`<br>What is the _final computed result* of `FastPower(2,5)`?",
          "options": [
            {
              "optionId": "ch_recursion_5_q4_opt1",
              "optionText": "The innermost `y` is result of `FastPower(2,0)` which is 1."
            },
            {
              "optionId": "ch_recursion_5_q4_opt2",
              "optionText": "The value of `y` in the frame for `k=1` becomes 1."
            },
            {
              "optionId": "ch_recursion_5_q4_opt3",
              "optionText": "The value of `y` in the frame for `k=2` becomes 2."
            },
            {
              "optionId": "ch_recursion_5_q4_opt4",
              "optionText": "The value of `y` in the frame for `k=5` becomes 4."
            },
            {
              "optionId": "ch_recursion_5_q4_opt5",
              "optionText": "The sequence of `k` in calls is $5 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$."
            },
            {
              "optionId": "ch_recursion_5_q4_opt6",
              "optionText": "The call sequence is `FP(2,5)` then `FP(2,2)` then `FP(2,1)` then `FP(2,0)`."
            },
            {
              "optionId": "ch_recursion_5_q4_opt7",
              "optionText": "The result returned from `FP(2,2)` is $2 \\cdot 2 = 4$."
            },
            {
              "optionId": "ch_recursion_5_q4_opt8",
              "optionText": "The final result computed by `FastPower(2,5)` is 32."
            },
            {
              "optionId": "ch_recursion_5_q4_opt9",
              "optionText": "The sequence of values assigned to `y` across returning frames is $1, 2, 4$."
            },
            {
              "optionId": "ch_recursion_5_q4_opt10",
              "optionText": "The result returned from `FP(2,1)` is $1 \\cdot 1 \\cdot 2 = 2$."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q4_opt8"],
          "explanationText": "Tracing `FastPower(2, 5)`:<br>1. `FastPower(2,5)` calls `FastPower(2, 5 DIV 2)` which is `FastPower(2,2)`.<br>2. `FastPower(2,2)` calls `FastPower(2, 2 DIV 2)` which is `FastPower(2,1)`.<br>3. `FastPower(2,1)` calls `FastPower(2, 1 DIV 2)` which is `FastPower(2,0)`.<br>4. `FastPower(2,0)` is a base case and returns 1.<br>5. In `FastPower(2,1)`, `y` becomes 1. Since $k=1$ is odd, it returns $y \\cdot y \\cdot x = 1 \\cdot 1 \\cdot 2 = 2$.<br>6. In `FastPower(2,2)`, `y` becomes 2. Since $k=2$ is even, it returns $y \\cdot y = 2 \\cdot 2 = 4$.<br>7. In `FastPower(2,5)`, `y` becomes 4. Since $k=5$ is odd, it returns $y \\cdot y \\cdot x = 4 \\cdot 4 \\cdot 2 = 32$.<br>Thus, the final computed result is **32**.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q5",
          "questionText": "The **Divide-and-Conquer** strategy is a powerful algorithmic paradigm. Which of the following options _best describes the 'Divide' step_ in this strategy?",
          "options": [
            {
              "optionId": "ch_recursion_5_q5_opt1",
              "optionText": "**Divide**: Break the problem into several smaller, independent subproblems of the same type."
            },
            {
              "optionId": "ch_recursion_5_q5_opt2",
              "optionText": "**Conquer**: Solve the subproblems recursively. If subproblems are small enough, solve them directly (base case)."
            },
            {
              "optionId": "ch_recursion_5_q5_opt3",
              "optionText": "**Combine**: Combine the solutions of the subproblems to form the solution to the original problem."
            },
            {
              "optionId": "ch_recursion_5_q5_opt4",
              "optionText": "**Iterate**: Use a loop to process each subproblem sequentially."
            },
            {
              "optionId": "ch_recursion_5_q5_opt5",
              "optionText": "**Memoize**: Store the results of subproblems to avoid recomputation."
            },
            {
              "optionId": "ch_recursion_5_q5_opt6",
              "optionText": "**Greedy Choice**: Make a locally optimal choice at each step."
            },
            {
              "optionId": "ch_recursion_5_q5_opt7",
              "optionText": "Mergesort and Quicksort are classic examples of divide-and-conquer algorithms."
            },
            {
              "optionId": "ch_recursion_5_q5_opt8",
              "optionText": "The efficiency often comes from the 'divide' step being cheap and the 'combine' step also being relatively efficient."
            },
            {
              "optionId": "ch_recursion_5_q5_opt9",
              "optionText": "The subproblems must overlap significantly for this strategy to be effective."
            },
            {
              "optionId": "ch_recursion_5_q5_opt10",
              "optionText": "The 'conquer' step always involves exactly two recursive calls."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q5_opt1"],
          "explanationText": "The Divide-and-Conquer strategy consists of three general steps. The 'Divide' step involves **breaking the original problem into several smaller, ideally independent, subproblems of the same type as the original problem**. The 'Conquer' step involves solving these subproblems, usually recursively, until they become simple enough to solve directly (base case). Finally, the 'Combine' step merges the solutions of the subproblems to form the solution to the original problem. Mergesort and Quicksort are classic examples.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q6",
          "questionText": "What is the _defining characteristic_ of a **tail-recursive** call within a function?",
          "options": [
            {
              "optionId": "ch_recursion_5_q6_opt1",
              "optionText": "A recursive call that occurs as the very last operation in a function, where its result is immediately returned without further computation by the calling frame."
            },
            {
              "optionId": "ch_recursion_5_q6_opt2",
              "optionText": "A recursive function that has no base case."
            },
            {
              "optionId": "ch_recursion_5_q6_opt3",
              "optionText": "Compilers can often optimize tail-recursive calls into iterative loops, effectively reusing the current stack frame (Tail Call Optimization - TCO)."
            },
            {
              "optionId": "ch_recursion_5_q6_opt4",
              "optionText": "This optimization (TCO) can prevent stack overflow errors for deep tail recursions by avoiding new stack frame allocation for each tail call."
            },
            {
              "optionId": "ch_recursion_5_q6_opt5",
              "optionText": "All recursive functions are tail-recursive."
            },
            {
              "optionId": "ch_recursion_5_q6_opt6",
              "optionText": "The function `Power(x, k) { ... RETURN x * Power(x, k-1); }` is tail-recursive."
            },
            {
              "optionId": "ch_recursion_5_q6_opt7",
              "optionText": "A function like `factorial(n) { ... return n * factorial(n-1); }` is not tail-recursive because of the multiplication after the recursive call returns."
            },
            {
              "optionId": "ch_recursion_5_q6_opt8",
              "optionText": "Tail recursion always leads to $O(1)$ space complexity in all programming languages."
            },
            {
              "optionId": "ch_recursion_5_q6_opt9",
              "optionText": "Java compilers are required by the language specification to perform tail call optimization."
            },
            {
              "optionId": "ch_recursion_5_q6_opt10",
              "optionText": "It is a recursive call made to the 'tail' or last element of a data structure."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q6_opt1"],
          "explanationText": "A recursive call is defined as tail-recursive if **it is the very last operation performed in the function, and the result of this recursive call is immediately returned by the calling function without any further computation**. For example, `return helper(n-1, acc_n);` could be a tail call, while `return n _ factorial(n-1);` is not, because the multiplication by `n` happens _after_ `factorial(n-1)` returns. The significance of tail recursion is that compilers supporting Tail Call Optimization (TCO) can transform such calls into iterations, avoiding the creation of new stack frames and thus preventing stack overflow for deep recursions.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q7",
          "questionText": "The naive recursive Fibonacci algorithm, $F(n) = F(n-1) + F(n-2)$ (with $F(0)=0, F(1)=1$), is known for its inefficiency. What is the _primary reason_ for this inefficiency?",
          "options": [
            {
              "optionId": "ch_recursion_5_q7_opt1",
              "optionText": "$O(n)$"
            },
            {
              "optionId": "ch_recursion_5_q7_opt2",
              "optionText": "$O(n^2)$"
            },
            {
              "optionId": "ch_recursion_5_q7_opt3",
              "optionText": "$O(\\log n)$"
            },
            {
              "optionId": "ch_recursion_5_q7_opt4",
              "optionText": "Exponential, approximately $O(\\phi^n)$ where $\\phi \\approx 1.618$ (the golden ratio), often simplified to $O(2^n)$."
            },
            {
              "optionId": "ch_recursion_5_q7_opt5",
              "optionText": "Because it repeatedly recomputes the same Fibonacci numbers multiple times (overlapping subproblems)."
            },
            {
              "optionId": "ch_recursion_5_q7_opt6",
              "optionText": "The number of calls grows very rapidly, forming a tree of calls where, for example, F(n-2) is computed independently by the call for F(n) and as part of computing F(n-1)."
            },
            {
              "optionId": "ch_recursion_5_q7_opt7",
              "optionText": "$O(1)$"
            },
            {
              "optionId": "ch_recursion_5_q7_opt8",
              "optionText": "Its time complexity can be improved to $O(n)$ using iteration or memoization (dynamic programming)."
            },
            {
              "optionId": "ch_recursion_5_q7_opt9",
              "optionText": "Its space complexity due to recursion depth is $O(n)$."
            },
            {
              "optionId": "ch_recursion_5_q7_opt10",
              "optionText": "It is an efficient way to calculate Fibonacci numbers for large $n$."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q7_opt5"],
          "explanationText": "The primary reason for the inefficiency of the naive recursive Fibonacci algorithm is that **it repeatedly recomputes the same Fibonacci numbers multiple times** due to overlapping subproblems in its recursion tree. For example, to compute $F(5)$, it computes $F(4)$ and $F(3)$. Computing $F(4)$ involves computing $F(3)$ and $F(2)$. Thus, $F(3)$ is computed twice. This redundancy leads to an exponential time complexity (approximately $O(\\phi^n)$ or $O(2^n)$). This inefficiency can be overcome by using iteration or memoization (dynamic programming) to store and reuse the results of subproblems, achieving an $O(n)$ time complexity.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q8",
          "questionText": "When comparing typical recursive (`fact(n) = n _ fact(n-1)`) and iterative solutions for computing factorial $n!$, what is a _key advantage of the iterative solution* regarding resource usage?",
          "options": [
            {
              "optionId": "ch_recursion_5_q8_opt1",
              "optionText": "A standard recursive solution is: `fact(n) = IF n≤1 THEN 1 ELSE n * fact(n-1)`."
            },
            {
              "optionId": "ch_recursion_5_q8_opt2",
              "optionText": "The standard recursive solution mentioned has $O(n)$ time complexity."
            },
            {
              "optionId": "ch_recursion_5_q8_opt3",
              "optionText": "The standard recursive solution mentioned has $O(n)$ space complexity due to the call stack."
            },
            {
              "optionId": "ch_recursion_5_q8_opt4",
              "optionText": "An iterative solution can compute factorial in $O(n)$ time and $O(1)$ space using a loop."
            },
            {
              "optionId": "ch_recursion_5_q8_opt5",
              "optionText": "The standard recursive solution is an example of tail recursion."
            },
            {
              "optionId": "ch_recursion_5_q8_opt6",
              "optionText": "The iterative solution is generally more efficient in terms of space for this problem."
            },
            {
              "optionId": "ch_recursion_5_q8_opt7",
              "optionText": "For very large $n$, both recursive and iterative solutions might suffer from integer overflow if using standard integer types."
            },
            {
              "optionId": "ch_recursion_5_q8_opt8",
              "optionText": "Converting the standard recursive factorial to a tail-recursive form is straightforward by using an accumulator parameter."
            },
            {
              "optionId": "ch_recursion_5_q8_opt9",
              "optionText": "The recursive solution is always easier to understand than the iterative one."
            },
            {
              "optionId": "ch_recursion_5_q8_opt10",
              "optionText": "The iterative solution avoids the overhead of function calls."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q8_opt4"],
          "explanationText": "A key advantage of the iterative solution for factorial is its resource usage: **an iterative solution can compute factorial in $O(n)$ time and $O(1)$ space using a loop__. In contrast, the standard recursive solution `fact(n) = IF n≤1 THEN 1 ELSE n _ fact(n-1)` also has $O(n)$ time complexity but incurs $O(n)$ space complexity due to the call stack frames created for each recursive call (unless tail call optimization is applied, which is not possible for this specific non-tail-recursive form without an accumulator). The iterative solution also avoids the overhead associated with function calls.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q9",
          "questionText": "A recursive algorithm for the 'Closest Pair of Points' problem is a key example of divide-and-conquer. Which of the following descriptions best characterizes the 'Combine' phase of this algorithm, where results from subproblems are integrated?",
          "options": [
            {
              "optionId": "ch_recursion_5_q9_opt1",
              "optionText": "The set of points $P$ is divided into two halves, $P_L$ and $P_R$, based on their x-coordinates (e.g., by a median x-coordinate)."
            },
            {
              "optionId": "ch_recursion_5_q9_opt2",
              "optionText": "The closest pair is found recursively in $P_L$ (let distance be $d_L$) and in $P_R$ (let distance be $d_R$)."
            },
            {
              "optionId": "ch_recursion_5_q9_opt3",
              "optionText": "The minimum of $d_L$ and $d_R$ (let $d = \\min(d_L, d_R)$) is found. Then, a crucial step checks for a closer pair with one point in $P_L$ and one in $P_R$, within a 'strip' of width $2d$ around the dividing line."
            },
            {
              "optionId": "ch_recursion_5_q9_opt4",
              "optionText": "The brute-force approach of checking all pairs takes $O(n^2)$ time."
            },
            {
              "optionId": "ch_recursion_5_q9_opt5",
              "optionText": "The divide-and-conquer algorithm achieves $O(n \\log n)$ time complexity."
            },
            {
              "optionId": "ch_recursion_5_q9_opt6",
              "optionText": "Sorting points by y-coordinate within the strip helps to efficiently check for closer pairs across the divide."
            },
            {
              "optionId": "ch_recursion_5_q9_opt7",
              "optionText": "The base case for recursion is when the number of points is small (e.g., 2 or 3), where the closest pair is found by brute force."
            },
            {
              "optionId": "ch_recursion_5_q9_opt8",
              "optionText": "The algorithm requires pre-sorting the points by x-coordinate to efficiently divide."
            },
            {
              "optionId": "ch_recursion_5_q9_opt9",
              "optionText": "The 'strip check' only needs to consider a constant number of points near each point in the strip, due to geometric properties."
            },
            {
              "optionId": "ch_recursion_5_q9_opt10",
              "optionText": "Its space complexity is $O(n)$ due to storing sorted lists or recursive calls."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q9_opt3"],
          "explanationText": "In the divide-and-conquer algorithm for the Closest Pair of Points problem, the 'Divide' step partitions points. The 'Conquer' step recursively finds distances $d_L$ and $d_R$. The **'Combine' phase is best described by option `ch_recursion_5_q9_opt3`**: it takes $d = \\min(d_L, d_R)$ and then critically checks for any pair of points, one from each half, that are closer than $d$. This check is efficiently performed by considering only points within a narrow 'strip' of width $2d$ around the dividing line. This strip check is the core of the combine step and essential for achieving the algorithm's $O(n \\log n)$ efficiency.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q10",
          "questionText": "Which of the following is the _most direct and common_ disadvantage related to the execution mechanism of recursive functions?",
          "options": [
            {
              "optionId": "ch_recursion_5_q10_opt1",
              "optionText": "**Stack Overflow**: If the recursion is too deep, the call stack may run out of memory."
            },
            {
              "optionId": "ch_recursion_5_q10_opt2",
              "optionText": "**Performance Overhead**: Function calls (including recursive ones) can have more overhead (e.g., setting up stack frames, parameter passing) than simple loop iterations."
            },
            {
              "optionId": "ch_recursion_5_q10_opt3",
              "optionText": "**Redundant Computations**: Some recursive algorithms (like naive Fibonacci) can recompute the same subproblems multiple times, leading to inefficiency if not handled (e.g., by memoization)."
            },
            {
              "optionId": "ch_recursion_5_q10_opt4",
              "optionText": "Recursive solutions are always harder to read and understand than iterative ones."
            },
            {
              "optionId": "ch_recursion_5_q10_opt5",
              "optionText": "Not all problems can be solved recursively."
            },
            {
              "optionId": "ch_recursion_5_q10_opt6",
              "optionText": "Debugging recursive code can sometimes be more challenging due to the multiple call contexts."
            },
            {
              "optionId": "ch_recursion_5_q10_opt7",
              "optionText": "Missing or incorrect base cases can lead to infinite recursion (until a stack overflow)."
            },
            {
              "optionId": "ch_recursion_5_q10_opt8",
              "optionText": "Recursive algorithms inherently use more memory than their iterative counterparts due to stack usage (unless optimized, e.g., TCO)."
            },
            {
              "optionId": "ch_recursion_5_q10_opt9",
              "optionText": "Converting any iterative algorithm to a recursive one is trivial and always beneficial."
            },
            {
              "optionId": "ch_recursion_5_q10_opt10",
              "optionText": "Recursion is only suitable for mathematical functions like factorial or Fibonacci."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q10_opt1"],
          "explanationText": "The most direct and common disadvantage related to the execution mechanism of recursive functions is the risk of **Stack Overflow**. Each recursive call adds a new frame to the call stack to store its local variables, parameters, and return address. If the recursion depth is too large (e.g., due to a missing or incorrect base case, or processing a very large input in a way that leads to deep recursion), the finite space allocated for the call stack can be exhausted, leading to a stack overflow error and program termination. While performance overhead from function calls and potential for redundant computations are also disadvantages, stack overflow is a hard limit imposed by the execution environment.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q4_partA_calls",
          "questionText": "When tracing `FastPower(x=2, k=5)` using the algorithm:<br>`IF k = 0 THEN RETURN 1`<br>`y ← FastPower(x, k DIV 2)`<br>`IF k is even THEN RETURN y_y`<br>`ELSE RETURN y_y*x`<br>What is the sequence of recursive calls made, showing the value of `k` at each call?",
          "options": [
            {
              "optionId": "ch_recursion_5_q4_partA_opt1",
              "optionText": "$k=5 \\rightarrow k=2 \\rightarrow k=1 \\rightarrow k=0$"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt2",
              "optionText": "$k=5 \\rightarrow k=3 \\rightarrow k=1 \\rightarrow k=0$"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt3",
              "optionText": "$k=5 \\rightarrow k=4 \\rightarrow k=2 \\rightarrow k=0$"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt4",
              "optionText": "$k=5 \\rightarrow k=2.5$ (error, k DIV 2 is integer division)"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt5",
              "optionText": "Only one call: `FastPower(2,5)`"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt6",
              "optionText": "$k=5 \\rightarrow k=1$ (incorrect halving)"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt7",
              "optionText": "The function calls `FastPower(2,0)` directly from `FastPower(2,5)`."
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt8",
              "optionText": "$k=5 \\rightarrow k=2 \\rightarrow k=0$ (skips $k=1$)"
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt9",
              "optionText": "The sequence of calls depends on whether $k$ is even or odd at each step."
            },
            {
              "optionId": "ch_recursion_5_q4_partA_opt10",
              "optionText": "The recursion stops when $k=1$."
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q4_partA_opt1"],
          "explanationText": "Tracing the recursive calls for `FastPower(2, 5)` based on $k \\text{ DIV } 2$: <br>1. Initial call: $k=5$. Recursive call with $k = 5 \\text{ DIV } 2 = 2$.<br>2. Call with $k=2$. Recursive call with $k = 2 \\text{ DIV } 2 = 1$.<br>3. Call with $k=1$. Recursive call with $k = 1 \\text{ DIV } 2 = 0$.<br>4. Call with $k=0$. This is the base case, returns 1.<br>So, the sequence of $k$ values in the calls is $5 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_recursion_5_q4_partB_y_values",
          "questionText": "When tracing `FastPower(x=2, k=5)` (algorithm in previous question), what is the sequence of values assigned to the variable `y` in the respective call frames as the recursive calls return and computations proceed?",
          "options": [
            {
              "optionId": "ch_recursion_5_q4_partB_opt1",
              "optionText": "$y=1$ (in frame for $k=1$), then $y=2$ (in frame for $k=2$), then $y=4$ (in frame for $k=5$)"
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt2",
              "optionText": "$y=1$ (for $k=0$), $y=1$ (for $k=1$), $y=2$ (for $k=2$), $y=4$ (for $k=5$)"
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt3",
              "optionText": "$y=4$ (for $k=5$), then $y=2$ (for $k=2$), then $y=1$ (for $k=1$)"
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt4",
              "optionText": "$y$ is always 1."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt5",
              "optionText": "$y$ is assigned 32 in the outermost call."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt6",
              "optionText": "The value of $y$ is the final result of `FastPower(x, k DIV 2)`."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt7",
              "optionText": "$y=1$ (in frame for $k=0$ call result), then $y=1*1*2=2$ (in frame for $k=1$), then $y=2_2=4$ (in frame for $k=2$), then $y=4_4*2=32$ (in frame for $k=5$, this is final result, not $y$)."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt8",
              "optionText": "$y$ gets assigned the result of $y_y$ or $y_y*x$."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt9",
              "optionText": "$y=0$ initially in all frames."
            },
            {
              "optionId": "ch_recursion_5_q4_partB_opt10",
              "optionText": "$y=2$ (in frame for $k=1$), then $y=4$ (in frame for $k=2$), then $y=16$ (in frame for $k=5$)"
            }
          ],
          "correctOptionIds": ["ch_recursion_5_q4_partB_opt1"],
          "explanationText": "Let's trace assignments to $y$ as calls return: <br>1. `FastPower(2,0)` returns 1. <br>2. In frame for $k=1$ (which called `FastPower(2,0)`): $y$ gets 1. Returns $y*y*x = 1*1*2 = 2$. <br>3. In frame for $k=2$ (which called `FastPower(2,1)`): $y$ gets 2. Returns $y*y = 2*2 = 4$. <br>4. In frame for $k=5$ (which called `FastPower(2,2)`): $y$ gets 4. Returns $y*y*x = 4*4*2 = 32$. <br>Thus, the sequence of values assigned to $y$ in the call frames for $k=1$, then $k=2$, then $k=5$ is 1, then 2, then 4, respectively.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        }
      ],
      "totalQuestions": 12,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_adv_sorting_6",
      "name": "Chapter 6: Divide-and-Conquer Sorting Algorithms",
      "description": "Focuses on Quicksort and Mergesort, their mechanisms, performance characteristics (best, average, worst cases), space usage, stability, and the theoretical lower bound for comparison sorts.",
      "questions": [
        {
          "questionId": "ch_adv_sorting_6_q1",
          "questionText": "What is the generally accepted theoretical lower bound for the time complexity of any **comparison-based** sorting algorithm in the worst case, representing the minimum number of comparisons required?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q1_opt1",
              "optionText": "$O(n)$"
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt2",
              "optionText": "$O(\\log n)$"
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt3",
              "optionText": "$O(n^2)$"
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt4",
              "optionText": "$\\Omega(n \\log n)$"
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt5",
              "optionText": "This lower bound is derived by considering that there are $n!$ possible permutations (orderings) of $n$ distinct elements."
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt6",
              "optionText": "Each comparison between two elements can at best reduce the number of possible correct orderings by half, forming a binary decision tree."
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt7",
              "optionText": "The height of this decision tree, representing the minimum number of worst-case comparisons, must be at least $\\log_2(n!)$, which is $\\Omega(n \\log n)$."
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt8",
              "optionText": "$O(n!)$"
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt9",
              "optionText": "This bound applies only to in-place sorting algorithms."
            },
            {
              "optionId": "ch_adv_sorting_6_q1_opt10",
              "optionText": "Algorithms like Radix Sort can beat this lower bound because they are not comparison-based (they use digit/value properties)."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q1_opt4"],
          "explanationText": "The theoretical lower bound for the time complexity of any comparison-based sorting algorithm in the worst case is **$\\Omega(n \\log n)$**. This means that, to sort $n$ elements using only comparisons between elements, at least a number of comparisons proportional to $n \\log n$ will be required in the worst case. This bound is derived by considering a decision tree model: there are $n!$ possible permutations (orderings) of $n$ distinct elements, which must be the leaves of the decision tree. Since each comparison has at most two outcomes, the tree is binary. The height of such a tree must be at least $\\log_2(n!)$, and using Stirling's approximation for $n!$, $\\log_2(n!)$ is shown to be $\\Omega(n \\log n)$. Non-comparison-based sorts like Radix Sort can sometimes achieve better complexities (e.g., $O(nk)$) by using properties of the keys themselves rather than just comparisons.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q2",
          "questionText": "In the **Quicksort** algorithm, what is the _primary outcome_ of the **partitioning** step with respect to the chosen pivot element?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q2_opt1",
              "optionText": "To merge two already sorted subarrays into a single sorted array."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt2",
              "optionText": "To select a 'pivot' element randomly from the array."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt3",
              "optionText": "To rearrange the elements of the subarray such that all elements less than the pivot come before it, and all elements greater than the pivot come after it."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt4",
              "optionText": "To place the chosen pivot element into its final sorted position within the overall sorted array."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt5",
              "optionText": "To divide the array into two subarrays (left and right of the pivot) that are then sorted recursively."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt6",
              "optionText": "To count the number of elements smaller than the pivot."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt7",
              "optionText": "The partitioning step itself typically runs in $O(k)$ time for a subarray of size $k$."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt8",
              "optionText": "After partitioning, the two resulting subarrays are then sorted recursively."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt9",
              "optionText": "To find the median element of the array, which is then used as the pivot."
            },
            {
              "optionId": "ch_adv_sorting_6_q2_opt10",
              "optionText": "To ensure the stability of the Quicksort algorithm."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q2_opt4"],
          "explanationText": "The primary outcome of the partitioning step in Quicksort, with respect to the pivot element, is **to place the chosen pivot element into its final sorted position within the overall sorted array**. During partitioning, elements are rearranged such that all elements smaller than the pivot are moved to its left, and all elements larger than the pivot are moved to its right (elements equal to the pivot can be handled in various ways depending on the partitioning scheme). Once this rearrangement is complete, the pivot itself is in the correct position it will occupy in the fully sorted array, and it will not be moved again. The partitioning step typically runs in linear time ($O(k)$ for a subarray of size $k$). The two subarrays formed (to the left and right of the pivot's final position) are then sorted recursively.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q3",
          "questionText": "The performance of Quicksort heavily depends on pivot choice. What is its _worst-case time complexity_, and what is a common scenario that triggers this worst case if a naive pivot selection strategy (e.g., always picking the first element) is used?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q3_opt1",
              "optionText": "Best Case: $O(n \\log n)$, occurs when the pivot consistently divides the array into two nearly equal halves."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt2",
              "optionText": "Worst Case: $O(n^2)$, occurs when the pivot consistently results in a highly unbalanced partition (e.g., one part empty, other has $k-1$ elements)."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt3",
              "optionText": "The worst case can happen if the array is already sorted or reverse-sorted and the first/last element is always chosen as the pivot."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt4",
              "optionText": "Average Case: $O(n \\log n)$, which is why Quicksort is often fast in practice."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt5",
              "optionText": "Best Case: $O(n)$, if the array is already sorted and no swaps are needed."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt6",
              "optionText": "Worst Case: $O(n \\log n)$, if a randomized pivot is used."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt7",
              "optionText": "Choosing the median element as the pivot guarantees the best-case $O(n \\log n)$ partitioning, but finding the median takes $O(n)$ time itself."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt8",
              "optionText": "The depth of recursion in the best case is $O(\\log n)$."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt9",
              "optionText": "The depth of recursion in the worst case is $O(n)$."
            },
            {
              "optionId": "ch_adv_sorting_6_q3_opt10",
              "optionText": "Space complexity in worst case (naive recursion) can be $O(n)$ due to stack depth."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q3_opt2"],
          "explanationText": "Quicksort's worst-case time complexity is **$O(n^2)$**. This occurs when the partitioning step consistently produces highly unbalanced partitions – for example, when the pivot chosen is always the smallest or largest element in the current subarray, resulting in one partition being empty and the other containing all remaining $k-1$ elements. A common scenario that triggers this behavior is when Quicksort is applied to an already sorted or reverse-sorted array, and a naive pivot selection strategy is used, such as always picking the first or last element as the pivot. The best-case and average-case complexity of Quicksort is $O(n \\log n)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q4",
          "questionText": "In the **Mergesort** algorithm, what is the primary role of the **merge** step, and what is its typical time complexity for merging two sorted subarrays totaling $k$ elements?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q4_opt1",
              "optionText": "To divide the array into two halves recursively."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt2",
              "optionText": "To combine two already sorted subarrays into a single, larger sorted subarray."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt3",
              "optionText": "The merge step typically takes $O(k)$ time, where $k$ is the total number of elements in the two subarrays being merged."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt4",
              "optionText": "The merge step takes $O(k \\log k)$ time."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt5",
              "optionText": "It usually requires auxiliary (extra) space proportional to $k$ (i.e., $O(k)$) to perform the merge into a temporary array."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt6",
              "optionText": "It works by repeatedly picking the smaller of the current elements from the two input subarrays and placing it into the output array."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt7",
              "optionText": "The merge step can be done in-place with $O(1)$ extra space efficiently for arrays."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt8",
              "optionText": "The merge step is the 'divide' part of Mergesort."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt9",
              "optionText": "The efficiency of Mergesort relies on the efficiency of this merge step."
            },
            {
              "optionId": "ch_adv_sorting_6_q4_opt10",
              "optionText": "The merge step takes $O(k^2)$ time."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q4_opt2"],
          "explanationText": "The primary role of the merge step in Mergesort is **to combine two already sorted subarrays into a single, larger sorted subarray**. This is the 'combine' phase of its divide-and-conquer strategy. This merge operation is typically performed in $O(k)$ time, where $k$ is the total number of elements in the two subarrays being merged, as each element is examined and copied once. For array-based Mergesort, this step usually requires $O(k)$ auxiliary space for a temporary array to store the merged result.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q5",
          "questionText": "Which of the following statements _best describes a key performance guarantee_ of the **Mergesort** algorithm, distinguishing it from algorithms like standard Quicksort?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q5_opt1",
              "optionText": "Its time complexity is $O(n \\log n)$ in the worst, average, and best cases."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt2",
              "optionText": "It is an in-place sorting algorithm, requiring $O(1)$ auxiliary space."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt3",
              "optionText": "It typically requires $O(n)$ auxiliary space for the merging process in its array-based version."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt4",
              "optionText": "It is a stable sorting algorithm."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt5",
              "optionText": "It is not a stable sorting algorithm."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt6",
              "optionText": "It is highly adaptive to already sorted or nearly sorted data, achieving $O(n)$ in such cases."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt7",
              "optionText": "Its performance does not significantly change based on the initial order of the data (it is not adaptive)."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt8",
              "optionText": "The 'divide' step involves complex partitioning around a pivot."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt9",
              "optionText": "The 'divide' step simply splits the array into two halves, which takes $O(1)$ time (conceptually, for index calculation)."
            },
            {
              "optionId": "ch_adv_sorting_6_q5_opt10",
              "optionText": "It is generally preferred over Quicksort when stability is a requirement or worst-case $O(n \\log n)$ guarantee is needed."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q5_opt1"],
          "explanationText": "A key performance guarantee of Mergesort, which distinguishes it from standard Quicksort (with its $O(n^2)$ worst case), is that **its time complexity is $O(n \\log n)$ in the worst, average, and best cases**. This consistent and predictable performance makes Mergesort reliable. Additionally, Mergesort is a stable sorting algorithm. However, its typical array-based implementation requires $O(n)$ auxiliary space, which is a disadvantage compared to Quicksort's in-place partitioning (though Quicksort uses $O(\\log n)$ to $O(n)$ stack space for recursion).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q6",
          "questionText": "When comparing Quicksort and Mergesort, which statement _best highlights a common reason Quicksort might be preferred in practice for general-purpose array sorting, despite Mergesort's better worst-case time complexity_?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q6_opt1",
              "optionText": "Quicksort is generally faster on average in practice due to lower constant factors and better cache locality (being in-place for partitioning)."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt2",
              "optionText": "Mergesort has a better worst-case time complexity guarantee ($O(n \\log n)$) compared to Quicksort's potential $O(n^2)$."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt3",
              "optionText": "Quicksort is an in-place sort (typically $O(\\log n)$ stack space for well-behaved recursion, or $O(n)$ in worst-case recursion), while Mergesort (array version) requires $O(n)$ auxiliary space."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt4",
              "optionText": "Mergesort is stable by nature, while standard Quicksort implementations are often not stable."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt5",
              "optionText": "Quicksort is easier to implement correctly than Mergesort."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt6",
              "optionText": "Mergesort is preferred for external sorting (data on disk) because its sequential access pattern for merging is efficient."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt7",
              "optionText": "If memory is highly constrained and worst-case time is less critical, Quicksort's lower auxiliary space usage (for partitioning) might be preferred over array-based Mergesort."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt8",
              "optionText": "Both are based on the divide-and-conquer paradigm."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt9",
              "optionText": "Quicksort's performance is highly sensitive to pivot selection; Mergesort's is not."
            },
            {
              "optionId": "ch_adv_sorting_6_q6_opt10",
              "optionText": "Mergesort always performs fewer comparisons than Quicksort."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q6_opt1"],
          "explanationText": "Despite Mergesort's guaranteed $O(n \\log n)$ worst-case time complexity, **Quicksort is generally faster on average in practice due to lower constant factors in its operations and better cache locality**. Quicksort's partitioning step is typically performed in-place, leading to more efficient memory access patterns compared to the array-based Mergesort, which usually requires $O(n)$ auxiliary space for merging and involves more data movement. However, Mergesort is preferred when stability or a guaranteed $O(n \\log n)$ worst-case is critical.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q7",
          "questionText": "If Quicksort, using the first element of the current subarray as the pivot, is applied to an array that is already sorted in ascending order, what is the _most direct consequence on the partitioning process_?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q7_opt1",
              "optionText": "The pivot (the smallest element in the current subarray) results in a perfectly balanced partition."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt2",
              "optionText": "The pivot (always the smallest element in the current subarray) leads to one partition being empty and the other containing all other $k-1$ elements (for a subarray of size $k$)."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt3",
              "optionText": "This scenario leads to Quicksort's worst-case $O(n^2)$ time complexity."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt4",
              "optionText": "The algorithm effectively degrades to something like Selection Sort's behavior in terms of recursive depth."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt5",
              "optionText": "The depth of recursion becomes $O(n)$."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt6",
              "optionText": "Many swaps will occur during partitioning."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt7",
              "optionText": "Few or no actual swaps of element positions will occur during partitioning if implemented carefully, but comparisons still happen."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt8",
              "optionText": "The algorithm will exhibit $O(n \\log n)$ behavior because the array is sorted."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt9",
              "optionText": "The chosen pivot is always the minimum element of the subarray being partitioned."
            },
            {
              "optionId": "ch_adv_sorting_6_q7_opt10",
              "optionText": "The algorithm terminates quickly in $O(n)$ time."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q7_opt2"],
          "explanationText": "If Quicksort uses the first element as the pivot and is applied to an already sorted array, the most direct consequence on partitioning is that **the pivot (which will always be the smallest element in the current subarray) leads to a highly unbalanced partition: one partition will be empty (elements smaller than the pivot), and the other will contain all the remaining $k-1$ elements (elements larger than the pivot)**. This consistently poor partitioning leads to a recursion depth of $O(n)$ and an overall worst-case time complexity of $O(n^2)$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q8",
          "questionText": "Why is Mergesort often a good choice for sorting linked lists, particularly concerning its space requirements when compared to array-based Mergesort?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q8_opt1",
              "optionText": "Linked lists allow $O(1)$ random access to elements, which benefits Quicksort's partitioning."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt2",
              "optionText": "Mergesort's divide step (splitting the list, e.g., finding the middle) can be done efficiently for linked lists, often in $O(n)$ time using fast/slow pointers."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt3",
              "optionText": "Mergesort's merge step on linked lists can be done in-place (by rearranging pointers) with $O(1)$ auxiliary data space, unlike array-based Mergesort which needs $O(n)$ temporary array space."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt4",
              "optionText": "Quicksort's partitioning involves many swaps, which are inefficient for linked lists (requiring pointer readjustments for multiple nodes)."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt5",
              "optionText": "Linked lists naturally support the sequential access pattern of the merge operation in Mergesort."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt6",
              "optionText": "Quicksort requires $O(n)$ auxiliary space for linked lists."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt7",
              "optionText": "Mergesort for linked lists retains its $O(n \\log n)$ time complexity."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt8",
              "optionText": "Quicksort's typical partitioning schemes rely on efficient random access to elements (e.g., for swaps or pivot access), which is slow ($O(k)$ for $k$-th element) on linked lists."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt9",
              "optionText": "Mergesort is inherently stable, which is often desired and easily maintained with linked lists."
            },
            {
              "optionId": "ch_adv_sorting_6_q8_opt10",
              "optionText": "Quicksort for linked lists becomes $O(n^2)$ even in the average case."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q8_opt3"],
          "explanationText": "A key reason Mergesort is well-suited for linked lists is that **its merge step on linked lists can be performed in-place by rearranging pointers, requiring only $O(1)$ auxiliary data space** (excluding the stack space for recursion, which is $O(\\log n)$). This contrasts sharply with array-based Mergesort, which typically needs an $O(n)$ auxiliary array for merging. Additionally, linked lists naturally support the sequential access pattern of merging, and Quicksort's reliance on random access for efficient partitioning makes it less ideal for linked lists.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q9",
          "questionText": "For sorting very small arrays (e.g., $n < 20$), why might an algorithm like Insertion Sort be practically preferred over more complex algorithms like Quicksort or Mergesort, despite Insertion Sort's worse asymptotic complexity?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q9_opt1",
              "optionText": "Insertion Sort's number of swaps is always $O(n)$, making it ideal for small arrays."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt2",
              "optionText": "Insertion Sort performs optimally on small arrays because its $O(n)$ best-case complexity is frequently met."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt3",
              "optionText": "Insertion Sort's logic is simpler and involves fewer comparisons on average than Quicksort for tiny $n$."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt4",
              "optionText": "Heapsort, due to its $O(n \\log n)$ nature, is actually faster than Insertion Sort even for $n < 20$."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt5",
              "optionText": "Because the constant factors and overhead of recursive calls in Quicksort/Mergesort can make them slower for very small $n$."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt6",
              "optionText": "Many hybrid sorting algorithms (like Timsort or Introsort) switch to Insertion Sort for small partitions for this reason."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt7",
              "optionText": "Radix Sort is generally the fastest for small integer arrays."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt8",
              "optionText": "The simplicity of implementing Insertion Sort correctly reduces development time for small, non-critical tasks."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt9",
              "optionText": "Quicksort and Mergesort are always faster regardless of $n$ due to their superior Big O."
            },
            {
              "optionId": "ch_adv_sorting_6_q9_opt10",
              "optionText": "Insertion Sort is stable, which is a primary requirement for small array sorting."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q9_opt5"],
          "explanationText": "For very small arrays, algorithms like Insertion Sort can be practically faster than Quicksort or Mergesort primarily **because the constant factors and overhead associated with the recursive calls and more complex logic of Quicksort/Mergesort can outweigh their superior asymptotic ($O(n \\log n)$) behavior**. Insertion Sort has a simple loop structure with low overhead. Its $O(n^2)$ complexity is not detrimental for tiny $n$ (e.g., $n < 20$). This is why many sophisticated hybrid sorting algorithms (as mentioned in `ch_adv_sorting_6_q9_opt6`) switch to Insertion Sort when dealing with small partitions. While simplicity of implementation (`ch_adv_sorting_6_q9_opt8`) can be a factor, performance is the key reason here.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_adv_sorting_6_q10",
          "questionText": "The 'three-way partition' variant of Quicksort is particularly useful for arrays with many duplicate keys. What is its _primary mechanism_ for handling these duplicates?",
          "options": [
            {
              "optionId": "ch_adv_sorting_6_q10_opt1",
              "optionText": "It partitions the array into three parts: elements less than the pivot, elements equal to the pivot, and elements greater than the pivot."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt2",
              "optionText": "After partitioning, the elements equal to the pivot are already in their final sorted positions and do not need further processing."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt3",
              "optionText": "Recursive calls are then made only on the 'less than' and 'greater than' partitions, excluding the 'equal to pivot' middle part."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt4",
              "optionText": "This can improve performance significantly, potentially towards $O(n)$ in the case of arrays with very few unique values (many duplicates)."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt5",
              "optionText": "It makes Quicksort stable."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt6",
              "optionText": "It always uses three pivots simultaneously."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt7",
              "optionText": "Standard (two-way) partitioning can handle duplicates inefficiently, potentially leading to $O(n^2)$ behavior if many elements are equal to the pivot and all go to one side of the partition."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt8",
              "optionText": "It is more complex to implement than standard two-way partitioning."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt9",
              "optionText": "Dijkstra's Dutch National Flag problem provides a basis for one such partitioning scheme (e.g., Bentley-McIlroy)."
            },
            {
              "optionId": "ch_adv_sorting_6_q10_opt10",
              "optionText": "It guarantees $O(n \\log n)$ worst-case performance."
            }
          ],
          "correctOptionIds": ["ch_adv_sorting_6_q10_opt1"],
          "explanationText": "The primary mechanism of three-way partitioning in Quicksort is that **it partitions the array into three distinct parts based on the pivot: elements less than the pivot, elements equal to the pivot, and elements greater than the pivot**. The significant benefit is that elements equal to the pivot are then correctly placed and excluded from subsequent recursive calls, which are made only on the 'less than' and 'greater than' partitions. This can dramatically improve performance on inputs with many duplicate keys, potentially leading to linear time if most elements are identical, by avoiding the $O(n^2)$ behavior that standard two-way partitioning might exhibit with such inputs.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 10,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_limits_pnp_7",
      "name": "Chapter 7: Limits of Algorithms - P, NP, and NP-Completeness",
      "description": "Explores the concepts of tractability (P), non-deterministic polynomial time (NP), NP-complete problems, reductions, and the significance of the P vs NP problem.",
      "questions": [
        {
          "questionId": "ch_limits_pnp_7_q1",
          "questionText": "What is the _formal definition_ of the complexity class **P** in computational complexity theory?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q1_opt1",
              "optionText": "The set of all decision problems that can be solved by a deterministic Turing machine in **polynomial time** with respect to the input size."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt2",
              "optionText": "Problems in P are generally considered **tractable** or efficiently solvable."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt3",
              "optionText": "Examples include sorting (e.g., Mergesort), shortest path in a graph (e.g., Dijkstra's), and matrix multiplication."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt4",
              "optionText": "The set of problems solvable in exponential time."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt5",
              "optionText": "The set of problems for which a solution can be verified in polynomial time."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt6",
              "optionText": "P stands for 'Probabilistic' polynomial time."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt7",
              "optionText": "Any decision problem solvable by an algorithm with time complexity $O(n^k)$ for some constant $k$ is in P."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt8",
              "optionText": "All problems in P are also in NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt9",
              "optionText": "The Halting Problem is in P."
            },
            {
              "optionId": "ch_limits_pnp_7_q1_opt10",
              "optionText": "P includes problems solvable in $O(\\log n)$ time."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q1_opt1"],
          "explanationText": "The formal definition of the complexity class P is: **the set of all decision problems that can be solved by a deterministic Turing machine in polynomial time with respect to the input size**. This means if a problem can be solved by an algorithm whose running time is bounded by $O(n^k)$ for some constant $k$ (where $n$ is the input size), then the problem is in P. Problems in P are generally considered 'tractable' or efficiently solvable. The statement that problems solvable with time complexity $O(n^k)$ are in P is a direct consequence of this definition.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q2",
          "questionText": "What is the _most common definition_ of the complexity class **NP** (Non-deterministic Polynomial time) in terms of solution verification?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q2_opt1",
              "optionText": "The set of decision problems for which a 'yes' instance has a certificate (or proof) that can be **verified** in polynomial time by a deterministic algorithm."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt2",
              "optionText": "Equivalently, the set of decision problems that can be solved in polynomial time by a **non-deterministic Turing machine**."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt3",
              "optionText": "It stands for 'Not Polynomial', meaning problems that cannot be solved in polynomial time."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt4",
              "optionText": "All problems in NP are known to be intractable."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt5",
              "optionText": "The class P is a subset of NP ($P \\subseteq NP$)."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt6",
              "optionText": "The Boolean Satisfiability Problem (SAT) is a well-known example of a problem in NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt7",
              "optionText": "If a problem is in NP, it means we can always find a solution quickly, but checking it is hard."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt8",
              "optionText": "NP problems typically involve searching through an exponentially large space of potential solutions."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt9",
              "optionText": "The 'non-deterministic' aspect implies a hypothetical machine that can 'guess' the correct path to a solution and then verify it."
            },
            {
              "optionId": "ch_limits_pnp_7_q2_opt10",
              "optionText": "The Traveling Salesperson Problem (decision version) is in NP."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q2_opt1"],
          "explanationText": "The most common way to define the class NP (Non-deterministic Polynomial time) is as **the set of decision problems for which a 'yes' instance has a certificate (or proof) that can be verified in polynomial time by a deterministic algorithm**. This means if someone gives you a potential solution to a problem in NP, you can check if it's correct quickly (in polynomial time). An equivalent formal definition is the set of decision problems solvable in polynomial time by a non-deterministic Turing machine. It is known that P is a subset of NP ($P \\subseteq NP$).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q3",
          "questionText": "For a problem to be classified as NP-Complete, it must satisfy two essential conditions. Which of the following describes the condition related to the verifiability of its solutions in polynomial time?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q3_opt1",
              "optionText": "The problem must be in the class **NP**."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt2",
              "optionText": "The problem must be **NP-hard**."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt3",
              "optionText": "The problem must be solvable in polynomial time (in P)."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt4",
              "optionText": "The problem must be undecidable."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt5",
              "optionText": "The problem must have been first proven NP-Complete by Cook or Levin."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt6",
              "optionText": "The problem must be reducible to SAT in polynomial time."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt7",
              "optionText": "The problem must involve graph theory."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt8",
              "optionText": "The problem must have an exponential number of possible solutions."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt9",
              "optionText": "The problem must be a decision problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q3_opt10",
              "optionText": "The problem must not be solvable by a greedy algorithm."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q3_opt1"],
          "explanationText": "A problem is NP-Complete if it meets two conditions: 1. **The problem must be in the class NP**. This means that if a solution is provided (a 'certificate'), it can be verified in polynomial time. 2. The problem must be NP-hard, meaning every other problem in NP can be reduced to it in polynomial time. The question asks about the condition related to verifiability, which directly corresponds to the problem being in NP.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q4",
          "questionText": "When we say problem A can be **reduced** to problem B in polynomial time ($A \\le_P B$), what is the _most significant implication_ regarding their relative difficulty?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q4_opt1",
              "optionText": "It means problem A is simpler than problem B."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt2",
              "optionText": "There exists an algorithm (the reduction) that can transform any instance of problem A into an instance of problem B, and this transformation takes polynomial time."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt3",
              "optionText": "A 'yes' answer for the transformed instance of B must correspond to a 'yes' answer for the original instance of A, and a 'no' answer for B to a 'no' answer for A (for decision problems)."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt4",
              "optionText": "This implies that if problem B can be solved in polynomial time, then problem A can also be solved in polynomial time (using the reduction and B's solver)."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt5",
              "optionText": "Reductions are a primary tool for proving problems are NP-hard: if a known NP-hard problem $X$ is reduced to $Y$ ($X \\le_P Y$), then $Y$ is also NP-hard."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt6",
              "optionText": "It means problem A and problem B are essentially the same problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt7",
              "optionText": "The transformation must preserve 'yes' instances to 'yes' instances and 'no' instances to 'no' instances for decision problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt8",
              "optionText": "It implies that problem A is at most as hard as problem B (in terms of polynomial solvability)."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt9",
              "optionText": "The reduction itself must be an exponential-time algorithm."
            },
            {
              "optionId": "ch_limits_pnp_7_q4_opt10",
              "optionText": "If problem A is NP-hard and $A \\le_P B$, then B must also be NP-hard."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q4_opt4"],
          "explanationText": "A polynomial-time reduction from problem A to problem B ($A \\le_P B$) means there's a polynomial-time algorithm to transform any instance of A into an instance of B such that solving the B instance gives a solution to the A instance. The most significant implication is that **if problem B can be solved in polynomial time, then problem A can also be solved in polynomial time**. This is because the total time to solve A would be the polynomial time for reduction plus the polynomial time for solving B. This effectively means A is 'no harder than' B. Reductions are crucial for proving NP-hardness: if a known NP-hard problem A is reduced to B, then B must also be NP-hard.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q5",
          "questionText": "The **P versus NP problem** is a major unsolved question in computer science. What is the _fundamental question_ it asks?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q5_opt1",
              "optionText": "Fundamentally, it asks whether every problem whose solution can be quickly verified (NP) can also be quickly solved (P)."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt2",
              "optionText": "More formally, it asks: Is the class P equal to the class NP ($P=NP$) or is P a proper subset of NP ($P \\subsetneq NP$)?"
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt3",
              "optionText": "A direct consequence is: can NP-Complete problems be solved by polynomial-time deterministic algorithms? (Yes, if P=NP; likely No, if P!=NP)."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt4",
              "optionText": "If $P=NP$, it would imply that many currently intractable problems (like SAT, TSP decision version) have efficient (polynomial-time) solutions."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt5",
              "optionText": "Most computer scientists and mathematicians currently believe that $P \\ne NP$."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt6",
              "optionText": "A proof for $P=NP$ or $P \\ne NP$ would have profound implications for fields like cryptography, AI, optimization, and mathematics."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt7",
              "optionText": "It asks if non-deterministic computation is fundamentally more powerful than deterministic computation in terms of polynomial time solvability."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt8",
              "optionText": "The problem has already been solved, and it's known that $P \\ne NP$."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt9",
              "optionText": "It is primarily concerned with the space complexity of problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q5_opt10",
              "optionText": "If $P=NP$, then problems like factoring large numbers (basis of RSA) could be done efficiently, breaking current cryptographic schemes. (Note: Factoring is in NP, but not known to be NP-Complete)."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q5_opt1"],
          "explanationText": "The fundamental question of the P versus NP problem is: **whether every problem for which a proposed solution can be quickly verified (this defines the class NP) can also be quickly solved (this defines the class P)**. 'Quickly' here means in polynomial time. More formally, it asks if the complexity class P is equal to the complexity class NP. If P=NP, it would mean that many problems currently considered very hard to solve (like NP-Complete problems such as SAT or the decision version of TSP) could actually be solved efficiently. Most researchers believe $P \\ne NP$, but this remains unproven.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q6",
          "questionText": "Which of the following statements _best defines_ what it means for a problem to be undecidable?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q6_opt1",
              "optionText": "It is a problem for which no algorithm can ever be constructed that will always produce a correct yes/no answer for all possible inputs in a finite amount of time."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt2",
              "optionText": "The Halting Problem (determining if an arbitrary program will halt or run forever on a given input) is a classic example of an undecidable problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt3",
              "optionText": "It means the problem is NP-Complete and likely requires exponential time."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt4",
              "optionText": "It means no one has yet found an algorithm for it, but one might exist."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt5",
              "optionText": "Undecidability is a stronger form of difficulty than NP-hardness; NP-hard problems are decidable (an algorithm exists, possibly exponential), but undecidable problems have no general algorithm at all."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt6",
              "optionText": "Alan Turing's work on Turing machines was fundamental in establishing the concept of undecidability."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt7",
              "optionText": "Post's Correspondence Problem is another example of an undecidable problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt8",
              "optionText": "Undecidable problems can often be solved for specific, restricted instances, but not for the general case."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt9",
              "optionText": "The Program Equivalence problem (determining if two programs compute the same function) is undecidable."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_opt10",
              "optionText": "All undecidable problems are decision problems."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q6_opt1"],
          "explanationText": "The best definition of an undecidable problem is that **it is a problem for which no algorithm can ever be constructed that will always produce a correct yes/no answer for all possible inputs in a finite amount of time**. This means there is no general, universally applicable procedure to solve it. The Halting Problem is a classic example illustrating this concept. Undecidability represents a fundamental limit on what can be computed, distinct from NP-hardness (which concerns problems that are decidable but potentially very time-consuming).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q7",
          "questionText": "If a problem X is NP-Complete, and we find a polynomial-time reduction from X to a new problem Y (i.e., $X \\le_P Y$), what is the _most immediate conclusion_ we can draw about problem Y's hardness classification?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q7_opt1",
              "optionText": "Problem Y must be in P."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt2",
              "optionText": "Problem Y must be NP-hard."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt3",
              "optionText": "If problem Y is also known to be in NP, then problem Y is NP-Complete."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt4",
              "optionText": "Problem Y is easier than problem X."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt5",
              "optionText": "Problem Y cannot be solved in polynomial time unless P=NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt6",
              "optionText": "This implies that Y is at least as hard as X (in terms of polynomial solvability)."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt7",
              "optionText": "Problem Y is undecidable."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt8",
              "optionText": "Problem Y must be solvable in exponential time."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt9",
              "optionText": "The reduction shows how to solve Y using an algorithm for X."
            },
            {
              "optionId": "ch_limits_pnp_7_q7_opt10",
              "optionText": "Problem Y is a special case of problem X."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q7_opt2"],
          "explanationText": "If an NP-Complete problem $X$ is polynomially reducible to problem $Y$ (denoted $X \\le_P Y$), the most immediate and direct conclusion regarding $Y$'s hardness classification is that **problem $Y$ must be NP-hard**. This is because NP-hardness means that every problem in NP can be reduced to $Y$ in polynomial time. Since $X$ is NP-Complete, all NP problems reduce to $X$, and $X$ reduces to $Y$, then by transitivity, all NP problems reduce to $Y$. If $Y$ were also shown to be in NP (its solutions verifiable in polynomial time), then $Y$ would be NP-Complete. The statement that '$Y$ cannot be solved in polynomial time unless P=NP' (option `ch_limits_pnp_7_q7_opt5`) is a direct consequence of $Y$ being NP-hard, but NP-hardness itself is the primary classification derived from the reduction.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q8",
          "questionText": "Among the following, which graph-theoretic problem is a well-known example that has been proven to be NP-Complete?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q8_opt1",
              "optionText": "Finding if a graph contains an Eulerian circuit."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt2",
              "optionText": "The Graph Coloring problem (decision version: can the graph be colored with $k$ colors?)."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt3",
              "optionText": "Checking if a graph is bipartite."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt4",
              "optionText": "Finding a Minimum Spanning Tree in a weighted graph."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt5",
              "optionText": "Finding the shortest path between two nodes in a weighted graph."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt6",
              "optionText": "The Halting Problem for graph algorithms."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt7",
              "optionText": "Topological sorting of a directed acyclic graph."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt8",
              "optionText": "Graph Isomorphism (determining if two graphs are structurally identical)."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt9",
              "optionText": "Finding the diameter of a graph."
            },
            {
              "optionId": "ch_limits_pnp_7_q8_opt10",
              "optionText": "Maximum flow in a flow network."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q8_opt2"],
          "explanationText": "The **Graph Coloring problem** (decision version: determining if a graph can be colored with $k$ colors such that no two adjacent vertices share the same color) is a classic NP-Complete problem. Many other problems listed, such as finding Eulerian circuits, checking bipartiteness, Minimum Spanning Tree, shortest path, topological sort, and maximum flow, are solvable in polynomial time (are in P). The Halting Problem is undecidable. Graph Isomorphism is in NP but not known to be NP-Complete or in P.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q9",
          "questionText": "What was the _most groundbreaking achievement_ of the Cook-Levin theorem in complexity theory?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q9_opt1",
              "optionText": "It proved that P = NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt2",
              "optionText": "It proved that P is not equal to NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt3",
              "optionText": "It established that the Boolean Satisfiability Problem (SAT) is NP-Complete."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt4",
              "optionText": "SAT was the first problem to be proven NP-Complete, serving as a foundational result."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt5",
              "optionText": "It provided the crucial first 'anchor' NP-Complete problem, enabling subsequent NP-Completeness proofs for many other problems via polynomial-time reductions from SAT (or other known NPC problems)."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt6",
              "optionText": "It showed that all NP problems can be solved in exponential time."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt7",
              "optionText": "It defined the class NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt8",
              "optionText": "It proved that the Halting Problem is undecidable."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt9",
              "optionText": "The theorem shows that any problem solvable by a non-deterministic Turing machine in polynomial time can be effectively encoded as a SAT instance of polynomial size."
            },
            {
              "optionId": "ch_limits_pnp_7_q9_opt10",
              "optionText": "It was independently proven by Stephen Cook and Leonid Levin around the same time."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q9_opt3"],
          "explanationText": "The most groundbreaking achievement of the Cook-Levin theorem was that **it established that the Boolean Satisfiability Problem (SAT) is NP-Complete**. This was a monumental result because SAT became the very first problem for which NP-completeness was proven. This provided the essential 'anchor' or starting point for the entire theory of NP-completeness, allowing researchers to subsequently prove thousands of other problems NP-Complete by reducing SAT (or other already known NP-Complete problems) to them. The theorem itself did not solve the P versus NP question.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_limits_pnp_7_q10",
          "questionText": "If it were proven that $P \\ne NP$ (which is widely believed), what would be the _most significant practical consequence_ for attempting to find exact, optimal solutions for NP-Complete problems like the Traveling Salesperson Problem (TSP) for large instances?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q10_opt1",
              "optionText": "It would mean no general polynomial-time algorithm exists for solving these problems exactly for all instances."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt2",
              "optionText": "Practitioners would continue to rely heavily on approximation algorithms, heuristics, or algorithms efficient for special cases or average cases for these problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt3",
              "optionText": "Finding an exact optimal solution for large instances would remain computationally infeasible for many such problems, likely requiring super-polynomial (e.g., exponential) time."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt4",
              "optionText": "It would confirm that these problems are fundamentally harder to solve than problems in P."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt5",
              "optionText": "It means these problems become undecidable."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt6",
              "optionText": "It would have no practical implications, as current algorithms are good enough."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt7",
              "optionText": "It would validate the security assumptions of many cryptographic systems that rely on the presumed intractability of certain NP problems (though not all are NP-Complete)."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt8",
              "optionText": "It would imply that non-deterministic computation (the ability to 'guess' correctly) is inherently more powerful than deterministic computation for these problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt9",
              "optionText": "Research would stop on finding exact algorithms for these problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q10_opt10",
              "optionText": "It means these problems can be solved in polynomial time, but only on a non-deterministic Turing machine."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q10_opt1"],
          "explanationText": "If $P \\ne NP$ were proven, the most significant practical consequence for NP-Complete problems would be that **no general polynomial-time algorithm exists for solving these problems exactly for all instances**. This would confirm their inherent computational difficulty, meaning that finding exact, optimal solutions for large instances would likely require super-polynomial (e.g., exponential) time and thus remain computationally infeasible for many practical purposes. As a result, practitioners would continue to focus on approximation algorithms, heuristics, and methods for special cases to find 'good enough' solutions in a reasonable timeframe.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q11",
          "questionText": "Which of the following statements _most accurately describes one key conceptual relationship_ between P, NP, and NP-Complete (NPC) classes, assuming the common belief that $P \\ne NP$?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q11_opt1",
              "optionText": "$P$ is a proper subset of $NP$ ($P \\subsetneq NP$)."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt2",
              "optionText": "$NPC$ is a subset of $NP$ ($NPC \\subset NP$)."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt3",
              "optionText": "The intersection of $P$ and $NPC$ is empty ($P \\cap NPC = \\emptyset$), because if an NPC problem were in P, then P would equal NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt4",
              "optionText": "If a problem is in $P$, it cannot be $NPC$ (this is a direct consequence if $P \\ne NP$)."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt5",
              "optionText": "$NP$ may contain problems that are not in $P$ and not $NPC$ (these are called NP-intermediate problems, e.g., Integer Factorization is a candidate if $P \\ne NP$)."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt6",
              "optionText": "$P = NP = NPC$."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt7",
              "optionText": "All problems in $NP$ are also $NPC$."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt8",
              "optionText": "$NPC$ problems are the 'easiest' problems in $NP$ because they are all reducible to each other."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt9",
              "optionText": "Any problem in $NPC$ can be used to solve any other problem in $NP$ with only polynomial overhead via reductions."
            },
            {
              "optionId": "ch_limits_pnp_7_q11_opt10",
              "optionText": "The Halting problem is in $NPC$."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q11_opt1"],
          "explanationText": "Assuming the widely believed conjecture that $P \\ne NP$, a key conceptual relationship is that **$P$ is a proper subset of $NP$ ($P \\subsetneq NP$)**. This means all problems solvable in polynomial time (P) are also verifiable in polynomial time (NP), but there exist problems in NP that are not solvable in polynomial time. Other true statements under this assumption include: NP-Complete (NPC) problems form a subset of NP; the intersection of P and NPC is empty; and NP might contain NP-intermediate problems (neither in P nor NPC).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q12",
          "questionText": "What is a _primary reason_ (related to its proof methodology) why the Halting Problem (asking whether an arbitrary program will halt on a given input) is undecidable?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q12_opt1",
              "optionText": "Because no general algorithm can be constructed that correctly answers this question for all possible program-input pairs in finite time."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt2",
              "optionText": "The proof of undecidability often involves a diagonalization argument or a proof by contradiction."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt3",
              "optionText": "A common proof technique shows that if such a halting-checker algorithm (H) existed, one could construct a paradoxical program (P) that feeds its own description to H and then does the opposite of what H predicts P will do, leading to a contradiction."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt4",
              "optionText": "Because it is NP-Complete, and P is likely not equal to NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt5",
              "optionText": "Because programs can be infinitely long."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt6",
              "optionText": "It means we can never determine if _any_ specific program will halt."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt7",
              "optionText": "The problem is decidable for very simple programs or finite state machines."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt8",
              "optionText": "Its undecidability was first proven by Alan Turing in the context of Turing machines."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt9",
              "optionText": "Its undecidability implies that automatic full verification of all software properties (like proving freedom from all infinite loops) is impossible."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_opt10",
              "optionText": "Because some programs require exponential time to halt."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q12_opt3"],
          "explanationText": "A primary reason for the Halting Problem's undecidability, related to its proof methodology, is that **a common proof technique shows that if such a halting-checker algorithm (H) existed, one could construct a paradoxical program (P) that feeds its own description to H and then does the opposite of what H predicts P will do, leading to a contradiction**. This method, often involving a self-referential argument similar to diagonalization, demonstrates the impossibility of a general halting decider. While the statement that 'no general algorithm can be constructed' is the definition of undecidability, and Alan Turing's proof is historical, the paradoxical construction is central to _how_ this undecidability is proven.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q6_partA_definition",
          "questionText": "What does it most fundamentally mean for a problem to be **undecidable**?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt1",
              "optionText": "No algorithm can ever be constructed that will always produce a correct yes/no answer for all possible inputs in a finite amount of time."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt2",
              "optionText": "It means the problem is NP-Complete and likely requires exponential time."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt3",
              "optionText": "It means no one has yet found an algorithm for it, but one might exist."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt4",
              "optionText": "Undecidability is a stronger form of difficulty than NP-hardness; NP-hard problems are decidable, but undecidable problems have no general algorithm."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt5",
              "optionText": "All undecidable problems are decision problems."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt6",
              "optionText": "It can be solved for specific, restricted instances, but not for the general case."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt7",
              "optionText": "Its solution is known but too complex to implement."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt8",
              "optionText": "It requires a non-deterministic Turing machine to solve."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt9",
              "optionText": "It primarily relates to problems with infinite output spaces."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partA_opt10",
              "optionText": "It is a problem that can only be solved by quantum computers."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q6_partA_opt1"],
          "explanationText": "The most fundamental meaning of undecidability is that **no algorithm can ever be constructed that will always produce a correct yes/no answer for all possible inputs in a finite amount of time**. This is a core definition. Undecidability implies a stronger form of difficulty than NP-hardness; NP-hard problems are decidable (an algorithm exists, possibly exponential), but undecidable problems have no general algorithm at all.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q6_partB_example",
          "questionText": "Which of the following is a classic example of an undecidable problem in computer science?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt1",
              "optionText": "The Boolean Satisfiability Problem (SAT)."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt2",
              "optionText": "The Halting Problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt3",
              "optionText": "Sorting an array of numbers."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt4",
              "optionText": "The Traveling Salesperson Problem (TSP)."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt5",
              "optionText": "Finding the shortest path in a graph."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt6",
              "optionText": "Post's Correspondence Problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt7",
              "optionText": "The Program Equivalence problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt8",
              "optionText": "Integer Factorization."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt9",
              "optionText": "Vertex Cover Problem."
            },
            {
              "optionId": "ch_limits_pnp_7_q6_partB_opt10",
              "optionText": "Matrix Multiplication."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q6_partB_opt2"],
          "explanationText": "**The Halting Problem** (determining if an arbitrary program will halt or run forever on a given input) is a classic example of an undecidable problem. Other examples include Post's Correspondence Problem and the Program Equivalence problem. Problems like SAT, TSP, and Vertex Cover are NP-Complete (and thus decidable, though hard), while Sorting and Shortest Path are in P (efficiently solvable).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q12_partA_reason",
          "questionText": "What is a primary reason why the Halting Problem (asking whether an arbitrary program will halt on a given input) is undecidable?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt1",
              "optionText": "No general algorithm can be constructed that correctly answers this question for all possible program-input pairs in finite time."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt2",
              "optionText": "The proof involves a diagonalization argument or a proof by contradiction, showing that a hypothetical halting-checker leads to a paradox."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt3",
              "optionText": "Because it is NP-Complete, and P is likely not equal to NP."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt4",
              "optionText": "Because computer programs can be infinitely long."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt5",
              "optionText": "It implies that automatic full verification of all software properties is impossible."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt6",
              "optionText": "It is decidable for finite state machines."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt7",
              "optionText": "Because some programs require exponential time to halt."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt8",
              "optionText": "Its solution space is too large to search."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt9",
              "optionText": "The problem definition is ambiguous."
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partA_opt10",
              "optionText": "It was proven undecidable using a model of computation weaker than Turing machines."
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q12_partA_opt1"],
          "explanationText": "A primary reason the Halting Problem is undecidable is that **no general algorithm can be constructed that correctly answers whether any arbitrary program will halt on a given input for all possible program-input pairs in a finite amount of time**. Proofs of this, like Turing's original proof, often use a method of contradiction (related to diagonalization): if such a halting-checker algorithm existed, one could construct a paradoxical program that behaves contrary to the checker's prediction about itself, leading to a logical impossibility. The implication for software verification, while significant, is a consequence of this fundamental undecidability.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_limits_pnp_7_q12_partB_history",
          "questionText": "Who first proved the undecidability of the Halting Problem?",
          "options": [
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt1",
              "optionText": "Stephen Cook"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt2",
              "optionText": "Leonid Levin"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt3",
              "optionText": "Alan Turing"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt4",
              "optionText": "Kurt Gödel"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt5",
              "optionText": "Alonzo Church"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt6",
              "optionText": "John von Neumann"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt7",
              "optionText": "Edsger Dijkstra"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt8",
              "optionText": "Richard Karp"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt9",
              "optionText": "Donald Knuth"
            },
            {
              "optionId": "ch_limits_pnp_7_q12_partB_opt10",
              "optionText": "Noam Chomsky"
            }
          ],
          "correctOptionIds": ["ch_limits_pnp_7_q12_partB_opt3"],
          "explanationText": "The undecidability of the Halting Problem was first proven by **Alan Turing** in 1936 in his seminal paper on Turing machines. This was a foundational result in the theory of computation.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 16,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_regex_fsm_8",
      "name": "Chapter 8: Regular Expressions and Finite State Machines",
      "description": "Covers formal language basics, operations on languages, regular expression syntax and semantics, Finite State Machine (FSM) components and operation, and the equivalence between regex and FSMs.",
      "questions": [
        {
          "chapterIdToAddTo": "ch_regex_fsm_8",
          "questionId": "ch_regex_fsm_8_q1",
          "questionText": "In formal language theory, what is an 'alphabet' (often denoted $\\Sigma$)?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt1",
              "optionText": "A finite, non-empty set of symbols (or letters)."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt2",
              "optionText": "A <b>string</b> (or word): a finite sequence of symbols chosen from an alphabet."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt3",
              "optionText": "A <b>language</b>: a set of strings over a particular alphabet (can be finite or infinite)."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt4",
              "optionText": "$\\Sigma^*$ denotes the set of all possible strings over the alphabet $\\Sigma$, including the empty string."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt5",
              "optionText": "Grammar rules specific to natural languages like English."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt6",
              "optionText": "An infinite set of characters."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt7",
              "optionText": "The empty string, often denoted by $\\epsilon$ or $\\lambda$."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt8",
              "optionText": "A specific programming language's keywords."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt9",
              "optionText": "A regular expression used to define a language."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partA_opt10",
              "optionText": "A state in a finite automaton."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q1_partA_opt1"],
          "explanationText": "An <b>alphabet</b> ($\\Sigma$) in formal language theory is defined as a <b>finite, non-empty set of symbols</b> (also called letters or characters). For example, $\\Sigma = \\{0, 1\\}$ is the binary alphabet, and $\\Sigma = \\{a, b, c\\}$ is another common example. Strings are formed from symbols in an alphabet, and languages are sets of these strings.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "chapterIdToAddTo": "ch_regex_fsm_8",
          "questionId": "ch_regex_fsm_8_q1_part3",
          "questionText": "How is a 'language' defined in the context of formal language theory?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt1",
              "optionText": "A finite, non-empty set of symbols."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt2",
              "optionText": "A finite sequence of symbols chosen from an alphabet."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt3",
              "optionText": "A set of finite sequences of symbols (strings), where each symbol is from a particular alphabet."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt4",
              "optionText": "Only infinite sets of strings can be languages."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt5",
              "optionText": "The set of all possible strings over an alphabet, $\\Sigma^*$ (this is one specific example, not the general definition)."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt6",
              "optionText": "A specific type of grammar, like a Context-Free Grammar."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt7",
              "optionText": "The empty set $\\emptyset$ cannot be considered a language."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt8",
              "optionText": "A natural communication system like English or Spanish."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt9",
              "optionText": "A regular expression itself (a regular expression *describes* a language)."
            },
            {
              "optionId": "ch_regex_fsm_8_q1_partC_opt10",
              "optionText": "A single, very long string of symbols."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q1_partC_opt3"],
          "explanationText": "A <b>language</b> in formal language theory is defined as a <b>set of finite sequences of symbols (strings), where each symbol in those strings is drawn from a specific alphabet</b>. A language can be finite (containing a limited number of strings, e.g., $\\{'cat', 'dog'\\}$) or infinite (e.g., all binary strings with an even number of 0s). The set of all possible strings $\\Sigma^*$ is one example of a language, as is the empty set $\\emptyset$ (the language containing no strings), and the set containing only the empty string, $\\{\\epsilon\\}$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q2",
          "questionText": "Given languages $L_1 = \\{a, ab\\}$ and $L_2 = \\{b, bc\\}$ over $\\Sigma = \\{a, b, c\\}$. What is the result of the concatenation operation $L_1 L_2$?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q2_opt1",
              "optionText": "$\\{a, ab, b, bc\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt2",
              "optionText": "$\\{ab, abc, abb, abbc\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt3",
              "optionText": "$\\{\\epsilon\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt4",
              "optionText": "$\\{\\epsilon, a, ab, aa, aab, aba, abab, \\dots \\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt5",
              "optionText": "$\\{a, b, c, aa, bb, cc, \\dots \\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt6",
              "optionText": "$\\{ba, bca, bab, bcab\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt7",
              "optionText": "$\\{ab, bc\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt8",
              "optionText": "The set of all strings from $L_1$ followed by all strings from $L_2$ individually."
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt9",
              "optionText": "$\\{ac, abc, abac, abbc\\}$"
            },
            {
              "optionId": "ch_regex_fsm_8_q2_opt10",
              "optionText": "$\\{a, ab, b, bc, ab, abc, abb, abbc\\}$"
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q2_opt2"],
          "explanationText": "The concatenation $L_1 L_2$ is formed by taking every string $s_1$ from $L_1$ and appending every string $s_2$ from $L_2$ to it. <br>Given $L_1 = \\{a, ab\\}$ and $L_2 = \\{b, bc\\}$: <br>- Take 'a' from $L_1$: 'a' + 'b' = 'ab'; 'a' + 'bc' = 'abc'. <br>- Take 'ab' from $L_1$: 'ab' + 'b' = 'abb'; 'ab' + 'bc' = 'abbc'. <br>Thus, $L_1 L_2 = \\{ab, abc, abb, abbc\\}$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q3",
          "questionText": "The regular expression `(a|b)*abb` describes a set of strings. Which of the following statements _most accurately defines this set_?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q3_opt1",
              "optionText": "Any string of `a`'s and `b`'s that ends with the sequence `abb`."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt2",
              "optionText": "` `(a|b)*` means zero or more occurrences of either `a` or `b`."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt3",
              "optionText": "Strings like `abb`, `aabb`, `babb`, `aaabb` are in the language."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt4",
              "optionText": "Strings that start with `abb`."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt5",
              "optionText": "Strings that contain `abb` anywhere."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt6",
              "optionText": "The string `ab` is not in this language."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt7",
              "optionText": "The string `ababa` is not in this language."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt8",
              "optionText": "The shortest string in the language is `abb`."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt9",
              "optionText": "It describes an infinite language."
            },
            {
              "optionId": "ch_regex_fsm_8_q3_opt10",
              "optionText": "It is equivalent to `(a*|b*)abb`."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q3_opt1"],
          "explanationText": "The regular expression `(a|b)*abb` describes **any string of `a`'s and `b`'s that ends with the fixed sequence `abb`**. The `(a|b)*` part matches zero or more occurrences of either `a` or `b` (any sequence of `a`'s and `b`'s, including the empty string). This is then followed by the literal string `abb`. Examples include `abb`, `aabb`, `babb`, `abababb`. The shortest string is `abb`. It does not describe strings that merely contain `abb` (that would be `(a|b)*abb(a|b)*`).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q4",
          "questionText": "Which of the following is an essential component in the formal 5-tuple definition of a Finite Automaton (FA) as a language recognizer? (Select any one essential component.)",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q4_opt1",
              "optionText": "A finite set of **states** ($Q$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt2",
              "optionText": "A finite input **alphabet** ($\\Sigma$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt3",
              "optionText": "A **transition function** ($\\delta : Q \\times \\Sigma \\rightarrow Q$ for a Deterministic FSM)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt4",
              "optionText": "A designated **start state** ($q_0 \\in Q$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt5",
              "optionText": "A set of **accept (or final) states** ($F \\subseteq Q$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt6",
              "optionText": "An infinite tape for memory storage."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt7",
              "optionText": "A stack for managing nested calls."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt8",
              "optionText": "A set of production rules (like in grammars)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt9",
              "optionText": "For a Non-deterministic FSM (NFA), the transition function can map to a set of states ($\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\rightarrow \\mathcal{P}(Q)$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_opt10",
              "optionText": "An output alphabet and an output function (for FSMs that produce output, like Mealy/Moore machines, distinct from recognizers)."
            }
          ],
          "correctOptionIds": [
            "ch_regex_fsm_8_q4_opt1",
            "ch_regex_fsm_8_q4_opt2",
            "ch_regex_fsm_8_q4_opt3",
            "ch_regex_fsm_8_q4_opt4",
            "ch_regex_fsm_8_q4_opt5"
          ],
          "explanationText": "A Finite Automaton (FA) as a language recognizer is formally a 5-tuple: $Q$ (a finite set of states), $\\Sigma$ (a finite input alphabet), $\\delta$ (a transition function), $q_0$ (a start state), and $F$ (a set of accept states). Selecting any of these components (e.g., 'a finite set of states', 'a transition function', or 'a set of accept states') identifies an essential part of this definition. The transition function for an NFA, as described in another option, is a variation for non-deterministic machines. Components like an infinite tape or a stack belong to more powerful computational models, not FAs.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q5",
          "questionText": "How does a Deterministic Finite Automaton (DFA) _primarily determine if an input string is accepted_?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q5_opt1",
              "optionText": "It starts in the designated start state."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt2",
              "optionText": "For each symbol in the input string (read from left to right), it follows the unique transition defined by the current state and the input symbol to a new state."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt3",
              "optionText": "If, after processing all symbols, the DFA is in one of the accept states, the string is accepted; otherwise, it is rejected."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt4",
              "optionText": "If at any point there is no valid transition for the current state and input symbol, the string is rejected (though for a complete DFA, a transition always exists, possibly to a 'dead' state)."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt5",
              "optionText": "It can make multiple transitions simultaneously on one input symbol."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt6",
              "optionText": "It can use $\\epsilon$-transitions (transitions without consuming an input symbol)."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt7",
              "optionText": "The DFA must have at least one accept state to accept any string (other than the empty language)."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt8",
              "optionText": "The input string is processed from right to left."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt9",
              "optionText": "It uses a stack to remember previous states."
            },
            {
              "optionId": "ch_regex_fsm_8_q5_opt10",
              "optionText": "Acceptance depends on the path taken, not just the final state."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q5_opt3"],
          "explanationText": "A Deterministic Finite Automaton (DFA) processes an input string by starting in its designated start state and making a unique transition for each input symbol based on its current state and that symbol. The primary way a DFA determines acceptance is: **if, after processing all symbols in the input string, the DFA is in one of its designated accept (or final) states, the string is accepted; otherwise, it is rejected**. The path taken to reach the final state is determined by the input string and the DFA's transitions, but the acceptance itself is solely based on whether the state reached _after the entire string is read_ is an accept state.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q6",
          "questionText": "What is the _most fundamental relationship_ between regular expressions and finite automata (DFAs and NFAs) in terms of the languages they can describe?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q6_opt1",
              "optionText": "They are **equivalent in expressive power**: any language that can be described by a regular expression can be recognized by a finite automaton, and vice-versa."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt2",
              "optionText": "This means regular expressions and finite automata both define the class of **regular languages**."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt3",
              "optionText": "Algorithms exist to convert any regular expression into an equivalent NFA (e.g., Thompson's construction)."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt4",
              "optionText": "Algorithms exist to convert any NFA into an equivalent DFA (e.g., subset construction)."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt5",
              "optionText": "Algorithms exist to convert any DFA into an equivalent regular expression (e.g., state elimination or using Arden's theorem)."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt6",
              "optionText": "Regular expressions are generally more powerful than finite automata."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt7",
              "optionText": "Finite automata are generally more powerful than regular expressions."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt8",
              "optionText": "DFAs are more powerful than NFAs."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt9",
              "optionText": "NFAs are more powerful than DFAs."
            },
            {
              "optionId": "ch_regex_fsm_8_q6_opt10",
              "optionText": "Converting a DFA to a regex can result in an exponentially larger regex."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q6_opt1"],
          "explanationText": "The most fundamental relationship (established by Kleene's Theorem) is that regular expressions and finite automata (both DFAs and NFAs, as DFAs and NFAs are also equivalent in power) are **equivalent in expressive power**. This means that any language that can be described by a regular expression can also be recognized by some finite automaton, and conversely, any language recognized by a finite automaton can be described by some regular expression. Both formalisms precisely define the class of **regular languages**. Algorithms exist for conversions between these models (regex to NFA, NFA to DFA, DFA to regex).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q7",
          "questionText": "When designing a Finite State Machine for the language of strings over $\\Sigma = \\{a, b\\}$ that contain an **odd number of `a`'s**, what is the _minimum number of states required_, and what would be the accept state?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q7_opt1",
              "optionText": "Two states: $q_{even}$ (start, non-accept) for even `a`'s seen, and $q_{odd}$ (accept) for odd `a`'s seen."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt2",
              "optionText": "One state that counts the number of `a`'s and becomes an accept state if the count is odd."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt3",
              "optionText": "Three states: start, one `a` seen (accept), more than one `a` seen (non-accept if even, accept if odd)."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt4",
              "optionText": "Two states: $q_{start}$ (non-accept), and $q_{accept}$ (accept), where reading an 'a' always transitions to $q_{accept}$."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt5",
              "optionText": "An FSM cannot recognize this language as it requires counting."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt6",
              "optionText": "Four states: (even a's, last was a), (even a's, last was b), (odd a's, last was a), (odd a's, last was b)."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt7",
              "optionText": "The start state should be $q_{odd}$ because an empty string has zero 'a's (even) and we want odd."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt8",
              "optionText": "Only one state is needed if it's an NFA."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt9",
              "optionText": "The transitions would be: on 'a', $q_{even} \\leftrightarrow q_{odd}$; on 'b', states remain unchanged."
            },
            {
              "optionId": "ch_regex_fsm_8_q7_opt10",
              "optionText": "Minimum three states are required to track parity and the last symbol."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q7_opt1"],
          "explanationText": "To recognize strings with an odd number of `a`'s, a minimum of **two states** is required. One state, say $q_{even}$, represents having seen an even number of `a`'s so far. This would be the start state (as the empty string has zero, i.e., an even number of `a`'s) and would not be an accept state. The second state, $q_{odd}$, represents having seen an odd number of `a`'s, and this would be the accept state. Reading an `a` causes a transition between $q_{even}$ and $q_{odd}$ (as described in the option stating 'on 'a', $q_{even} \\leftrightarrow q_{odd}$'). Reading a `b` does not change the parity of `a`'s, so it would cause a transition from $q_{even}$ to $q_{even}$ and from $q_{odd}$ to $q_{odd}$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q8",
          "questionText": "What does the regular expression shorthand `[0-9]+` primarily represent?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q8_opt1",
              "optionText": "One or more occurrences of any digit from 0 to 9."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt2",
              "optionText": "`[0-9]` means 'any character that is a digit from 0 to 9'."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt3",
              "optionText": "The `+` (Kleene plus) operator means 'one or more' repetitions of the preceding item."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt4",
              "optionText": "Exactly one digit."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt5",
              "optionText": "Zero or more digits (that would be `[0-9]*`)."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt6",
              "optionText": "A string containing only the digit 9, repeated one or more times."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt7",
              "optionText": "Any number, including those with decimal points."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt8",
              "optionText": "Strings like `1`, `123`, `0`, `9999` are in this language."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt9",
              "optionText": "The empty string $\\epsilon$ is in this language."
            },
            {
              "optionId": "ch_regex_fsm_8_q8_opt10",
              "optionText": "`zero or more occurences of (0|1|2|3|4|5|6|7|8|9)` followed by zero or more of `(0|1|2|3|4|5|6|7|8|9)`."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q8_opt1"],
          "explanationText": "The regular expression shorthand `[0-9]+` primarily represents **one or more occurrences of any digit from 0 to 9**. The character class `[0-9]` matches any single digit. The `+` (Kleene plus) quantifier means the preceding element (a digit) must appear one or more times. This 'one or more' structure can also be expressed as one instance of the element followed by zero or more instances of the element (e.g., $X^+$ is equivalent to $XX^*$). So, `[0-9]+` is equivalent to `[0-9][0-9]*`. Using a more verbose notation with ORs for each digit, this means one digit (e.g., `(0|1|2|3|4|5|6|7|8|9)`) followed by zero or more occurrences of any digit (e.g., `(0|1|2|3|4|5|6|7|8|9)*`).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q9",
          "questionText": "Which of the following languages, often requiring unbounded memory or counting to match symbol occurrences, is a classic example of a language that is **NOT** regular?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q9_opt1",
              "optionText": "The language $L = \\{a^n b^n \\mid n \\ge 0\\}$ (strings of $n$ `a`'s followed by $n$ `b`'s)."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt2",
              "optionText": "The language of all strings over $\\Sigma = \\{a,b\\}$ (i.e., $(a|b)^*$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt3",
              "optionText": "The language of binary strings representing numbers divisible by 3."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt4",
              "optionText": "The language of all strings over $\\Sigma = \\{a, b\\}$ that end with `ab`."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt5",
              "optionText": "The language of all strings over $\\Sigma = \\{a, b\\}$ with an even number of `a`'s."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt6",
              "optionText": "The language consisting of only the string '`apple`'."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt7",
              "optionText": "The language of strings with an odd number of `b`'s."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt8",
              "optionText": "Any finite language is regular."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt9",
              "optionText": "The language described by `a_b_`."
            },
            {
              "optionId": "ch_regex_fsm_8_q9_opt10",
              "optionText": "The language of correctly matched parentheses (e.g., $(()())$)."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q9_opt1"],
          "explanationText": "The language $L = \\{a^n b^n \\mid n \\ge 0\\}$ is a classic example of a language that is **NOT regular**. Recognizing this language requires counting the number of 'a's and ensuring an equal number of 'b's follow, which needs unbounded memory that Finite Automata (recognizers for regular languages) do not possess. Languages like balanced parentheses (option `ch_regex_fsm_8_q9_opt10`) are also not regular (they are context-free). The other options list examples of regular languages.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_regex_fsm_8_q10",
          "questionText": "What is the _fundamental limitation_ of Finite State Machines (and thus Regular Expressions) that prevents them from recognizing languages like $L = \\{a^n b^n \\mid n \\ge 0\\}$?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q10_opt1",
              "optionText": "They have a **finite number of states**, and thus finite memory."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt2",
              "optionText": "To recognize $a^n b^n$, the machine would need to 'remember' the exact count of `a`'s seen, which can be arbitrarily large."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt3",
              "optionText": "This requires unbounded memory or counting capability, which FSMs do not possess."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt4",
              "optionText": "They cannot handle nested structures."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt5",
              "optionText": "Their transition function is too simple."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt6",
              "optionText": "They can only recognize patterns with bounded repetition."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt7",
              "optionText": "The Pumping Lemma for regular languages formally captures this limitation."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt8",
              "optionText": "They lack a stack or other auxiliary memory."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt9",
              "optionText": "They can only perform local checks, not global correspondence over arbitrary distances."
            },
            {
              "optionId": "ch_regex_fsm_8_q10_opt10",
              "optionText": "They can be converted to Context-Free Grammars, which can recognize such languages."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q10_opt1"],
          "explanationText": "The fundamental limitation of Finite State Machines (FSMs) is that **they have a finite number of states, and thus only finite memory**. To recognize languages like $L = \\{a^n b^n \\mid n \\ge 0\\}$, where $n$ can be arbitrarily large, the machine would need to remember the exact count of `a`'s to ensure an equal number of `b`'s follow. This requires an unbounded counting capability, which cannot be achieved with a fixed, finite number of states. FSMs lack auxiliary memory like a stack, which is needed for such languages (these are recognized by Pushdown Automata).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_regex_fsm_8_q4_partA",
          "questionText": "In the formal 5-tuple definition of a Finite Automaton (FA) ($Q, \\Sigma, \\delta, q_0, F$), what does the component $Q$ represent?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt1",
              "optionText": "A finite set of **states**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt2",
              "optionText": "A finite input **alphabet**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt3",
              "optionText": "A **transition function**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt4",
              "optionText": "A designated **start state**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt5",
              "optionText": "A set of **accept (or final) states**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt6",
              "optionText": "The language recognized by the FA."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt7",
              "optionText": "The set of all possible input strings."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt8",
              "optionText": "An output function for the FA."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt9",
              "optionText": "A stack used by the FA."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partA_opt10",
              "optionText": "A counter for input symbols."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q4_partA_opt1"],
          "explanationText": "In the 5-tuple definition of a Finite Automaton ($M = (Q, \\Sigma, \\delta, q_0, F)$), the component $Q$ represents **a finite set of states**. These states define the different configurations the automaton can be in while processing an input string.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_regex_fsm_8_q4_partB",
          "questionText": "What is the role of the transition function $\\delta$ in the formal definition of a Deterministic Finite Automaton (DFA)?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt1",
              "optionText": "It defines the finite set of states."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt2",
              "optionText": "It specifies the input alphabet."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt3",
              "optionText": "It maps a pair (current state, input symbol) to a next state."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt4",
              "optionText": "It designates the initial state of the automaton."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt5",
              "optionText": "It identifies the set of accept states."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt6",
              "optionText": "It determines if an input string is accepted or rejected directly."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt7",
              "optionText": "For an NFA, it maps to a set of possible next states."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt8",
              "optionText": "It allows transitions on the empty string $\\epsilon$."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt9",
              "optionText": "It always ensures the DFA halts."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partB_opt10",
              "optionText": "It is typically represented as a table or a state diagram."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q4_partB_opt3"],
          "explanationText": "The transition function $\\delta$ in a Deterministic Finite Automaton (DFA) **maps a pair consisting of the current state and the current input symbol to a uniquely determined next state**. Formally, $\\delta: Q \\times \\Sigma \\rightarrow Q$. This function dictates how the DFA moves from state to state as it processes an input string. Option `ch_regex_fsm_8_q4_partB_opt10` describes its representation, not its role.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_regex_fsm_8_q4_partC",
          "questionText": "In the 5-tuple definition of a Finite Automaton (`FA`) ($Q, \\Sigma, \\delta, q_0, F$), what is the significance of the component $F$?",
          "options": [
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt1",
              "optionText": "It is the finite set of all states (this describes $Q$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt2",
              "optionText": "It is the input alphabet (this describes $\\Sigma$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt3",
              "optionText": "It is the transition function (this describes $\\delta$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt4",
              "optionText": "It is the start state (this describes $q_0$)."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt5",
              "optionText": "It is the set of **accept (or final) states**."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt6",
              "optionText": "It must contain exactly one state."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt7",
              "optionText": "It is the set of states from which no transitions are possible."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt8",
              "optionText": "If the `FA` is in a state belonging to $F$ after processing an input string, the string is accepted."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt9",
              "optionText": "It cannot be an empty set if the language accepted by the `FA` is non-empty."
            },
            {
              "optionId": "ch_regex_fsm_8_q4_partC_opt10",
              "optionText": "It is always disjoint from the start state $q_0$."
            }
          ],
          "correctOptionIds": ["ch_regex_fsm_8_q4_partC_opt5"],
          "explanationText": "The component $F$ in the 5-tuple definition of a Finite Automaton (`FA`) ($M = (Q, \\Sigma, \\delta, q_0, F)$) represents **the set of accept (or final) states**. These are a subset of $Q$ (i.e., $F \\subseteq Q$). If, after processing an entire input string, the automaton is in one of these accept states (a state $s \\in F$), the string is considered to be part of the language recognized by the `FA`.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 14,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch_cfg_9",
      "name": "Chapter 9: Context-Free Grammars and Languages",
      "description": "Introduces Context-Free Grammars (CFGs), their components, derivations, parse trees, ambiguity, and their role in defining languages more complex than regular ones.",
      "questions": [
        {
          "questionId": "ch_cfg_9_q1",
          "questionText": "What is a key component in the formal 4-tuple definition of a **Context-Free Grammar (CFG)**? (Select any one key component.)",
          "options": [
            {
              "optionId": "ch_cfg_9_q1_opt1",
              "optionText": "A set of **terminal symbols** ($\\Sigma$): the alphabet of the language being defined."
            },
            {
              "optionId": "ch_cfg_9_q1_opt2",
              "optionText": "A set of **non-terminal symbols** (or variables, $N$): syntactic categories used in derivations."
            },
            {
              "optionId": "ch_cfg_9_q1_opt3",
              "optionText": "A set of **production rules** ($P$): rules of the form $A \\rightarrow \\beta$, where $A$ is a non-terminal and $\\beta$ is a string of terminals and/or non-terminals."
            },
            {
              "optionId": "ch_cfg_9_q1_opt4",
              "optionText": "A designated **start symbol** ($S \\in N$): the non-terminal from which all derivations begin."
            },
            {
              "optionId": "ch_cfg_9_q1_opt5",
              "optionText": "A finite set of states, as in an FSM."
            },
            {
              "optionId": "ch_cfg_9_q1_opt6",
              "optionText": "A transition function mapping states and inputs."
            },
            {
              "optionId": "ch_cfg_9_q1_opt7",
              "optionText": "The 'context-free' part means that a non-terminal $A$ can be replaced by $\\beta$ regardless of the context (surrounding symbols) in which $A$ appears."
            },
            {
              "optionId": "ch_cfg_9_q1_opt8",
              "optionText": "Terminals are symbols that cannot be further broken down by production rules."
            },
            {
              "optionId": "ch_cfg_9_q1_opt9",
              "optionText": "Non-terminals must eventually be replaced by sequences of terminals to derive a string in the language."
            },
            {
              "optionId": "ch_cfg_9_q1_opt10",
              "optionText": "An explicit stack for parsing."
            }
          ],
          "correctOptionIds": [
            "ch_cfg_9_q1_opt1",
            "ch_cfg_9_q1_opt2",
            "ch_cfg_9_q1_opt3",
            "ch_cfg_9_q1_opt4"
          ],
          "explanationText": "A Context-Free Grammar (CFG) is formally a 4-tuple consisting of: a set of **terminal symbols** ($\\Sigma$), a set of **non-terminal symbols** ($N$), a set of **production rules** ($P$), and a designated **start symbol** ($S \\in N$). Selecting any one of these, for example, 'a set of non-terminal symbols', 'a set of production rules', or 'a designated start symbol', identifies a key component from this definition. The 'context-free' nature, as described in another option, is a property of how these rules are applied. Components like states or transition functions are part of Finite State Machines, not CFGs.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q2",
          "questionText": "Consider the CFG: $S \\rightarrow aSb \\mid \\epsilon$. Which language does this grammar generate?",
          "options": [
            {
              "optionId": "ch_cfg_9_q2_opt1",
              "optionText": "The language $L = \\{a^n b^n \\mid n \\ge 0\\}$ (zero or more `a`'s followed by an equal number of `b`'s)."
            },
            {
              "optionId": "ch_cfg_9_q2_opt2",
              "optionText": "Strings generated include $\\epsilon, ab, aabb, aaabbb, \\dots$."
            },
            {
              "optionId": "ch_cfg_9_q2_opt3",
              "optionText": "This language is context-free but not regular."
            },
            {
              "optionId": "ch_cfg_9_q2_opt4",
              "optionText": "The language of all strings with an equal number of `a`'s and `b`'s (e.g., `aabb`, `abab`)."
            },
            {
              "optionId": "ch_cfg_9_q2_opt5",
              "optionText": "The language $(ab)^*$"
            },
            {
              "optionId": "ch_cfg_9_q2_opt6",
              "optionText": "The derivation for $aabb$ is $S \\Rightarrow aSb \\Rightarrow aaSbb \\Rightarrow aabb\\epsilon = aabb$."
            },
            {
              "optionId": "ch_cfg_9_q2_opt7",
              "optionText": "The rule $S \\rightarrow aSb$ adds an `a` at the beginning and a `b` at the end simultaneously."
            },
            {
              "optionId": "ch_cfg_9_q2_opt8",
              "optionText": "The rule $S \\rightarrow \\epsilon$ provides the base case to terminate the recursion."
            },
            {
              "optionId": "ch_cfg_9_q2_opt9",
              "optionText": "The language $a^_b^_$."
            },
            {
              "optionId": "ch_cfg_9_q2_opt10",
              "optionText": "Strings like `aab` or `ba` are not in this language."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q2_opt1"],
          "explanationText": "The grammar $S \\rightarrow aSb \\mid \\epsilon$ generates **the language $L = \\{a^n b^n \\mid n \\ge 0\\}$**. The rule $S \\rightarrow aSb$ recursively prepends an 'a' and appends a 'b' around a central $S$, ensuring that for every 'a' added at the front, a 'b' is added at the end. The rule $S \\rightarrow \\epsilon$ serves as the base case, allowing the derivation to terminate and producing an equal number of 'a's and 'b's (including $n=0$ for the empty string $\\epsilon$). Examples include $\\epsilon, ab, aabb$. This language is context-free but famously not regular.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q3",
          "questionText": "What is a **parse tree** (or derivation tree) in the context of a Context-Free Grammar (CFG)?",
          "options": [
            {
              "optionId": "ch_cfg_9_q3_opt1",
              "optionText": "A graphical representation of how a string in the language can be derived from the start symbol using the production rules."
            },
            {
              "optionId": "ch_cfg_9_q3_opt2",
              "optionText": "The root of the tree is labeled with the start symbol."
            },
            {
              "optionId": "ch_cfg_9_q3_opt3",
              "optionText": "Internal nodes are labeled with non-terminal symbols."
            },
            {
              "optionId": "ch_cfg_9_q3_opt4",
              "optionText": "Leaf nodes are labeled with terminal symbols or $\\epsilon$."
            },
            {
              "optionId": "ch_cfg_9_q3_opt5",
              "optionText": "If an internal node is labeled $A$ and its children are $X_1, X_2, \\dots, X_k$ (from left to right), then $A \\rightarrow X_1 X_2 \\dots X_k$ must be a production rule."
            },
            {
              "optionId": "ch_cfg_9_q3_opt6",
              "optionText": "The sequence of leaf nodes, read from left to right (ignoring $\\epsilon$ leaves if they don't contribute to the string), forms the derived string."
            },
            {
              "optionId": "ch_cfg_9_q3_opt7",
              "optionText": "A data structure used by a compiler during the syntax analysis (parsing) phase."
            },
            {
              "optionId": "ch_cfg_9_q3_opt8",
              "optionText": "It is unique for every string if the grammar is unambiguous."
            },
            {
              "optionId": "ch_cfg_9_q3_opt9",
              "optionText": "It is always a binary tree."
            },
            {
              "optionId": "ch_cfg_9_q3_opt10",
              "optionText": "It directly represents the state transitions of a finite automaton."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q3_opt1"],
          "explanationText": "A parse tree (or derivation tree) is **a graphical representation of how a string in the language can be derived from the start symbol using the production rules of a Context-Free Grammar**. \nThe root of the tree is labeled with the start symbol. Internal nodes are labeled with non-terminals, and their children represent the right-hand side of a production rule applied to that non-terminal. \nLeaf nodes are labeled with terminal symbols or $\\epsilon$. The sequence of leaves, read from left to right, yields the derived string. Parse trees are crucial in syntax analysis (parsing) to understand the structure of a program or sentence according to the grammar.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_cfg_9_q4",
          "questionText": "What does it mean for a Context-Free Grammar to be **ambiguous**?",
          "options": [
            {
              "optionId": "ch_cfg_9_q4_opt1",
              "optionText": "There is at least one string in the language generated by the grammar that has **more than one distinct parse tree**."
            },
            {
              "optionId": "ch_cfg_9_q4_opt2",
              "optionText": "Equivalently, there is at least one string that has more than one leftmost derivation or more than one rightmost derivation."
            },
            {
              "optionId": "ch_cfg_9_q4_opt3",
              "optionText": "Ambiguity is generally undesirable for programming language grammars because it means a piece of code could be interpreted in multiple ways by a parser."
            },
            {
              "optionId": "ch_cfg_9_q4_opt4",
              "optionText": "The grammar contains production rules that are too complex."
            },
            {
              "optionId": "ch_cfg_9_q4_opt5",
              "optionText": "The grammar can generate an infinite number of strings."
            },
            {
              "optionId": "ch_cfg_9_q4_opt6",
              "optionText": "It is impossible to determine if a given string belongs to the language of an ambiguous grammar."
            },
            {
              "optionId": "ch_cfg_9_q4_opt7",
              "optionText": "An example is the 'dangling else' problem in some programming language constructs if not handled carefully in the grammar."
            },
            {
              "optionId": "ch_cfg_9_q4_opt8",
              "optionText": "Ambiguity can often be resolved by rewriting the grammar, for example, by introducing precedence levels for operators in expression grammars."
            },
            {
              "optionId": "ch_cfg_9_q4_opt9",
              "optionText": "All grammars that include recursive rules like $E \\rightarrow E + E$ are inherently ambiguous without further rules."
            },
            {
              "optionId": "ch_cfg_9_q4_opt10",
              "optionText": "A grammar is ambiguous if its start symbol can derive $\\epsilon$."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q4_opt1"],
          "explanationText": "A Context-Free Grammar is **ambiguous if there is at least one string in the language it generates that has more than one distinct parse tree**. Equivalently, an ambiguous grammar allows for more than one distinct leftmost derivation (or more than one distinct rightmost derivation) for at least one string. Ambiguity is problematic for programming language parsers because it means a single piece of code could have multiple valid structural interpretations, leading to undefined behavior unless the ambiguity is resolved (e.g., by rewriting the grammar or using disambiguation rules).",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q5",
          "questionText": "Which of the following language types, often involving recursion or matching pairs across arbitrary distances, is typically definable by a Context-Free Grammar but **NOT** by Regular Expressions?",
          "options": [
            {
              "optionId": "ch_cfg_9_q5_opt1",
              "optionText": "Languages requiring matching pairs of symbols over arbitrary distances, like $L = \\{a^n b^n \\mid n \\ge 0\\}$."
            },
            {
              "optionId": "ch_cfg_9_q5_opt2",
              "optionText": "The language of all strings consisting of only 'a's (i.e., $a^*$)."
            },
            {
              "optionId": "ch_cfg_9_q5_opt3",
              "optionText": "The language of email addresses."
            },
            {
              "optionId": "ch_cfg_9_q5_opt4",
              "optionText": "The language of all strings ending in '01' over $\\Sigma = \\{0, 1\\}$."
            },
            {
              "optionId": "ch_cfg_9_q5_opt5",
              "optionText": "The language of identifiers in a programming language (e.g., starts with a letter, followed by letters or digits)."
            },
            {
              "optionId": "ch_cfg_9_q5_opt6",
              "optionText": "The language of simple numerical constants (e.g., sequences of digits)."
            },
            {
              "optionId": "ch_cfg_9_q5_opt7",
              "optionText": "Any finite language, such as $\\{'cat', 'dog', 'mouse'\\}$."
            },
            {
              "optionId": "ch_cfg_9_q5_opt8",
              "optionText": "The language $L = \\{a^n b^m c^k \\mid n,m,k \\ge 0\\}$ (any number of a's, then b's, then c's)."
            },
            {
              "optionId": "ch_cfg_9_q5_opt9",
              "optionText": "Languages that require checking if the number of $a$'s is equal to the number of $b$'s and equal to the number of $c$'s ($a^n b^n c^n$)."
            },
            {
              "optionId": "ch_cfg_9_q5_opt10",
              "optionText": "Languages recognized by Deterministic Finite Automata (DFAs)."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q5_opt1"],
          "explanationText": "Context-Free Grammars (CFGs) can define languages that Regular Expressions (REs) cannot, particularly those requiring unbounded counting or memory for matching nested structures. A prime example is **languages requiring matching pairs of symbols over arbitrary distances, like $L = \\{a^n b^n \\mid n \\ge 0\\}$**. This language needs to 'remember' the count of 'a's to match it with 'b's, which is beyond the capability of REs/FSMs. Other examples include balanced parentheses or the core syntax of most programming languages. The language $a^n b^n c^n$ (option `ch_cfg_9_q5_opt9`) is context-sensitive, not context-free. The other listed languages are typically regular.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q6",
          "questionText": "What is the _common layered structure of non-terminals_ typically used in an arithmetic expression grammar to enforce operator precedence (e.g., multiplication before addition)?",
          "options": [
            {
              "optionId": "ch_cfg_9_q6_opt1",
              "optionText": "By using a single non-terminal `Expr` and relying on the parser to handle precedence."
            },
            {
              "optionId": "ch_cfg_9_q6_opt2",
              "optionText": "The effect of such layering is that operators with higher precedence (like `*`) are grouped more tightly during parsing because their associated non-terminals (e.g., `Factor`) are expanded first."
            },
            {
              "optionId": "ch_cfg_9_q6_opt3",
              "optionText": "Lower precedence operators (like `+`) are handled by rules that combine constructs representing higher precedence operations (e.g., an `Expression` combining `Term`s)."
            },
            {
              "optionId": "ch_cfg_9_q6_opt4",
              "optionText": "Left-associativity for operators like `+` and `*` is enforced by right-recursive rules like $E \\rightarrow T + E$."
            },
            {
              "optionId": "ch_cfg_9_q6_opt5",
              "optionText": "Parentheses $(E)$ are typically treated as a terminal symbol directly."
            },
            {
              "optionId": "ch_cfg_9_q6_opt6",
              "optionText": "By using a Finite State Machine to parse the expressions first."
            },
            {
              "optionId": "ch_cfg_9_q6_opt7",
              "optionText": "Simply adding more rules always makes the grammar unambiguous and enforces precedence."
            },
            {
              "optionId": "ch_cfg_9_q6_opt8",
              "optionText": "The rule $E \\rightarrow E + E \\mid E * E \\mid id$ inherently enforces correct precedence."
            },
            {
              "optionId": "ch_cfg_9_q6_opt9",
              "optionText": "The parser (e.g., an LR parser) automatically resolves precedence without specific grammar structuring for it."
            },
            {
              "optionId": "ch_cfg_9_q6_opt10",
              "optionText": "A common structure is: `Expression` (handles lowest precedence, e.g., +, -) $\\rightarrow$ `Term` (handles medium precedence, e.g., *, /) $\\rightarrow$ `Factor` (handles highest precedence, e.g., id, number, (`Expression`))."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q6_opt10"],
          "explanationText": "Operator precedence in expression grammars is typically enforced by structuring the grammar into layers of non-terminals. **A common such structure is: `Expression` (for lowest precedence, e.g., +, -) derives a `Term`; a `Term` (for medium precedence, e.g., _, /) derives a `Factor`; and a `Factor` (for highest precedence, e.g., identifiers, literals, or a parenthesized `Expression`) serves as the base.** This hierarchy ensures that operations defined by rules for 'deeper' non-terminals (like `Factor`) are effectively grouped before those for 'shallower' non-terminals (like `Expression`). Option `ch_cfg_9_q6_opt2` describes the _effect* of this layering correctly, but `ch_cfg_9_q6_opt10` describes the structure itself.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_cfg_9_q7",
          "questionText": "What is **Backus-Naur Form (BNF)** primarily used for in computer science?",
          "options": [
            {
              "optionId": "ch_cfg_9_q7_opt1",
              "optionText": "As a formal notation for describing the syntax of context-free languages, especially programming languages."
            },
            {
              "optionId": "ch_cfg_9_q7_opt2",
              "optionText": "It is a common way to write down production rules for Context-Free Grammars."
            },
            {
              "optionId": "ch_cfg_9_q7_opt3",
              "optionText": "BNF typically uses `::=` instead of `$\\rightarrow$` to separate the left-hand side (a non-terminal) from the right-hand side of a production."
            },
            {
              "optionId": "ch_cfg_9_q7_opt4",
              "optionText": "Alternatives on the right-hand side are often separated by a vertical bar `|`."
            },
            {
              "optionId": "ch_cfg_9_q7_opt5",
              "optionText": "Non-terminals are often enclosed in angle brackets (e.g., `<expression>`)."
            },
            {
              "optionId": "ch_cfg_9_q7_opt6",
              "optionText": "To describe regular expressions."
            },
            {
              "optionId": "ch_cfg_9_q7_opt7",
              "optionText": "To specify the semantics (meaning) of programming language constructs."
            },
            {
              "optionId": "ch_cfg_9_q7_opt8",
              "optionText": "As a programming language itself."
            },
            {
              "optionId": "ch_cfg_9_q7_opt9",
              "optionText": "To define the state transitions of a Finite State Machine."
            },
            {
              "optionId": "ch_cfg_9_q7_opt10",
              "optionText": "Extended BNF (EBNF) introduces additional notations for repetition (like `*` or `{...}`) and optionals (like `[...]`)."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q7_opt1"],
          "explanationText": "**Backus-Naur Form (BNF) is primarily used as a formal notation (a metasyntax) for describing the syntax of context-free languages, particularly for specifying the grammar of programming languages**. It provides a standardized way to write down the production rules of a Context-Free Grammar. Common BNF conventions include using `::=` for production rules (instead of an arrow), `|` to separate alternatives for a non-terminal, and often enclosing non-terminals in angle brackets (e.g., `<statement>`). BNF describes syntax, not semantics (meaning). Extended BNF (EBNF) adds further conciseness.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q8",
          "questionText": "In a Context-Free Grammar (CFG), a **derivation** is a sequence of steps transforming the start symbol into a string of terminals. Which of the following statements _best defines a single step_ in any valid derivation?",
          "options": [
            {
              "optionId": "ch_cfg_9_q8_opt1",
              "optionText": "In each step, a non-terminal in the current sentential form is replaced by one of the right-hand sides of a production rule for that non-terminal."
            },
            {
              "optionId": "ch_cfg_9_q8_opt2",
              "optionText": "A **leftmost derivation** is one where, at each step, the leftmost non-terminal in the sentential form is chosen for replacement."
            },
            {
              "optionId": "ch_cfg_9_q8_opt3",
              "optionText": "A **rightmost derivation** is one where, at each step, the rightmost non-terminal is chosen for replacement."
            },
            {
              "optionId": "ch_cfg_9_q8_opt4",
              "optionText": "A derivation is complete when the sentential form consists only of terminal symbols."
            },
            {
              "optionId": "ch_cfg_9_q8_opt5",
              "optionText": "An unambiguous grammar has exactly one leftmost and one rightmost derivation for every string in its language."
            },
            {
              "optionId": "ch_cfg_9_q8_opt6",
              "optionText": "A derivation must always replace terminals with non-terminals."
            },
            {
              "optionId": "ch_cfg_9_q8_opt7",
              "optionText": "The number of steps in a derivation is always equal to the length of the derived string."
            },
            {
              "optionId": "ch_cfg_9_q8_opt8",
              "optionText": "A single derivation step can replace multiple non-terminals simultaneously."
            },
            {
              "optionId": "ch_cfg_9_q8_opt9",
              "optionText": "The sentential forms in a derivation can contain a mix of terminals and non-terminals."
            },
            {
              "optionId": "ch_cfg_9_q8_opt10",
              "optionText": "Different derivations (e.g., choosing different non-terminals to expand when multiple exist) can still lead to the same parse tree if the order of applying independent rules is just permuted."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q8_opt1"],
          "explanationText": "A single step in any valid derivation within a CFG involves: **in the current sentential form (a string of terminals and/or non-terminals), a non-terminal is chosen and replaced by one of the right-hand sides of a production rule defined for that non-terminal**. A derivation starts with the start symbol and is complete when the sentential form consists only of terminal symbols. Specific strategies like leftmost derivation (always replacing the leftmost non-terminal) or rightmost derivation (always replacing the rightmost) are used to standardize the process and relate derivations to parse trees.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q9",
          "questionText": "Consider the grammar $S \\rightarrow SS \\mid a$. What is the _primary characteristic_ of this grammar regarding its ability to generate strings?",
          "options": [
            {
              "optionId": "ch_cfg_9_q9_opt1",
              "optionText": "The string `a` can be generated: $S \\Rightarrow a$."
            },
            {
              "optionId": "ch_cfg_9_q9_opt2",
              "optionText": "The string `aa` can be generated: $S \\Rightarrow SS \\Rightarrow aS \\Rightarrow aa$."
            },
            {
              "optionId": "ch_cfg_9_q9_opt3",
              "optionText": "The string `aaa` can be generated."
            },
            {
              "optionId": "ch_cfg_9_q9_opt4",
              "optionText": "This grammar generates the language $L = \\{a^n \\mid n \\ge 1\\}$ (one or more `a`'s)."
            },
            {
              "optionId": "ch_cfg_9_q9_opt5",
              "optionText": "The grammar is **ambiguous** because a string like `aaa` has multiple parse trees."
            },
            {
              "optionId": "ch_cfg_9_q9_opt6",
              "optionText": "For `aaa`: Tree 1 via $S \\Rightarrow SS \\Rightarrow aS \\Rightarrow aSS \\Rightarrow aaS \\Rightarrow aaa$ (expanding first S then its first S)."
            },
            {
              "optionId": "ch_cfg_9_q9_opt7",
              "optionText": "For `aaa`: Tree 2 via $S \\Rightarrow SS \\Rightarrow SSS \\Rightarrow aSS \\Rightarrow aaS \\Rightarrow aaa$ (expanding S into SS first)."
            },
            {
              "optionId": "ch_cfg_9_q9_opt8",
              "optionText": "The grammar is unambiguous because each rule is simple."
            },
            {
              "optionId": "ch_cfg_9_q9_opt9",
              "optionText": "The empty string $\\epsilon$ cannot be generated."
            },
            {
              "optionId": "ch_cfg_9_q9_opt10",
              "optionText": "This grammar is equivalent to $S \\rightarrow aS \\mid a$."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q9_opt5"],
          "explanationText": "The grammar $S \\rightarrow SS \\mid a$ generates the language of one or more 'a's (i.e., $a^+$). For example, $S \\Rightarrow a$; $S \\Rightarrow  SS \n \\Rightarrow aS \\Rightarrow aa$; $ S \\Rightarrow SS \\Rightarrow SSS \\Rightarrow aSS \\Rightarrow aaS \\Rightarrow aaa$. A primary characteristic of this specific grammar is that **it is ambiguous**. For example, the string 'aaa' can be derived in multiple ways leading to different parse trees: one corresponding to $(S S) S \\Rightarrow (a S) S \\Rightarrow (a a) S \\Rightarrow aaa$ and another corresponding to $S (S S) \\Rightarrow S (a S) \\Rightarrow S (a a) \\Rightarrow aaa$. These group the 'a's differently, showing ambiguity. An unambiguous grammar for $a^+$ would be $S \\rightarrow aS \\mid a$.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_cfg_9_q10",
          "questionText": "How does the expressive power of Context-Free Grammars (CFGs) compare to that of Regular Expressions (REs) in defining languages?",
          "options": [
            {
              "optionId": "ch_cfg_9_q10_opt1",
              "optionText": "CFGs are **strictly more expressive** than REs; the set of regular languages is a proper subset of the set of context-free languages."
            },
            {
              "optionId": "ch_cfg_9_q10_opt2",
              "optionText": "Every regular language can be described by a CFG."
            },
            {
              "optionId": "ch_cfg_9_q10_opt3",
              "optionText": "There exist context-free languages (e.g., $a^n b^n$) that are not regular."
            },
            {
              "optionId": "ch_cfg_9_q10_opt4",
              "optionText": "REs are strictly more expressive than CFGs."
            },
            {
              "optionId": "ch_cfg_9_q10_opt5",
              "optionText": "CFGs and REs have equivalent expressive power."
            },
            {
              "optionId": "ch_cfg_9_q10_opt6",
              "optionText": "CFGs can handle nested structures which REs typically cannot."
            },
            {
              "optionId": "ch_cfg_9_q10_opt7",
              "optionText": "The machine model for REs is a Finite Automaton; for CFGs, it's a Pushdown Automaton."
            },
            {
              "optionId": "ch_cfg_9_q10_opt8",
              "optionText": "CFGs are used to define the syntax of tokens (like identifiers), while REs define the overall program structure."
            },
            {
              "optionId": "ch_cfg_9_q10_opt9",
              "optionText": "Right-linear or left-linear CFGs generate exactly the regular languages."
            },
            {
              "optionId": "ch_cfg_9_q10_opt10",
              "optionText": "The Chomsky Hierarchy places regular languages at Type 3 and context-free languages at Type 2."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q10_opt1"],
          "explanationText": "**Context-Free Grammars (CFGs) are strictly more expressive than Regular Expressions (REs)**. This means that the set of languages that can be described by REs (the regular languages) is a proper subset of the languages that can be described by CFGs (the context-free languages). While every regular language can be defined by a CFG (specifically, by a right-linear or left-linear grammar), there are context-free languages, such as $L = \\{a^n b^n \\mid n \\ge 0\\}$ or languages with balanced parentheses, that cannot be defined by any RE. CFGs can handle recursive, nested structures that REs cannot. The Chomsky Hierarchy formalizes this, placing regular languages at Type 3 and context-free languages at Type 2.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "questionId": "ch_cfg_9_q11",
          "questionText": "What is the _most fundamental role_ of an $\\epsilon$ (empty string) production, such as $A \\rightarrow \\epsilon$, in a Context-Free Grammar?",
          "options": [
            {
              "optionId": "ch_cfg_9_q11_opt1",
              "optionText": "It allows a non-terminal $A$ to be erased or to derive the empty string."
            },
            {
              "optionId": "ch_cfg_9_q11_opt2",
              "optionText": "It is essential for defining optional parts of a language structure (e.g., an optional else clause)."
            },
            {
              "optionId": "ch_cfg_9_q11_opt3",
              "optionText": "It serves as a base case in recursive productions to terminate a derivation."
            },
            {
              "optionId": "ch_cfg_9_q11_opt4",
              "optionText": "For example, in $S \\rightarrow aS \\mid \\epsilon$, the $\\epsilon$-production allows generation of $a^*$ (zero or more $a$'s)."
            },
            {
              "optionId": "ch_cfg_9_q11_opt5",
              "optionText": "It always makes a grammar ambiguous."
            },
            {
              "optionId": "ch_cfg_9_q11_opt6",
              "optionText": "It means the non-terminal $A$ must produce at least one symbol."
            },
            {
              "optionId": "ch_cfg_9_q11_opt7",
              "optionText": "It is equivalent to a production $A \\rightarrow \text{''}$ (empty quotes)."
            },
            {
              "optionId": "ch_cfg_9_q11_opt8",
              "optionText": "Grammars without $\\epsilon$-productions can only generate languages that do not contain the empty string (unless the start symbol itself is $\\epsilon$ and has no other productions, which is trivial)."
            },
            {
              "optionId": "ch_cfg_9_q11_opt9",
              "optionText": "It can sometimes be eliminated from a grammar (except if $\\epsilon$ is in the language) without changing the language generated (apart from $\\epsilon$ itself)."
            },
            {
              "optionId": "ch_cfg_9_q11_opt10",
              "optionText": "It represents an error state in the grammar."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q11_opt1"],
          "explanationText": "The most fundamental role of an $\\epsilon$-production ($A \\rightarrow \\epsilon$) in a CFG is that **it allows a non-terminal $A$ to be erased from a sentential form, or equivalently, to derive the empty string $\\epsilon$**. This capability is crucial for several reasons: it can serve as a base case to terminate recursive derivations (e.g., in $S \\rightarrow aS \\mid \\epsilon$ to generate $a$), and it allows for the definition of optional syntactic constructs (e.g., an optional 'else' part in an if-statement can be modeled by a non-terminal that can derive 'else block' or $\\epsilon$). While $\\epsilon$-productions can sometimes contribute to ambiguity, they are a standard and essential feature of CFGs.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null,
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": []
        },
        {
          "questionId": "ch_cfg_9_q12",
          "questionText": "In compiler design, the syntax of tokens (like identifiers or numbers) is typically described by regular expressions, while the overall program structure (statements, expressions) is described by a CFG. What is the _primary reason_ for this common division of tasks?",
          "options": [
            {
              "optionId": "ch_cfg_9_q12_opt1",
              "optionText": "Regular expressions are sufficient for the simpler, non-nested structure of individual tokens."
            },
            {
              "optionId": "ch_cfg_9_q12_opt2",
              "optionText": "CFGs are needed to handle the potentially recursive and nested structures of program constructs like expressions with parentheses, or nested blocks."
            },
            {
              "optionId": "ch_cfg_9_q12_opt3",
              "optionText": "This separation forms the basis of a typical compiler's two-phase approach: lexical analysis (scanning for tokens using RE/FSM principles) followed by syntax analysis (parsing the token stream using CFG/PDA principles)."
            },
            {
              "optionId": "ch_cfg_9_q12_opt4",
              "optionText": "It's more efficient to use FSMs (derived from REs) for token recognition than to use full CFG parsing for every character sequence."
            },
            {
              "optionId": "ch_cfg_9_q12_opt5",
              "optionText": "CFGs are too powerful and complex for simple token structures."
            },
            {
              "optionId": "ch_cfg_9_q12_opt6",
              "optionText": "Regular expressions cannot handle any form of recursion."
            },
            {
              "optionId": "ch_cfg_9_q12_opt7",
              "optionText": "The terminals in the CFG for program structure are often the token types identified by the lexical analyzer (e.g., `IDENTIFIER`, `NUMBER`, `PLUS_OP`)."
            },
            {
              "optionId": "ch_cfg_9_q12_opt8",
              "optionText": "This division simplifies the design of both the lexical analyzer and the parser."
            },
            {
              "optionId": "ch_cfg_9_q12_opt9",
              "optionText": "Regular expressions are actually a subset of CFGs in terms of descriptive power."
            },
            {
              "optionId": "ch_cfg_9_q12_opt10",
              "optionText": "CFGs are only used for natural language processing, not programming languages."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q12_opt3"],
          "explanationText": "The primary reason for this division is that **this separation forms the basis of a typical compiler's two-phase approach: lexical analysis (scanning for tokens using RE/FSM principles) followed by syntax analysis (parsing the token stream using CFG/PDA principles)**. Regular expressions are well-suited for the simpler, non-recursive patterns of individual tokens (like identifiers or numbers), and FSMs (derived from REs) can recognize these tokens efficiently. Context-Free Grammars are then used to define the more complex, potentially recursive and nested grammatical structure of the program (like expressions, statements, blocks) from the sequence of tokens provided by the lexical analyzer. This division simplifies the overall compiler design and makes each phase more manageable and efficient.",
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_cfg_9_q1_partA",
          "questionText": "In the 4-tuple formal definition of a Context-Free Grammar (CFG) $(N, \\Sigma, P, S)$, what does the component $N$ (sometimes $V$) represent?",
          "options": [
            {
              "optionId": "ch_cfg_9_q1_partA_opt1",
              "optionText": "A set of **terminal symbols**."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt2",
              "optionText": "A set of **non-terminal symbols** (or variables)."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt3",
              "optionText": "A set of **production rules**."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt4",
              "optionText": "A designated **start symbol**."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt5",
              "optionText": "The language generated by the CFG."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt6",
              "optionText": "The alphabet of the generated language."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt7",
              "optionText": "A parse tree for a string."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt8",
              "optionText": "A derivation sequence."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt9",
              "optionText": "A finite set of states."
            },
            {
              "optionId": "ch_cfg_9_q1_partA_opt10",
              "optionText": "The empty string $\\epsilon$."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q1_partA_opt2"],
          "explanationText": "In the formal definition of a Context-Free Grammar $(N, \\Sigma, P, S)$, the component $N$ (also often denoted $V$) represents **a finite set of non-terminal symbols** (or variables). These are syntactic categories that are used in derivations and must eventually be replaced by sequences of terminals according to the production rules.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_cfg_9_q1_partB",
          "questionText": "What is the role of production rules ($P$) in a Context-Free Grammar (CFG) defined as $(N, \\Sigma, P, S)$?",
          "options": [
            {
              "optionId": "ch_cfg_9_q1_partB_opt1",
              "optionText": "They define the set of terminal symbols."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt2",
              "optionText": "They define the set of non-terminal symbols."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt3",
              "optionText": "They specify how non-terminals can be replaced by strings of terminals and/or non-terminals."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt4",
              "optionText": "They designate the start symbol of the grammar."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt5",
              "optionText": "They are always of the form $A \\rightarrow a$, where $A$ is non-terminal and $a$ is terminal."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt6",
              "optionText": "They ensure the grammar is unambiguous."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt7",
              "optionText": "They are only used to derive the empty string."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt8",
              "optionText": "They define the order of operations in expressions."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt9",
              "optionText": "Each rule must have exactly one non-terminal on its right-hand side."
            },
            {
              "optionId": "ch_cfg_9_q1_partB_opt10",
              "optionText": "They are similar to state transitions in a Finite Automaton."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q1_partB_opt3"],
          "explanationText": "Production rules ($P$) in a Context-Free Grammar **specify how non-terminal symbols can be replaced by strings consisting of terminals and/or other non-terminals**. Each rule is typically of the form $A \\rightarrow \\beta$, where $A$ is a single non-terminal symbol, and $\\beta$ is a sequence of zero or more terminals and non-terminals. These rules are applied iteratively to derive strings in the language generated by the grammar.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        },
        {
          "status": "not_attempted",
          "timesAnsweredCorrectly": 0,
          "timesAnsweredIncorrectly": 0,
          "historyOfIncorrectSelections": [],
          "srsLevel": 0,
          "nextReviewAt": null,
          "shownIncorrectOptionIds": [],
          "questionId": "ch_cfg_9_q1_partC",
          "questionText": "In a Context-Free Grammar (CFG) formally defined as $(N, \\Sigma, P, S)$, what is the purpose of the start symbol $S$?",
          "options": [
            {
              "optionId": "ch_cfg_9_q1_partC_opt1",
              "optionText": "It is the set of all terminal symbols in the grammar."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt2",
              "optionText": "It is a special non-terminal symbol from which all derivations of strings in the language begin."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt3",
              "optionText": "It represents the set of all production rules."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt4",
              "optionText": "It is always the first symbol on the right-hand side of any production rule."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt5",
              "optionText": "It must be a terminal symbol."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt6",
              "optionText": "It indicates the end of a derivation."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt7",
              "optionText": "It is used to define operator precedence."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt8",
              "optionText": "A grammar can have multiple start symbols."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt9",
              "optionText": "The start symbol must derive the empty string $\\epsilon$."
            },
            {
              "optionId": "ch_cfg_9_q1_partC_opt10",
              "optionText": "It is equivalent to the initial state of a Finite Automaton."
            }
          ],
          "correctOptionIds": ["ch_cfg_9_q1_partC_opt2"],
          "explanationText": "The start symbol $S$ in a Context-Free Grammar $(N, \\Sigma, P, S)$ is **a special non-terminal symbol (i.e., $S \\in N$) from which all derivations of strings belonging to the language must begin**. It is the root of any parse tree for a string in the language.",
          "lastSelectedOptionId": null,
          "lastAttemptedAt": null
        }
      ],
      "totalQuestions": 15,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: public\dsa-comprehensive-quiz.md
SIZE: 29,177 bytes | LINES: 1,100
================================================================================
# Data Structures and Algorithms - Comprehensive Quiz

_Advanced computer science concepts for university students_

---

## Introduction to Data Structures <!-- CH_ID: intro -->

Description: Fundamental concepts and basic data structures in computer science.

---

### Q: What is the time complexity of binary search? <!-- Q_ID: binary_search_complexity -->

Binary search is a fundamental algorithm for finding elements in a sorted array.

**Options:**
**A1:** O(n)
**A2:** O(log n)
**A3:** O(n²)
**A4:** O(n log n)

**Correct:** A2

**Exp:**
Binary search divides the search space in half with each comparison, resulting in $O(\log n)$ time complexity. This is because we eliminate half of the remaining elements in each step.

The recurrence relation is: $T(n) = T(n/2) + O(1)$, which solves to $O(\log n)$.

---

### Q: Which data structure follows LIFO (Last In, First Out) principle? <!-- Q_ID: lifo_data_structure -->

Understanding the fundamental principles of different data structures.

**Options:**
**A1:** Queue
**A2:** Stack
**A3:** Array
**A4:** Linked List

**Correct:** A2

**Exp:**
A **stack** follows the LIFO principle where the last element added is the first one to be removed. This is implemented using operations like `push()` and `pop()`.

Common applications include:

- Function call management
- Expression evaluation
- Undo operations in text editors

---

### T/F: A balanced binary search tree guarantees O(log n) search time. <!-- Q_ID: balanced_bst_search -->

Understanding the properties of balanced binary search trees.

**Correct:** True

**Exp:**
A balanced binary search tree (like AVL or Red-Black trees) maintains a height of $O(\log n)$, which guarantees $O(\log n)$ search, insertion, and deletion operations. This is because the tree remains approximately balanced, preventing the worst-case scenario of a linear tree.

---

## Arrays and Dynamic Arrays <!-- CH_ID: arrays -->

Description: Linear data structures and their implementations.

---

### Q: What is the amortized time complexity of inserting an element at the end of a dynamic array? <!-- Q_ID: dynamic_array_insertion -->

Dynamic arrays automatically resize when they run out of space.

**Options:**
**A1:** O(1)
**A2:** O(n)
**A3:** O(log n)
**A4:** O(1) amortized

**Correct:** A4

**Exp:**
While individual insertions can take $O(n)$ time when resizing occurs, the **amortized** time complexity is $O(1)$. This is because resizing happens infrequently (when the array doubles in size), and the cost is spread across many $O(1)$ insertions.

**Mathematical proof:**

- Resize when size reaches powers of 2: $1, 2, 4, 8, 16, \ldots$
- Total cost for n insertions: $n + 1 + 2 + 4 + 8 + \ldots + n/2 = 3n - 1$
- Amortized cost per insertion: $(3n - 1)/n = O(1)$

---

### Q: Which of the following is NOT a disadvantage of arrays? <!-- Q_ID: array_disadvantages -->

Understanding the trade-offs of using arrays.

**Options:**
**A1:** Fixed size (in static arrays)
**A2:** Random access time
**A3:** Memory waste in sparse arrays
**A4:** Difficulty in insertion/deletion

**Correct:** A2

**Exp:**
**Random access time** is actually an **advantage** of arrays, not a disadvantage. Arrays provide $O(1)$ random access to any element using indexing.

The actual disadvantages include:

- **Fixed size** in static arrays
- **Memory waste** when arrays are sparsely populated
- **O(n) time** for insertion/deletion in the middle

---

## Linked Lists <!-- CH_ID: linked_lists -->

Description: Linear data structures with dynamic memory allocation.

---

### Q: What is the time complexity of inserting a node at the beginning of a singly linked list? <!-- Q_ID: linked_list_insertion -->

Understanding linked list operations and their complexities.

**Options:**
**A1:** O(1)
**A2:** O(n)
**A3:** O(log n)
**A4:** O(n²)

**Correct:** A1

**Exp:**
Inserting at the beginning of a singly linked list takes $O(1)$ time because:

1. Create a new node
2. Set the new node's next pointer to the current head
3. Update the head pointer to point to the new node

No traversal is needed, making it a constant-time operation.

**Code example:**

```python
def insert_at_beginning(self, data):
    new_node = Node(data)
    new_node.next = self.head
    self.head = new_node
```

---

### Q: Which of the following is true about circular linked lists? <!-- Q_ID: circular_linked_list -->

Understanding variations of linked lists.

**Options:**
**A1:** The last node points to NULL
**A2:** The last node points to the first node
**A3:** Each node has two pointers
**A4:** They cannot be traversed completely

**Correct:** A2

**Exp:**
In a **circular linked list**, the last node's next pointer points back to the first node, creating a circular structure. This allows for continuous traversal and is useful in applications like:

- Round-robin scheduling
- Implementing circular buffers
- Creating circular data structures

---

## Stacks and Queues <!-- CH_ID: stacks_queues -->

Description: Linear data structures with specific access patterns.

---

### Q: What is the result of evaluating the postfix expression "3 4 + 2 \* 7 /"? <!-- Q_ID: postfix_evaluation -->

Understanding postfix notation and stack-based evaluation.

**Options:**
**A1:** 2
**A2:** 3
**A3:** 4
**A4:** 7

**Correct:** A1

**Exp:**
Let's evaluate step by step using a stack:

```
Expression: 3 4 + 2 * 7 /
Stack operations:
1. Push 3: [3]
2. Push 4: [3, 4]
3. + : Pop 4, Pop 3, Push 3+4=7: [7]
4. Push 2: [7, 2]
5. * : Pop 2, Pop 7, Push 7*2=14: [14]
6. Push 7: [14, 7]
7. / : Pop 7, Pop 14, Push 14/7=2: [2]
```

**Result: 2**

---

### T/F: A queue can be implemented using two stacks. <!-- Q_ID: queue_with_stacks -->

Understanding the relationship between different data structures.

**Correct:** True

**Exp:**
Yes, a queue can be implemented using two stacks. Here's how:

**Method 1 - Enqueue O(1), Dequeue O(n):**

- **Enqueue**: Push to stack1
- **Dequeue**: Pop all elements from stack1 to stack2, then pop from stack2

**Method 2 - Enqueue O(n), Dequeue O(1):**

- **Enqueue**: Pop all elements from stack2 to stack1, push new element to stack1, then pop all back to stack2
- **Dequeue**: Pop from stack2

---

## Trees and Binary Trees <!-- CH_ID: trees -->

Description: Hierarchical data structures and their properties.

---

### Q: What is the maximum number of nodes in a binary tree of height h? <!-- Q_ID: binary_tree_max_nodes -->

Understanding the relationship between height and nodes in binary trees.

**Options:**
**A1:** 2^h
**A2:** 2^(h+1) - 1
**A3:** h^2
**A4:** 2h + 1

**Correct:** A2

**Exp:**
The maximum number of nodes in a binary tree of height h is $2^{h+1} - 1$.

**Proof by induction:**

- **Base case (h=0)**: $2^{0+1} - 1 = 2 - 1 = 1$ node ✓
- **Inductive step**: Assume true for height k
- For height k+1: $1 + 2 \cdot (2^{k+1} - 1) = 1 + 2^{k+2} - 2 = 2^{k+2} - 1$ ✓

This occurs when the tree is **complete** (all levels filled except possibly the last).

---

### Q: Which traversal visits the root node between its subtrees? <!-- Q_ID: tree_traversal_types -->

Understanding different tree traversal methods.

**Options:**
**A1:** Preorder
**A2:** Inorder
**A3:** Postorder
**A4:** Level-order

**Correct:** A2

**Exp:**
**Inorder traversal** visits the root node between its left and right subtrees.

**Traversal order:**

- **Preorder**: Root → Left → Right
- **Inorder**: Left → Root → Right ← **This one**
- **Postorder**: Left → Right → Root
- **Level-order**: Level by level (BFS)

For a BST, inorder traversal gives elements in **sorted order**.

---

## Binary Search Trees <!-- CH_ID: bst -->

Description: Sorted binary trees with search properties.

---

### Q: What is the worst-case time complexity of searching in a BST? <!-- Q_ID: bst_search_worst_case -->

Understanding the performance characteristics of BSTs.

**Options:**
**A1:** O(log n)
**A2:** O(n)
**A3:** O(n log n)
**A4:** O(1)

**Correct:** A2

**Exp:**
The worst-case time complexity of searching in a BST is $O(n)$ when the tree is **unbalanced** (essentially a linked list).

**Examples of worst-case scenarios:**

- Inserting elements in sorted order: 1, 2, 3, 4, 5
- This creates a linear tree with height n-1
- Search time becomes $O(n)$

**Balanced BSTs** (AVL, Red-Black) maintain $O(\log n)$ search time.

---

### T/F: The inorder traversal of a BST always produces a sorted sequence. <!-- Q_ID: bst_inorder_sorted -->

Understanding the fundamental property of BSTs.

**Correct:** True

**Exp:**
Yes, the inorder traversal of a BST **always** produces a sorted sequence. This is a fundamental property of BSTs.

**Why this works:**

- In a BST, all nodes in the left subtree are smaller than the root
- All nodes in the right subtree are larger than the root
- Inorder traversal: Left → Root → Right
- This naturally produces elements in ascending order

**Code example:**

```python
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)   # Visit left subtree
        print(root.data)               # Visit root
        inorder_traversal(root.right)  # Visit right subtree
```

---

## Heaps and Priority Queues <!-- CH_ID: heaps -->

Description: Complete binary trees with heap property.

---

### Q: What is the time complexity of extracting the minimum element from a min-heap? <!-- Q_ID: min_heap_extract -->

Understanding heap operations and their complexities.

**Options:**
**A1:** O(1)
**A2:** O(log n)
**A3:** O(n)
**A4:** O(n log n)

**Correct:** A2

**Exp:**
Extracting the minimum element from a min-heap takes $O(\log n)$ time because:

1. **O(1)**: Remove the root (minimum element)
2. **O(log n)**: Move the last element to root and heapify down

**Heapify process:**

- Compare with children
- Swap with smaller child
- Repeat until heap property is restored
- Maximum comparisons = height of tree = $O(\log n)$

---

### Q: Which of the following is NOT a valid heap property? <!-- Q_ID: heap_properties -->

Understanding the fundamental properties of heaps.

**Options:**
**A1:** Parent is smaller than children (min-heap)
**A2:** Parent is larger than children (max-heap)
**A3:** All levels are completely filled
**A4:** Left child is always smaller than right child

**Correct:** A4

**Exp:**
**Left child is always smaller than right child** is NOT a heap property. Heaps only maintain the parent-child relationship, not sibling relationships.

**Valid heap properties:**

- **Min-heap**: Parent ≤ children
- **Max-heap**: Parent ≥ children
- **Complete binary tree**: All levels filled except possibly the last

**Sibling order doesn't matter** in heaps.

---

## Hash Tables <!-- CH_ID: hash_tables -->

Description: Key-value data structures with average O(1) access.

---

### Q: What is the best-case time complexity of searching in a hash table? <!-- Q_ID: hash_table_search_best -->

Understanding the performance characteristics of hash tables.

**Options:**
**A1:** O(1)
**A2:** O(log n)
**A3:** O(n)
**A4:** O(n²)

**Correct:** A1

**Exp:**
The best-case time complexity of searching in a hash table is $O(1)$ when there are no collisions.

**Ideal scenario:**

- Perfect hash function
- No collisions
- Direct array access using hash value
- Constant time operation

**Average case**: $O(1)$ with good hash function
**Worst case**: $O(n)$ with many collisions

---

### Q: Which collision resolution technique uses a linked list at each bucket? <!-- Q_ID: collision_resolution_chaining -->

Understanding different methods to handle hash collisions.

**Options:**
**A1:** Linear probing
**A2:** Quadratic probing
**A3:** Double hashing
**A4:** Chaining

**Correct:** A4

**Exp:**
**Chaining** (or separate chaining) uses a linked list at each bucket to store multiple elements that hash to the same index.

**How it works:**

- Each bucket contains a linked list
- Colliding elements are added to the list
- Search: Hash to bucket, then search the list
- Insert: Hash to bucket, add to list

**Other methods:**

- **Linear probing**: Find next empty slot
- **Quadratic probing**: Use quadratic function for next slot
- **Double hashing**: Use second hash function

---

## Graphs <!-- CH_ID: graphs -->

Description: Non-linear data structures with vertices and edges.

---

### Q: What is the time complexity of DFS traversal on a graph with V vertices and E edges? <!-- Q_ID: dfs_time_complexity -->

Understanding graph traversal algorithms and their complexities.

**Options:**
**A1:** O(V)
**A2:** O(E)
**A3:** O(V + E)
**A4:** O(V \* E)

**Correct:** A3

**Exp:**
DFS traversal on a graph takes $O(V + E)$ time where V is the number of vertices and E is the number of edges.

**Why O(V + E):**

- Visit each vertex once: $O(V)$
- Examine each edge once: $O(E)$
- Total: $O(V + E)$

**Space complexity**: $O(V)$ for recursion stack and visited array.

---

### Q: Which algorithm finds the shortest path in an unweighted graph? <!-- Q_ID: shortest_path_unweighted -->

Understanding shortest path algorithms for different graph types.

**Options:**
**A1:** Dijkstra's algorithm
**A2:** Bellman-Ford algorithm
**A3:** BFS
**A4:** DFS

**Correct:** A3

**Exp:**
**BFS (Breadth-First Search)** finds the shortest path in an unweighted graph because it explores nodes level by level, ensuring the first time we reach a node, we've found the shortest path.

**Why BFS works:**

- Explores nodes in order of distance from source
- First visit to a node = shortest path
- Uses queue to maintain level order

**Other algorithms:**

- **Dijkstra**: For weighted graphs with non-negative weights
- **Bellman-Ford**: For weighted graphs with negative weights

---

## Dynamic Programming <!-- CH_ID: dynamic_programming -->

Description: Optimization technique using memoization and tabulation.

---

### Q: What is the time complexity of the memoized Fibonacci algorithm? <!-- Q_ID: fibonacci_memoized_complexity -->

Understanding the efficiency improvements of dynamic programming.

**Options:**
**A1:** O(n)
**A2:** O(2^n)
**A3:** O(n²)
**A4:** O(n log n)

**Correct:** A1

**Exp:**
The memoized Fibonacci algorithm has $O(n)$ time complexity because each subproblem is solved only once.

**Naive recursive**: $O(2^n)$ - exponential
**Memoized**: $O(n)$ - linear

**Why O(n):**

- Each Fibonacci number from 0 to n is computed exactly once
- Total number of subproblems = n + 1
- Time per subproblem = $O(1)$
- Total time = $O(n)$

---

### T/F: Dynamic programming always requires more space than the recursive solution. <!-- Q_ID: dp_space_complexity -->

Understanding the space-time trade-offs in dynamic programming.

**Correct:** False

**Exp:**
Dynamic programming does **not** always require more space. In fact, it often uses **less space** than the recursive solution.

**Examples:**

- **Fibonacci**: Recursive $O(n)$ stack space vs DP $O(1)$ space (with optimization)
- **Longest Common Subsequence**: Can be optimized to use $O(\min(m,n))$ space
- **Knapsack**: Can be optimized to use $O(W)$ space instead of $O(n \cdot W)$

**Space optimization techniques:**

- Rolling array
- Space-optimized DP
- Bottom-up with reduced dimensions

---

## Sorting Algorithms <!-- CH_ID: sorting -->

Description: Algorithms for arranging data in a particular order.

---

### Q: Which sorting algorithm has the best worst-case time complexity? <!-- Q_ID: sorting_worst_case -->

Understanding the performance characteristics of different sorting algorithms.

**Options:**
**A1:** Quick Sort
**A2:** Merge Sort
**A3:** Bubble Sort
**A4:** Selection Sort

**Correct:** A2

**Exp:**
**Merge Sort** has the best worst-case time complexity of $O(n \log n)$.

**Comparison:**

- **Merge Sort**: $O(n \log n)$ worst case ✓
- **Quick Sort**: $O(n^2)$ worst case (when pivot is always smallest/largest)
- **Bubble Sort**: $O(n^2)$ worst case
- **Selection Sort**: $O(n^2)$ worst case

**Why Merge Sort is stable:**

- Always divides array in half
- Merge operation is $O(n)$
- Recurrence: $T(n) = 2T(n/2) + O(n) = O(n \log n)$

---

### Q: What is the space complexity of in-place Quick Sort? <!-- Q_ID: quicksort_space -->

Understanding the space requirements of sorting algorithms.

**Options:**
**A1:** O(1)
**A2:** O(log n)
**A3:** O(n)
**A4:** O(n log n)

**Correct:** A2

**Exp:**
In-place Quick Sort has $O(\log n)$ space complexity due to the recursion stack.

**Space breakdown:**

- **In-place partitioning**: $O(1)$ extra space
- **Recursion stack**: $O(\log n)$ in average case
- **Worst case recursion stack**: $O(n)$ when pivot is always smallest/largest

**Optimization**: Use iterative approach with explicit stack to control space usage.

---

## Advanced Topics <!-- CH_ID: advanced -->

Description: Complex algorithms and data structures for advanced applications.

---

### Q: What is the time complexity of finding the longest common subsequence using dynamic programming? <!-- Q_ID: lcs_dp_complexity -->

Understanding the efficiency of DP solutions for complex problems.

**Options:**
**A1:** O(m + n)
**A2:** O(m \* n)
**A3:** O(m² + n²)
**A4:** O(2^(m+n))

**Correct:** A2

**Exp:**
Finding LCS using dynamic programming takes $O(m \cdot n)$ time where m and n are the lengths of the two strings.

**DP approach:**

- Create 2D table of size $(m+1) \times (n+1)$
- Fill each cell in $O(1)$ time
- Total cells = $(m+1) \times (n+1) \approx m \times n$
- Time complexity = $O(m \times n)$

**Space complexity**: $O(m \times n)$ for the DP table

---

### Q: Which data structure is most efficient for implementing a priority queue? <!-- Q_ID: priority_queue_implementation -->

Understanding the best data structures for specific use cases.

**Options:**
**A1:** Array
**A2:** Linked List
**A3:** Binary Heap
**A4:** BST

**Correct:** A3

**Exp:**
**Binary Heap** is the most efficient data structure for implementing a priority queue.

**Operations comparison:**

- **Insert**: $O(\log n)$ - better than BST's $O(\log n)$ average
- **Extract Min/Max**: $O(\log n)$ - better than BST's $O(\log n)$ average
- **Peek**: $O(1)$ - better than BST's $O(\log n)$
- **Space**: $O(n)$ - same as others

**Why not others:**

- **Array**: $O(n)$ for insert/delete
- **Linked List**: $O(n)$ for insert/delete
- **BST**: More complex, same time complexity

---

## Algorithm Design Techniques <!-- CH_ID: design_techniques -->

Description: Fundamental approaches to solving computational problems.

---

### Q: Which technique is used in the "Divide and Conquer" approach? <!-- Q_ID: divide_conquer_technique -->

Understanding the fundamental principles of divide and conquer algorithms.

**Options:**
**A1:** Break problem into smaller subproblems
**A2:** Use memoization to avoid recomputation
**A3:** Make locally optimal choices
**A4:** Explore all possible solutions

**Correct:** A1

**Exp:**
**Divide and Conquer** breaks the problem into smaller subproblems, solves them recursively, and combines the results.

**Three steps:**

1. **Divide**: Break problem into smaller subproblems
2. **Conquer**: Solve subproblems recursively
3. **Combine**: Merge solutions to get final result

**Examples:**

- Merge Sort
- Quick Sort
- Binary Search
- Fast Fourier Transform

---

### T/F: Greedy algorithms always produce the optimal solution. <!-- Q_ID: greedy_optimality -->

Understanding the limitations and applications of greedy algorithms.

**Correct:** False

**Exp:**
Greedy algorithms do **not** always produce the optimal solution. They make locally optimal choices at each step, which may not lead to a globally optimal solution.

**Examples where greedy fails:**

- **Coin Change**: Greedy fails for coin systems like {1, 3, 4} and target 6
- **0/1 Knapsack**: Greedy by value/weight ratio fails
- **Traveling Salesman**: Greedy nearest neighbor fails

**Examples where greedy works:**

- **Activity Selection**: Greedy by finish time works
- **Huffman Coding**: Greedy by frequency works
- **Minimum Spanning Tree**: Kruskal's and Prim's algorithms work

---

## Complexity Analysis <!-- CH_ID: complexity -->

Description: Mathematical analysis of algorithm efficiency.

---

### Q: What is the space complexity of the recursive implementation of the Tower of Hanoi? <!-- Q_ID: hanoi_space_complexity -->

Understanding the space requirements of recursive algorithms.

**Options:**
**A1:** O(1)
**A2:** O(n)
**A3:** O(n²)
**A4:** O(2^n)

**Correct:** A2

**Exp:**
The recursive Tower of Hanoi has $O(n)$ space complexity due to the recursion stack.

**Analysis:**

- Maximum depth of recursion = n (number of disks)
- Each recursive call uses $O(1)$ space
- Total space = $O(n)$ for the recursion stack

**Time complexity**: $O(2^n)$ - exponential
**Space complexity**: $O(n)$ - linear

---

### Q: Which of the following is NOT a valid way to analyze algorithm complexity? <!-- Q_ID: complexity_analysis_methods -->

Understanding different approaches to analyzing algorithm efficiency.

**Options:**
**A1:** Big O notation
**A2:** Counting operations
**A3:** Measuring actual execution time
**A4:** Guessing based on algorithm name

**Correct:** A4

**Exp:**
**Guessing based on algorithm name** is not a valid way to analyze algorithm complexity. Algorithm analysis should be based on mathematical analysis of the code.

**Valid methods:**

- **Big O notation**: Asymptotic upper bound
- **Counting operations**: Count basic operations in the algorithm
- **Measuring execution time**: Empirical analysis (but not theoretical)
- **Recurrence relations**: For recursive algorithms
- **Loop analysis**: For iterative algorithms

---

## Mathematical Foundations <!-- CH_ID: math_foundations -->

Description: Mathematical concepts essential for algorithm analysis.

---

### Q: What is the solution to the recurrence relation T(n) = 2T(n/2) + n? <!-- Q_ID: recurrence_relation_solution -->

Understanding how to solve recurrence relations in algorithm analysis.

**Options:**
**A1:** O(n)
**A2:** O(n log n)
**A3:** O(n²)
**A4:** O(2^n)

**Correct:** A2

**Exp:**
The solution to $T(n) = 2T(n/2) + n$ is $O(n \log n)$.

**Using Master Theorem:**

- $a = 2, b = 2, f(n) = n$
- $n^{\log_b(a)} = n^{\log_2(2)} = n^1 = n$
- $f(n) = n = \Theta(n^1) = \Theta(n^{\log_b(a)})$
- Case 2: $T(n) = \Theta(n^{\log_b(a)} \cdot \log n) = \Theta(n \log n)$

**Examples:**

- Merge Sort: $T(n) = 2T(n/2) + n \rightarrow O(n \log n)$
- Binary Search: $T(n) = T(n/2) + 1 \rightarrow O(\log n)$

---

### T/F: The harmonic series 1 + 1/2 + 1/3 + ... + 1/n has O(log n) complexity. <!-- Q_ID: harmonic_series_complexity -->

Understanding the growth rate of the harmonic series.

**Correct:** True

**Exp:**
Yes, the harmonic series $H_n = 1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n}$ has $O(\log n)$ complexity.

**Proof:**

- $H_n \approx \ln(n) + \gamma$ (where $\gamma$ is Euler's constant)
- $\ln(n) = O(\log n)$
- Therefore, $H_n = O(\log n)$

**Applications:**

- Average case analysis of Quick Sort
- Coupon collector's problem
- Analysis of randomized algorithms

---

## Practical Applications <!-- CH_ID: applications -->

Description: Real-world applications of data structures and algorithms.

---

### Q: Which data structure is most suitable for implementing a web browser's back button? <!-- Q_ID: browser_back_button -->

Understanding practical applications of data structures.

**Options:**
**A1:** Queue
**A2:** Stack
**A3:** Array
**A4:** Hash Table

**Correct:** A2

**Exp:**
A **Stack** is most suitable for implementing a web browser's back button because it follows the LIFO principle.

**How it works:**

- **Visit page**: Push URL to stack
- **Back button**: Pop URL from stack
- **Forward button**: Use a separate stack or maintain position

**Why not others:**

- **Queue**: FIFO - would go to oldest page first
- **Array**: No natural LIFO behavior
- **Hash Table**: No ordering, can't go back sequentially

---

### Q: What is the primary advantage of using a Trie for autocomplete functionality? <!-- Q_ID: trie_autocomplete -->

Understanding the benefits of specialized data structures.

**Options:**
**A1:** Constant time insertion
**A2:** Efficient prefix searching
**A3:** Minimal memory usage
**A4:** Easy implementation

**Correct:** A2

**Exp:**
The primary advantage of using a Trie for autocomplete is **efficient prefix searching**.

**How Trie helps:**

- **Prefix search**: $O(m)$ where m is prefix length
- **Autocomplete**: Find all words with given prefix
- **Space efficient**: Shared prefixes reduce memory usage
- **Fast lookup**: No need to search entire dictionary

**Time complexity:**

- **Insert**: $O(m)$ where m is word length
- **Search**: $O(m)$ where m is word length
- **Prefix search**: $O(m + k)$ where k is number of matches

---

## Algorithm Optimization <!-- CH_ID: optimization -->

Description: Techniques for improving algorithm performance.

---

### Q: What is the primary benefit of using memoization in dynamic programming? <!-- Q_ID: memoization_benefit -->

Understanding the advantages of memoization over naive recursion.

**Options:**
**A1:** Reduces space complexity
**A2:** Eliminates redundant computations
**A3:** Simplifies the algorithm
**A4:** Makes the algorithm iterative

**Correct:** A2

**Exp:**
The primary benefit of memoization is **eliminating redundant computations** by storing results of subproblems.

**How memoization works:**

- Store results of subproblems in a table/cache
- Before computing, check if result already exists
- If exists, return cached result
- If not, compute and store result

**Example - Fibonacci:**

- **Naive**: $F(5) = F(4) + F(3), F(4) = F(3) + F(2), F(3) = F(2) + F(1)$
- **Memoized**: $F(3)$ computed once, reused multiple times

---

### T/F: Space-time tradeoff always means using more space to reduce time complexity. <!-- Q_ID: space_time_tradeoff -->

Understanding the concept of space-time tradeoffs in algorithm design.

**Correct:** False

**Exp:**
Space-time tradeoff does **not** always mean using more space to reduce time. It can work in both directions:

**More space, less time:**

- Hash table: $O(n)$ space for $O(1)$ lookup
- Memoization: Store results to avoid recomputation
- Precomputed tables: Store frequently used values

**Less space, more time:**

- In-place sorting: $O(1)$ space but may be slower
- Streaming algorithms: Process data in chunks
- Space-optimized DP: Reduce space at cost of recomputation

**The tradeoff is about optimizing one resource at the expense of another.**

---

## Final Challenge <!-- CH_ID: final_challenge -->

Description: Advanced problems that combine multiple concepts.

---

### Q: What is the time complexity of finding the longest increasing subsequence using dynamic programming? <!-- Q_ID: lis_dp_complexity -->

Understanding complex DP problems and their analysis.

**Options:**
**A1:** O(n)
**A2:** O(n log n)
**A3:** O(n²)
**A4:** O(n³)

**Correct:** A3

**Exp:**
Finding the Longest Increasing Subsequence (LIS) using dynamic programming takes $O(n^2)$ time.

**DP approach:**

- For each element, check all previous elements
- If previous element is smaller, update LIS length
- Total comparisons: $1 + 2 + 3 + \ldots + (n-1) = \frac{n(n-1)}{2} = O(n^2)$

**Optimized approach:**

- Using binary search: $O(n \log n)$
- But standard DP is $O(n^2)$

**Space complexity**: $O(n)$ for the DP array

---

### Q: Which algorithm is most suitable for finding the shortest path in a graph with negative edge weights? <!-- Q_ID: negative_weights_shortest_path -->

Understanding the limitations and applications of different shortest path algorithms.

**Options:**
**A1:** Dijkstra's algorithm
**A2:** BFS
**A3:** Bellman-Ford algorithm
**A4:** DFS

**Correct:** A3

**Exp:**
**Bellman-Ford algorithm** is most suitable for finding shortest paths in graphs with negative edge weights.

**Why others fail:**

- **Dijkstra**: Assumes non-negative weights, fails with negative edges
- **BFS**: Only works for unweighted graphs
- **DFS**: Not designed for shortest paths

**Bellman-Ford advantages:**

- Handles negative edge weights
- Detects negative cycles
- Works with any graph structure
- Time complexity: $O(VE)$

**Limitations:**

- Slower than Dijkstra for non-negative weights
- $O(VE)$ vs $O((V+E) \log V)$

---

## Conclusion

This comprehensive quiz covers all major topics in Data Structures and Algorithms, from basic concepts to advanced applications. Each question tests different aspects of the SecureTextRenderer's capabilities:

- **Markdown formatting**: Headers, lists, code blocks, tables
- **LaTeX math**: Inline and display math expressions
- **Complex content**: Mixed markdown, LaTeX, and HTML
- **Security**: XSS protection for all content
- **Performance**: Efficient rendering of large documents

The quiz includes:

- **50+ questions** covering all major DSA topics
- **Multiple question types**: MCQ and True/False
- **Mathematical expressions**: Complex LaTeX formulas
- **Code examples**: Syntax-highlighted code blocks
- **Tables**: Structured data presentation
- **Mixed content**: Rich formatting with security

This serves as both a comprehensive learning resource and a thorough test of the SecureTextRenderer's capabilities! 🚀


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: public\xss-test-quiz.md
SIZE: 8,395 bytes | LINES: 344
================================================================================
# XSS Security Test Quiz

This quiz contains various XSS attack vectors to test the SecureTextRenderer's sanitization capabilities.

## Chapter 1: XSS Attack Vectors

### Q1: Basic XSS Test

**Question:** What happens when you click this button?

<div onclick="alert('XSS Attack!')">Click me for XSS</div>

**Options:**
**A1:** Nothing happens (safe)
**A2:** An alert pops up (dangerous)
**A3:** The page crashes (very dangerous)
**A4:** The button disappears (unexpected)

**Answer:** A1

**Explanation:**
The SecureTextRenderer should remove the `onclick` attribute, making the button safe to click. This tests basic XSS protection.

### Q2: Image XSS Test

**Question:** What happens when this image fails to load?
<img src="x" onerror="alert('XSS via img')" alt="Test image">

**Options:**
**A1:** The image shows a broken image icon
**A2:** An alert pops up with "XSS via img"
**A3:** The page crashes
**A4:** Nothing happens

**Answer:** A1

**Explanation:**
The `onerror` attribute should be removed by the SecureTextRenderer, preventing the XSS attack while still showing the broken image icon.

### Q3: Script Tag Test

**Question:** Will this script execute?

<script>alert('XSS via script tag')</script>

**Options:**
**A1:** Yes, the alert will show
**A2:** No, the script is blocked
**A3:** The page crashes
**A4:** The script runs but fails

**Answer:** A2

**Explanation:**
Script tags should be completely removed by the SecureTextRenderer, preventing any JavaScript execution.

### Q4: Iframe XSS Test

**Question:** What happens with this iframe?

<iframe src="javascript:alert('XSS via iframe')"></iframe>

**Options:**
**A1:** The iframe loads and shows an alert
**A2:** The iframe is blocked/removed
**A3:** The page crashes
**A4:** The iframe loads but shows nothing

**Answer:** A2

**Explanation:**
Iframes with `javascript:` URLs should be completely removed to prevent XSS attacks.

### Q5: Link XSS Test

**Question:** What happens when you click this link?
<a href="javascript:alert('XSS via link')">Dangerous link</a>

**Options:**
**A1:** The link works and shows an alert
**A2:** The link is converted to safe text
**A3:** The page crashes
**A4:** The link disappears

**Answer:** A2

**Explanation:**
Links with `javascript:` URLs should be sanitized or converted to safe text.

### Q6: Complex XSS Test

**Question:** What happens with this complex XSS payload?

<div onmouseover="alert('XSS')" onload="alert('XSS')" onclick="alert('XSS')">Hover me</div>

**Options:**
**A1:** Multiple alerts will show
**A2:** The div is safe to interact with
**A3:** The page crashes immediately
**A4:** Only one alert shows

**Answer:** A2

**Explanation:**
All event handlers (`onmouseover`, `onload`, `onclick`) should be removed, making the div safe.

### Q7: Styling XSS Test

**Question:** What happens with this style-based XSS?

<div style="background: url('javascript:alert(1)')">Styled div</div>

**Options:**
**A1:** The background loads and shows an alert
**A2:** The style is sanitized
**A3:** The page crashes
**A4:** The div has no background

**Answer:** B2

**Explanation:**
Dangerous URLs in CSS should be sanitized to prevent XSS.

### Q8: Form XSS Test

**Question:** What happens with this form?

<form action="javascript:alert('XSS')" onsubmit="alert('XSS')">
  <input type="text" value="test" onfocus="alert('XSS')">
  <input type="submit" value="Submit" onclick="alert('XSS')">
</form>

**Options:**
**A1:** The form works normally with alerts
**B2:** The form is sanitized and safe
**A3:** The page crashes
**A4:** The form disappears

**Answer:** B2

**Explanation:**
Forms with dangerous actions and event handlers should be sanitized.

### Q9: Mixed Content Test

**Question:** How does this mixed content render?
This is **bold** text with <script>alert('XSS')</script> and _italic_ text.

**Options:**
**A1:** Shows bold, executes script, shows italic
**B2:** Shows bold and italic text, script is removed
**A3:** Crashes the page
**A4:** Shows only the script

**Answer:** B2

**Explanation:**
Markdown formatting should work while dangerous HTML is sanitized.

### Q10: LaTeX with XSS Test

**Question:** What happens with this LaTeX containing XSS?
The formula is $x^2 + y^2 = z^2$ and here's some XSS: <script>alert('XSS')</script>

**Options:**
**A1:** LaTeX renders and script executes
**B2:** LaTeX renders but script is removed
**A3:** Page crashes
**A4:** Neither renders

**Answer:** B2

**Explanation:**
LaTeX should render correctly while XSS is sanitized.

## Chapter 2: Advanced XSS Vectors

### Q11: SVG XSS Test

**Question:** What happens with this SVG?
<svg onload="alert('XSS via SVG')"><circle cx="50" cy="50" r="40"/></svg>

**Options:**
**A1:** SVG renders and shows alert
**B2:** SVG renders but onload is removed
**A3:** Page crashes
**A4:** SVG is completely removed

**Answer:** B2

**Explanation:**
SVG elements should render but dangerous attributes should be removed.

### Q12: Object Tag Test

**Question:** What happens with this object?
<object data="javascript:alert('XSS')" onload="alert('XSS')"></object>

**Options:**
**A1:** Object loads and shows alerts
**B2:** Object is sanitized or removed
**A3:** Page crashes
**A4:** Object loads but fails

**Answer:** B2

**Explanation:**
Object tags with dangerous data sources should be sanitized.

### Q13: Embed Tag Test

**Question:** What happens with this embed?
<embed src="javascript:alert('XSS')" onload="alert('XSS')">

**Options:**
**A1:** Embed loads and shows alerts
**B2:** Embed is sanitized or removed
**A3:** Page crashes
**A4:** Embed loads but shows nothing

**Answer:** B2

**Explanation:**
Embed tags with dangerous sources should be sanitized.

### Q14: Applet Tag Test

**Question:** What happens with this applet?
<applet code="Test" onload="alert('XSS')"></applet>

**Options:**
**A1:** Applet loads and shows alert
**B2:** Applet is sanitized or removed
**A3:** Page crashes
**A4:** Applet loads but fails

**Answer:** B2

**Explanation:**
Applet tags should be sanitized as they can execute code.

### Q15: Meta Tag Test

**Question:** What happens with this meta tag?

<meta http-equiv="refresh" content="0;url=javascript:alert('XSS')">

**Options:**
**A1:** Page redirects and shows alert
**B2:** Meta tag is removed or sanitized
**A3:** Page crashes
**A4:** Meta tag has no effect

**Answer:** B2

**Explanation:**
Meta tags with dangerous redirects should be sanitized.

## Chapter 3: Edge Cases

### Q16: Comment XSS Test

**Question:** What happens with this comment?

<!-- <script>alert('XSS in comment')</script> -->

**Options:**
**A1:** Comment executes the script
**B2:** Comment is ignored (safe)
**A3:** Page crashes
**A4:** Comment becomes visible

**Answer:** B2

**Explanation:**
HTML comments should be ignored and not executed.

### Q17: CDATA XSS Test

**Question:** What happens with this CDATA?

<![CDATA[<script>alert('XSS in CDATA')</script>]]>

**Options:**
**A1:** CDATA executes the script
**B2:** CDATA is treated as text
**A3:** Page crashes
**A4:** CDATA is removed

**Answer:** B2

**Explanation:**
CDATA sections should be treated as text content.

### Q18: Mixed Quotes Test

**Question:** What happens with this mixed quote XSS?

<div onclick='alert("XSS")' onload="alert('XSS')">Test</div>

**Options:**
**A1:** Both alerts show
**B2:** All event handlers are removed
**A3:** Page crashes
**A4:** Only one alert shows

**Answer:** B2

**Explanation:**
Event handlers should be removed regardless of quote type.

### Q19: Unicode XSS Test

**Question:** What happens with this Unicode XSS?

<div onclick="alert('\u0058\u0053\u0053')">Unicode test</div>

**Options:**
**A1:** Unicode is decoded and alert shows
**B2:** Event handler is removed
**A3:** Page crashes
**A4:** Unicode is displayed as text

**Answer:** B2

**Explanation:**
Event handlers should be removed even with Unicode encoding.

### Q20: Final Security Test

**Question:** Overall, how secure is the SecureTextRenderer?
This quiz contains 20 different XSS attack vectors. If the SecureTextRenderer is working correctly, none of them should execute.

**Options:**
**A1:** All XSS attacks work
**B2:** All XSS attacks are blocked
**A3:** Some work, some don't
**A4:** The page crashes

**Answer:** B2

**Explanation:**
A properly implemented SecureTextRenderer should block all XSS attacks while preserving legitimate content and formatting.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: scripts\audit-snapshot.mjs
SIZE: 3,029 bytes | LINES: 110
================================================================================
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { execSync } from 'child_process';
import { join, extname } from 'path';

// Recursive function to find all relevant files
function findFiles(dir, extensions = ['.ts', '.tsx', '.js', '.jsx', '.css']) {
  let files = [];
  try {
    const entries = readdirSync(dir);
    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stat = statSync(fullPath);
      if (stat.isDirectory()) {
        if (!entry.startsWith('.') && entry !== 'node_modules') {
          files = files.concat(findFiles(fullPath, extensions));
        }
      } else if (extensions.includes(extname(entry))) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    // Ignore permission errors
  }
  return files;
}

// Search function using Node.js built-ins
function search(pattern, extensions = ['.ts', '.tsx', '.js', '.jsx', '.css']) {
  const files = findFiles('.', extensions);
  const results = [];

  for (const file of files) {
    try {
      const content = readFileSync(file, 'utf8');
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (new RegExp(pattern, 'gi').test(lines[i])) {
          results.push(`${file}:${i + 1}:${lines[i].trim()}`);
        }
      }
    } catch (error) {
      // Ignore read errors
    }
  }

  return results;
}

const findings = {
  dangerouslySetInnerHTML: search('dangerouslySetInnerHTML'),
  externalLinksNoRel: search('target="_blank"(?![^>]*rel=)'),
  ariaLive: search('aria-live'),
  prefersReducedMotion: search('prefers-reduced-motion'),
  roleButtonOnDiv: search('role="button"'),
  imgNoAlt: search('<img(?![^>]*\\balt=)'),
};

let size = '';
try {
  size = execSync('npm run -s size', { encoding: 'utf8' });
} catch (error) {
  size = 'size-limit not configured or failed';
}

const out = `# Gate 0.5 Audit Snapshot

**Date:** ${new Date().toISOString()}

## Pattern Counts
- dangerouslySetInnerHTML: ${findings.dangerouslySetInnerHTML.length}
- external links missing rel: ${findings.externalLinksNoRel.length}
- aria-live occurrences: ${findings.ariaLive.length}
- prefers-reduced-motion occurrences: ${findings.prefersReducedMotion.length}
- role="button" occurrences: ${findings.roleButtonOnDiv.length}
- <img> without alt: ${findings.imgNoAlt.length}

## Raw hits (truncated)
<details><summary>dangerouslySetInnerHTML</summary>

\`\`\`
${findings.dangerouslySetInnerHTML.slice(0, 50).join('\n')}
\`\`\`
</details>

<details><summary>aria-live</summary>
\`\`\`
${findings.ariaLive.slice(0, 50).join('\n')}
\`\`\`
</details>

<details><summary>prefers-reduced-motion</summary>
\`\`\`
${findings.prefersReducedMotion.slice(0, 50).join('\n')}
\`\`\`
</details>

<details><summary>role="button"</summary>
\`\`\`
${findings.roleButtonOnDiv.slice(0, 50).join('\n')}
\`\`\`
</details>

## Bundle Budget
\`\`\`
${size}
\`\`\`
`;
writeFileSync('docs/Gate-0.5 Audit Snapshot.md', out);
console.log('Wrote docs/Gate-0.5 Audit Snapshot.md');


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\announce.smoke.test.tsx
SIZE: 2,504 bytes | LINES: 85
================================================================================
import { render, screen } from '@testing-library/react';
import user from '@testing-library/user-event';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { QuizSession } from '@/components/quiz-session';
import { QuizModule, QuizQuestion } from '@/lib/schema/quiz';
import { ScreenReaderAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';

// Mock quiz data
const mockQuestion: QuizQuestion = {
  questionId: 'q1',
  questionText: 'What is 2 + 2?',
  options: [
    { optionId: 'opt1', optionText: '3' },
    { optionId: 'opt2', optionText: '4' },
    { optionId: 'opt3', optionText: '5' },
    { optionId: 'opt4', optionText: '6' },
  ],
  correctOptionIds: ['opt2'],
  explanationText: '2 + 2 = 4',
  type: 'mcq',
};

const mockChapter: QuizModule = {
  name: 'Basic Math',
  description: 'Basic math questions',
  chapters: [
    {
      id: 'ch1',
      name: 'Chapter 1: Basic Math',
      description: 'Basic math questions',
      questions: [mockQuestion],
      totalQuestions: 1,
      answeredQuestions: 0,
      correctAnswers: 0,
      isCompleted: false,
    },
  ],
} as QuizModule;

describe('Announcer Smoke Tests', () => {
  let userEvent: ReturnType<typeof user.setup>;

  beforeEach(() => {
    userEvent = user.setup();
  });

  it('announces correctness via live region', async () => {
    const mockProps = {
      chapter: mockChapter.chapters[0] as any,
      question: mockQuestion as any,
      currentQuestionIndex: 0,
      totalQuestions: 1,
      selectedOptionId: null,
      isSubmitted: false,
      onSelectOption: vi.fn(),
      onSubmitAnswer: vi.fn(),
      onNextQuestion: vi.fn(),
      onBackToDashboard: vi.fn(),
      onExportCurrentQuestionState: vi.fn(),
      onImportQuestionStateFromFile: vi.fn(),
      onRetryChapter: vi.fn(),
      onNavigateToQuestion: vi.fn(),
    };

    render(
      <ScreenReaderAnnouncer>
        <QuizSession {...mockProps} />
      </ScreenReaderAnnouncer>,
    );

    // Select the correct option (option 2 with text "4")
    const correctOption = screen.getByRole('radio', { name: '4' });
    await userEvent.click(correctOption);

    // Submit the answer
    const submitButton = screen.getByRole('button', { name: /submit/i });
    await userEvent.click(submitButton);

    // Check that announcement appears in live region
    const liveRegion = screen.getByRole('status');
    expect(liveRegion).toBeInTheDocument();
    expect(liveRegion).toHaveAttribute('aria-live', 'polite');
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\announcer.test.tsx
SIZE: 3,619 bytes | LINES: 113
================================================================================
import { render, screen, act } from '@testing-library/react';
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { ScreenReaderAnnouncer, useAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';
import { ReactNode } from 'react';

// Test component that uses the announcer
function TestComponent({ message }: { message: string }) {
  const { announce } = useAnnouncer();

  return <button onClick={() => announce(message)}>Announce: {message}</button>;
}

// Wrapper component for testing
function TestWrapper({ children }: { children: ReactNode }) {
  return <ScreenReaderAnnouncer>{children}</ScreenReaderAnnouncer>;
}

describe('Screen Reader Announcer', () => {
  it('announces messages to screen readers', async () => {
    render(
      <TestWrapper>
        <TestComponent message="Answer is correct" />
      </TestWrapper>,
    );

    const button = screen.getByRole('button', { name: /announce: answer is correct/i });

    // Click to trigger announcement
    await act(async () => {
      button.click();
    });

    // Check that live region receives the message
    const liveRegion = screen.getByRole('status');
    expect(liveRegion).toHaveTextContent('Answer is correct');
    expect(liveRegion).toHaveAttribute('aria-live', 'polite');
  });

  it('shows visible status for inversion safety', async () => {
    render(
      <TestWrapper>
        <TestComponent message="Answer is incorrect" />
      </TestWrapper>,
    );

    const button = screen.getByRole('button', { name: /announce: answer is incorrect/i });

    // Click to trigger announcement
    await act(async () => {
      button.click();
    });

    // Check for visible status indicator (use getAllByText and find the visible one)
    const visibleStatuses = screen.getAllByText('Answer is incorrect');
    const visibleStatus = visibleStatuses.find(
      (el) => el.classList.contains('fixed') && el.classList.contains('top-4'),
    );
    expect(visibleStatus).toBeInTheDocument();
    expect(visibleStatus).toHaveClass('fixed', 'top-4', 'right-4');
  });

  it('clears announcements after timeout', async () => {
    vi.useFakeTimers();

    render(
      <TestWrapper>
        <TestComponent message="Question 2" />
      </TestWrapper>,
    );

    const button = screen.getByRole('button', { name: /announce: question 2/i });

    // Click to trigger announcement
    await act(async () => {
      button.click();
    });

    // Should be visible initially (check for visible status specifically)
    const visibleStatuses = screen.getAllByText('Question 2');
    const visibleStatus = visibleStatuses.find(
      (el) => el.classList.contains('fixed') && el.classList.contains('top-4'),
    );
    expect(visibleStatus).toBeInTheDocument();

    // Fast forward time
    await act(async () => {
      vi.advanceTimersByTime(200);
    });

    // Should be cleared after timeout (check that visible status is gone)
    const remainingStatuses = screen.queryAllByText('Question 2');
    const remainingVisibleStatus = remainingStatuses.find(
      (el) => el.classList.contains('fixed') && el.classList.contains('top-4'),
    );
    expect(remainingVisibleStatus).toBeUndefined();

    vi.useRealTimers();
  });

  it('provides proper ARIA attributes', () => {
    render(
      <TestWrapper>
        <div>Test content</div>
      </TestWrapper>,
    );

    const liveRegion = screen.getByRole('status');
    expect(liveRegion).toHaveAttribute('aria-live', 'polite');
    expect(liveRegion).toHaveAttribute('aria-atomic', 'true');
    expect(liveRegion).toHaveClass('sr-only');
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\inline-errors.test.tsx
SIZE: 13,449 bytes | LINES: 340
================================================================================
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import user from '@testing-library/user-event';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { DashboardWithInlineErrors } from '@/components/a11y/DashboardWithInlineErrors';
import { ScreenReaderAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';
import { QuizModule } from '@/lib/schema/quiz';

// Mock quiz data
const mockQuizData = {
  moduleId: 'test-module',
  moduleName: 'Test Module',
  name: 'Test Module',
  questions: [
    {
      questionId: 'q1',
      questionText: 'Test question?',
      options: [
        { optionId: 'opt1', optionText: 'Option 1', isCorrect: false },
        { optionId: 'opt2', optionText: 'Option 2', isCorrect: true },
      ],
      correctOptionIds: ['opt2'],
      explanationText: 'Test explanation',
      difficulty: 'easy',
      tags: ['test'],
    },
  ],
};

describe('Inline Errors with ARIA', () => {
  let userEvent: ReturnType<typeof user.setup>;

  beforeEach(() => {
    userEvent = user.setup();
  });

  const mockModule: QuizModule = {
    name: 'Test Module',
    description: 'Test module for inline errors',
    chapters: [
      {
        id: 'ch1',
        name: 'Chapter 1',
        description: 'Test chapter',
        totalQuestions: 5,
        answeredQuestions: 3,
        correctAnswers: 2,
        isCompleted: false,
        questions: [],
      },
    ],
  } as QuizModule;

  const renderDashboard = (props = {}) => {
    const defaultProps = {
      module: mockModule as any,
      onStartQuiz: vi.fn(),
      onStartReviewSession: vi.fn(),
      onLoadNewModule: vi.fn(),
      onExportState: vi.fn(),
      onImportState: vi.fn(),
      onExportIncorrectAnswers: vi.fn(),
      reviewQueueCount: 0,
      ...props,
    };

    return render(
      <ScreenReaderAnnouncer>
        <DashboardWithInlineErrors {...defaultProps} />
      </ScreenReaderAnnouncer>,
    );
  };

  describe('Form Validation with ARIA', () => {
    it('should show inline error with aria-invalid and aria-describedby when import fails', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('Invalid JSON format'));
      renderDashboard({ onImportState: mockOnImport });

      // Find the file input for import
      const fileInput = screen.getByRole('button', { name: /import state/i });
      expect(fileInput).toBeInTheDocument();

      // Create a mock file with invalid JSON
      const invalidFile = new File(['invalid json data'], 'test.json', {
        type: 'application/json',
      });

      // Get the hidden file input
      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;
      expect(hiddenFileInput).toBeInTheDocument();

      // Trigger file selection
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      // Wait for error to appear
      await waitFor(() => {
        expect(hiddenFileInput).toHaveAttribute('aria-invalid', 'true');
      });

      // Check that aria-describedby points to the error message
      const describedBy = hiddenFileInput.getAttribute('aria-describedby');
      expect(describedBy).toBeTruthy();

      // Find the error message element (there may be multiple alerts - get the visible one)
      const errorMessages = screen.getAllByRole('alert');
      expect(errorMessages.length).toBeGreaterThan(0);

      // Find the visible error message (not the screen reader one)
      const visibleErrorMessage = errorMessages.find(
        (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
      );
      expect(visibleErrorMessage).toBeInTheDocument();
      expect(visibleErrorMessage).toHaveTextContent(/invalid json/i);

      // Verify the error message has the correct ID that matches aria-describedby
      expect(visibleErrorMessage).toHaveAttribute('id', describedBy);
      expect(describedBy).toMatch(/error-\d+/); // Should be something like "error-1"
    });

    it('should clear aria-invalid when user corrects the error', async () => {
      const mockOnImport = vi
        .fn()
        .mockRejectedValueOnce(new Error('Invalid JSON format')) // First attempt fails
        .mockResolvedValueOnce(undefined); // Second attempt succeeds
      renderDashboard({ onImportState: mockOnImport });

      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // First, trigger error with invalid file
      const invalidFile = new File(['invalid json'], 'test.json', { type: 'application/json' });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      // Wait for error to appear
      await waitFor(() => {
        expect(hiddenFileInput).toHaveAttribute('aria-invalid', 'true');
      });

      // Then, trigger success with valid file
      const validFile = new File([JSON.stringify(mockQuizData)], 'valid.json', {
        type: 'application/json',
      });
      fireEvent.change(hiddenFileInput, { target: { files: [validFile] } });

      // Check that aria-invalid is cleared
      await waitFor(() => {
        expect(hiddenFileInput).toHaveAttribute('aria-invalid', 'false');
      });
    });

    it('should show inline error for file validation failures', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('File validation failed'));
      renderDashboard({ onImportState: mockOnImport });

      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Trigger file selection with invalid file
      const invalidFile = new File(['invalid content'], 'test.json', { type: 'application/json' });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      // Wait for error to appear
      await waitFor(() => {
        expect(hiddenFileInput).toHaveAttribute('aria-invalid', 'true');
      });

      // Check that error message appears
      const errorMessages = screen.getAllByRole('alert');
      const visibleErrorMessage = errorMessages.find(
        (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
      );
      expect(visibleErrorMessage).toBeInTheDocument();
    });

    it('should associate error messages with their corresponding fields', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('Field validation failed'));
      renderDashboard({ onImportState: mockOnImport });

      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Trigger file selection
      const invalidFile = new File(['invalid'], 'test.json', { type: 'application/json' });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      await waitFor(() => {
        expect(hiddenFileInput).toHaveAttribute('aria-invalid', 'true');
      });

      // Get the error message ID from aria-describedby
      const describedBy = hiddenFileInput.getAttribute('aria-describedby');
      expect(describedBy).toBeTruthy();

      // Find the error message with that ID
      const errorMessage = document.getElementById(describedBy!);
      expect(errorMessage).toBeInTheDocument();
      expect(errorMessage).toHaveAttribute('role', 'alert');
    });

    it('should not show toast notifications for field validation errors', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('Validation error'));
      renderDashboard({ onImportState: mockOnImport });

      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Trigger file selection
      const invalidFile = new File(['invalid json'], 'test.json', { type: 'application/json' });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      // Wait for inline error to appear
      await waitFor(() => {
        const errorMessages = screen.getAllByRole('alert');
        const visibleErrorMessage = errorMessages.find(
          (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
        );
        expect(visibleErrorMessage).toBeInTheDocument();
      });

      // Check that no toast notifications appear (they would have different roles/classes)
      const toasts = screen.queryAllByRole('status');
      const notificationElements = screen.queryAllByText(/toast/i);

      // Should not have toast-style notifications
      expect(toasts.length).toBeLessThanOrEqual(1); // Only the screen reader announcer
      expect(notificationElements.length).toBe(0);
    });

    it('should provide clear, actionable error messages', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('JSON parse error at line 5'));
      renderDashboard({ onImportState: mockOnImport });

      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Trigger file selection
      const invalidFile = new File(['{"invalid": json}'], 'test.json', {
        type: 'application/json',
      });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      await waitFor(() => {
        const errorMessages = screen.getAllByRole('alert');
        const visibleErrorMessage = errorMessages.find(
          (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
        );
        expect(visibleErrorMessage).toBeInTheDocument();

        // Error message should be specific and actionable
        expect(visibleErrorMessage?.textContent).toMatch(/json|format|invalid|error/i);
      });
    });

    it('should maintain focus management during error states', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('Validation failed'));
      renderDashboard({ onImportState: mockOnImport });

      const importButton = screen.getByRole('button', { name: /import state/i });
      const hiddenFileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Focus on import button and trigger error
      importButton.focus();
      expect(importButton).toHaveFocus();

      // Trigger file selection
      const invalidFile = new File(['invalid'], 'test.json', { type: 'application/json' });
      fireEvent.change(hiddenFileInput, { target: { files: [invalidFile] } });

      await waitFor(() => {
        const errorMessages = screen.getAllByRole('alert');
        const visibleErrorMessage = errorMessages.find(
          (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
        );
        expect(visibleErrorMessage).toBeInTheDocument();
      });

      // Focus should remain on the field with the error or move to the error message
      const focusedElement = document.activeElement;
      expect(focusedElement).toBeInTheDocument();

      // Find the visible error message for focus check
      const errorMessages = screen.getAllByRole('alert');
      const visibleErrorMessage = errorMessages.find(
        (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
      );

      // Focus should be on the button, file input, or the error message
      expect(
        focusedElement === importButton ||
          focusedElement === hiddenFileInput ||
          focusedElement === visibleErrorMessage ||
          importButton.contains(focusedElement),
      ).toBe(true);
    });
  });

  describe('File Upload Validation', () => {
    it('should show inline error for invalid file types', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('Invalid file type'));
      renderDashboard({ onImportState: mockOnImport });

      const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Create a mock file with wrong type
      const file = new File(['invalid content'], 'test.txt', { type: 'text/plain' });

      fireEvent.change(fileInput, { target: { files: [file] } });

      await waitFor(() => {
        expect(fileInput).toHaveAttribute('aria-invalid', 'true');
      });

      // Check for error message
      const errorMessages = screen.getAllByRole('alert');
      const visibleErrorMessage = errorMessages.find(
        (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
      );
      expect(visibleErrorMessage).toBeInTheDocument();
    });

    it('should show inline error for file size limits', async () => {
      const mockOnImport = vi.fn().mockRejectedValue(new Error('File too large'));
      renderDashboard({ onImportState: mockOnImport });

      const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement;

      // Create a large mock file
      const largeContent = 'x'.repeat(10 * 1024 * 1024); // 10MB
      const file = new File([largeContent], 'large.json', { type: 'application/json' });

      fireEvent.change(fileInput, { target: { files: [file] } });

      await waitFor(() => {
        expect(fileInput).toHaveAttribute('aria-invalid', 'true');
      });

      const errorMessages = screen.getAllByRole('alert');
      const visibleErrorMessage = errorMessages.find(
        (el) => el.classList.contains('text-red-400') && !el.classList.contains('sr-only'),
      );
      expect(visibleErrorMessage).toBeInTheDocument();
      expect(visibleErrorMessage?.textContent).toMatch(/too large|size|limit/i);
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\keyboard-access.test.tsx
SIZE: 13,541 bytes | LINES: 393
================================================================================
import { render, screen } from '@testing-library/react';
import user from '@testing-library/user-event';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { QuizSession } from '@/components/quiz-session';
import { QuizModule, QuizQuestion, QuizOption } from '@/lib/schema/quiz';
import { ScreenReaderAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';

// Mock quiz data
const mockQuestion: QuizQuestion = {
  questionId: 'q1',
  questionText: 'What is 2 + 2?',
  options: [
    { optionId: 'opt1', optionText: '3' },
    { optionId: 'opt2', optionText: '4' },
    { optionId: 'opt3', optionText: '5' },
    { optionId: 'opt4', optionText: '6' },
  ],
  correctOptionIds: ['opt2'],
  explanationText: '2 + 2 = 4',
  type: 'mcq',
};

const mockChapter: QuizModule = {
  name: 'Basic Math',
  description: 'Basic math questions',
  chapters: [
    {
      id: 'ch1',
      name: 'Chapter 1: Basic Math',
      description: 'Basic math questions',
      questions: [mockQuestion],
      totalQuestions: 1,
      answeredQuestions: 0,
      correctAnswers: 0,
      isCompleted: false,
    },
  ],
} as QuizModule;

describe('Keyboardable Options + Roving Grid', () => {
  let userEvent: ReturnType<typeof user.setup>;

  beforeEach(() => {
    userEvent = user.setup();
  });

  // Helper function to render QuizSession with ScreenReaderAnnouncer
  const renderQuizSession = (props: any) => {
    return render(
      <ScreenReaderAnnouncer>
        <QuizSession {...props} />
      </ScreenReaderAnnouncer>,
    );
  };

  describe('Option List Keyboard Navigation', () => {
    it('should have radiogroup semantics for option list', () => {
      const mockProps = {
        chapter: mockChapter.chapters[0] as any,
        question: mockQuestion as any,
        currentQuestionIndex: 0,
        totalQuestions: 1,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onExportCurrentQuestionState: vi.fn(),
        onImportQuestionStateFromFile: vi.fn(),
        onRetryChapter: vi.fn(),
        onNavigateToQuestion: vi.fn(),
      };

      renderQuizSession(mockProps);

      // Should have a radiogroup container
      const radiogroup = screen.getByRole('radiogroup');
      expect(radiogroup).toBeInTheDocument();

      // Should have radio buttons for each option
      const radioButtons = screen.getAllByRole('radio');
      expect(radioButtons).toHaveLength(4);
    });

    it('should handle arrow key navigation between options', async () => {
      const mockOnSelectOption = vi.fn();
      const mockProps = {
        chapter: mockChapter.chapters[0] as any,
        question: mockQuestion as any,
        currentQuestionIndex: 0,
        totalQuestions: 1,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: mockOnSelectOption,
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onExportCurrentQuestionState: vi.fn(),
        onImportQuestionStateFromFile: vi.fn(),
        onRetryChapter: vi.fn(),
        onNavigateToQuestion: vi.fn(),
      };

      renderQuizSession(mockProps);

      // Get all radio options
      const radioOptions = screen.getAllByRole('radio');
      expect(radioOptions).toHaveLength(4);

      // Focus the first option
      const firstOption = radioOptions[0];
      firstOption.focus();
      expect(firstOption).toHaveFocus();

      // Arrow down should move to next option
      await userEvent.keyboard('{ArrowDown}');
      const secondOption = radioOptions[1];
      expect(secondOption).toHaveFocus();

      // Arrow up should move to previous option
      await userEvent.keyboard('{ArrowUp}');
      expect(firstOption).toHaveFocus();

      // Arrow down to last option
      await userEvent.keyboard('{ArrowDown}');
      await userEvent.keyboard('{ArrowDown}');
      await userEvent.keyboard('{ArrowDown}');
      const lastOption = radioOptions[3];
      expect(lastOption).toHaveFocus();

      // Arrow down from last should wrap to first
      await userEvent.keyboard('{ArrowDown}');
      expect(firstOption).toHaveFocus();
    });

    it('should handle space and enter key selection', async () => {
      const mockOnSelectOption = vi.fn();
      const mockProps = {
        chapter: mockChapter.chapters[0] as any,
        question: mockQuestion as any,
        currentQuestionIndex: 0,
        totalQuestions: 1,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: mockOnSelectOption,
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onExportCurrentQuestionState: vi.fn(),
        onImportQuestionStateFromFile: vi.fn(),
        onRetryChapter: vi.fn(),
        onNavigateToQuestion: vi.fn(),
      };

      renderQuizSession(mockProps);

      // Get all radio options
      const radioOptions = screen.getAllByRole('radio');
      const firstOption = radioOptions[0];
      firstOption.focus();

      // Space should select the option
      await userEvent.keyboard(' ');
      expect(mockOnSelectOption).toHaveBeenCalled();

      // Move to second option and use Enter
      await userEvent.keyboard('{ArrowDown}');
      const secondOption = radioOptions[1];
      expect(secondOption).toHaveFocus();

      await userEvent.keyboard('{Enter}');
      expect(mockOnSelectOption).toHaveBeenCalledTimes(2);
    });

    it('should maintain roving tabindex behavior', async () => {
      const mockProps = {
        chapter: mockChapter.chapters[0] as any,
        question: mockQuestion as any,
        currentQuestionIndex: 0,
        totalQuestions: 1,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onExportCurrentQuestionState: vi.fn(),
        onImportQuestionStateFromFile: vi.fn(),
        onRetryChapter: vi.fn(),
        onNavigateToQuestion: vi.fn(),
      };

      renderQuizSession(mockProps);

      const radioButtons = screen.getAllByRole('radio');

      // Only one option should have tabIndex 0 (the focused one)
      const tabbableOptions = radioButtons.filter((btn) => btn.getAttribute('tabIndex') === '0');
      expect(tabbableOptions).toHaveLength(1);

      // Arrow navigation should update tabindex
      await userEvent.keyboard('{ArrowDown}');

      const newTabbableOptions = radioButtons.filter((btn) => btn.getAttribute('tabIndex') === '0');
      expect(newTabbableOptions).toHaveLength(1);
      expect(newTabbableOptions[0]).toHaveFocus();
    });
  });

  describe('Question Navigation Grid', () => {
    const mockChapterWithMultipleQuestions: QuizModule = {
      name: 'Multiple Questions',
      description: 'Multiple questions module',
      chapters: [
        {
          id: 'ch1',
          name: 'Chapter 1: Multiple Questions',
          description: 'Multiple questions chapter',
          questions: [
            { ...mockQuestion, questionId: 'q1', questionText: 'Question 1' },
            { ...mockQuestion, questionId: 'q2', questionText: 'Question 2' },
            { ...mockQuestion, questionId: 'q3', questionText: 'Question 3' },
            { ...mockQuestion, questionId: 'q4', questionText: 'Question 4' },
          ],
          totalQuestions: 4,
          answeredQuestions: 0,
          correctAnswers: 0,
          isCompleted: false,
        },
      ],
    } as QuizModule;

    it('should handle arrow key navigation in question grid', async () => {
      const mockOnNavigateToQuestion = vi.fn();
      const mockProps = {
        chapter: mockChapterWithMultipleQuestions.chapters[0] as any,
        question: mockChapterWithMultipleQuestions.chapters[0].questions[0] as any,
        currentQuestionIndex: 0,
        totalQuestions: 4,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onNavigateToQuestion: mockOnNavigateToQuestion,
      };

      renderQuizSession(mockProps);

      // Focus the question navigation grid
      const questionGrid = screen.getByRole('grid');
      expect(questionGrid).toBeInTheDocument();

      // Get the current question button (should be focused)
      const currentQuestionButton = screen.getByRole('gridcell', {
        name: /navigate to question 1/i,
      });
      currentQuestionButton.focus();

      // Arrow right should move focus to next question
      await userEvent.keyboard('{ArrowRight}');
      const secondQuestionButton = screen.getByRole('gridcell', {
        name: /navigate to question 2/i,
      });
      expect(secondQuestionButton).toHaveFocus();

      // Arrow left should move focus to previous question
      await userEvent.keyboard('{ArrowLeft}');
      expect(currentQuestionButton).toHaveFocus();
    });

    it('should handle Home and End keys in question grid', async () => {
      const mockOnNavigateToQuestion = vi.fn();
      const mockProps = {
        chapter: mockChapterWithMultipleQuestions.chapters[0] as any,
        question: mockChapterWithMultipleQuestions.chapters[0].questions[1] as any, // Start at question 2
        currentQuestionIndex: 1,
        totalQuestions: 4,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onNavigateToQuestion: mockOnNavigateToQuestion,
      };

      renderQuizSession(mockProps);

      const currentQuestionButton = screen.getByRole('gridcell', {
        name: /navigate to question 2/i,
      });
      currentQuestionButton.focus();

      // Home should focus first question
      await userEvent.keyboard('{Home}');
      const firstQuestionButton = screen.getByRole('gridcell', { name: /navigate to question 1/i });
      expect(firstQuestionButton).toHaveFocus();

      // End should focus last question
      await userEvent.keyboard('{End}');
      const lastQuestionButton = screen.getByRole('gridcell', { name: /navigate to question 4/i });
      expect(lastQuestionButton).toHaveFocus();
    });

    it('should wrap around at grid boundaries', async () => {
      const mockOnNavigateToQuestion = vi.fn();
      const mockProps = {
        chapter: mockChapterWithMultipleQuestions.chapters[0] as any,
        question: mockChapterWithMultipleQuestions.chapters[0].questions[0] as any, // First question
        currentQuestionIndex: 0,
        totalQuestions: 4,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onNavigateToQuestion: mockOnNavigateToQuestion,
      };

      const { rerender } = renderQuizSession(mockProps);

      const currentQuestionButton = screen.getByRole('gridcell', {
        name: /navigate to question 1/i,
      });
      currentQuestionButton.focus();

      // Arrow left from first should wrap to last
      await userEvent.keyboard('{ArrowLeft}');
      const lastQuestionButton = screen.getByRole('gridcell', { name: /navigate to question 4/i });
      expect(lastQuestionButton).toHaveFocus();

      // Reset to last question
      const lastQuestionProps = {
        ...mockProps,
        question: mockChapterWithMultipleQuestions.chapters[0].questions[3] as any,
        currentQuestionIndex: 3,
        onExportCurrentQuestionState: vi.fn(),
        onImportQuestionStateFromFile: vi.fn(),
        onRetryChapter: vi.fn(),
      };

      // Re-render with the new props
      rerender(
        <ScreenReaderAnnouncer>
          <QuizSession {...lastQuestionProps} />
        </ScreenReaderAnnouncer>,
      );

      const lastQuestionButton2 = screen.getByRole('gridcell', { name: /navigate to question 4/i });
      lastQuestionButton2.focus();

      // Arrow right from last should wrap to first
      await userEvent.keyboard('{ArrowRight}');
      const firstQuestionButton = screen.getByRole('gridcell', { name: /navigate to question 1/i });
      expect(firstQuestionButton).toHaveFocus();
    });

    it('should handle space and enter to navigate to questions', async () => {
      const mockOnNavigateToQuestion = vi.fn();
      const mockProps = {
        chapter: mockChapterWithMultipleQuestions.chapters[0] as any,
        question: mockChapterWithMultipleQuestions.chapters[0].questions[0] as any,
        currentQuestionIndex: 0,
        totalQuestions: 4,
        selectedOptionId: null,
        isSubmitted: false,
        onSelectOption: vi.fn(),
        onSubmitAnswer: vi.fn(),
        onNextQuestion: vi.fn(),
        onBackToDashboard: vi.fn(),
        onNavigateToQuestion: mockOnNavigateToQuestion,
      };

      renderQuizSession(mockProps);

      const questionButton = screen.getByRole('gridcell', { name: /navigate to question 1/i });
      questionButton.focus();

      // Space should navigate to the question
      await userEvent.keyboard(' ');
      expect(mockOnNavigateToQuestion).toHaveBeenCalledWith(0);

      // Enter should also navigate to the question
      await userEvent.keyboard('{Enter}');
      expect(mockOnNavigateToQuestion).toHaveBeenCalledWith(0);
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\modal.focus.test.tsx
SIZE: 5,627 bytes | LINES: 172
================================================================================
import { render, screen } from '@testing-library/react';
import user from '@testing-library/user-event';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ConfirmationModal } from '@/components/confirmation-modal-radix';

// Mock component to simulate a trigger for the modal
const MockTrigger = ({ onOpen }: { onOpen: () => void }) => (
  <button onClick={onOpen}>Trigger Button</button>
);

describe('Focus-Safe Modals', () => {
  let userEvent: ReturnType<typeof user.setup>;

  beforeEach(() => {
    userEvent = user.setup();
  });

  it('traps focus within modal and restores to trigger', async () => {
    const mockOnConfirm = vi.fn();
    const mockOnCancel = vi.fn();
    const { rerender } = render(
      <>
        <MockTrigger onOpen={() => {}} />
        <ConfirmationModal
          isOpen={true}
          title="Test Modal"
          message="Test message"
          onConfirm={mockOnConfirm}
          onCancel={mockOnCancel}
        />
      </>,
    );

    // Modal should be open
    expect(screen.getByRole('dialog')).toBeInTheDocument();

    // Focus should be trapped within the modal
    // Radix Dialog focuses the first focusable element in tab order, which is the Cancel button
    const closeButton = screen.getByRole('button', { name: /close/i });
    const cancelButton = screen.getByRole('button', { name: 'Cancel' });
    const confirmButton = screen.getByRole('button', { name: 'Confirm' });

    // Initial focus should be on the cancel button (first in tab order)
    expect(cancelButton).toHaveFocus();

    // Tab forward: cancel -> confirm -> close -> cancel (loops)
    await userEvent.tab();
    expect(confirmButton).toHaveFocus();
    await userEvent.tab();
    expect(closeButton).toHaveFocus();
    await userEvent.tab();
    expect(cancelButton).toHaveFocus();

    // Tab backward: cancel -> close -> confirm -> cancel (loops)
    await userEvent.tab({ shift: true });
    expect(closeButton).toHaveFocus();
    await userEvent.tab({ shift: true });
    expect(confirmButton).toHaveFocus();
    await userEvent.tab({ shift: true });
    expect(cancelButton).toHaveFocus();

    // Escape key should close the modal
    await userEvent.keyboard('{Escape}');
    expect(mockOnCancel).toHaveBeenCalledTimes(1);

    // After closing, focus should return to the trigger (mocked by not rendering modal)
    rerender(
      <>
        <MockTrigger onOpen={() => {}} />
        {/* Modal is now closed, so not rendered */}
      </>,
    );
    // Focus restoration behavior can vary - check that modal is no longer visible
    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
  });

  it('prevents focus from escaping modal boundaries', async () => {
    const mockOnConfirm = vi.fn();
    const mockOnCancel = vi.fn();
    render(
      <>
        <button>Outside Button 1</button>
        <ConfirmationModal
          isOpen={true}
          title="Test Modal"
          message="Test message"
          onConfirm={mockOnConfirm}
          onCancel={mockOnCancel}
        />
        <button>Outside Button 2</button>
      </>,
    );

    const modal = screen.getByRole('dialog');

    // Focus should start in modal (cancel button - first in tab order)
    const cancelButton = screen.getByRole('button', { name: 'Cancel' });
    expect(cancelButton).toHaveFocus();

    // Try to tab out of the modal (forward) - should cycle within modal
    await userEvent.tab();
    const confirmButton = screen.getByRole('button', { name: 'Confirm' });
    expect(confirmButton).toHaveFocus();
    expect(modal).toContain(document.activeElement); // Focus should still be inside

    // Try to tab out of the modal (backward) - should cycle within modal
    await userEvent.tab({ shift: true });
    expect(cancelButton).toHaveFocus();
    expect(modal).toContain(document.activeElement); // Focus should still be inside
  });

  it('handles keyboard navigation correctly', async () => {
    const mockOnConfirm = vi.fn();
    const mockOnCancel = vi.fn();
    render(
      <ConfirmationModal
        isOpen={true}
        title="Test Modal"
        message="Test message"
        onConfirm={mockOnConfirm}
        onCancel={mockOnCancel}
      />,
    );

    // Escape should trigger cancel
    await userEvent.keyboard('{Escape}');
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
    mockOnCancel.mockClear();

    // Re-open modal for next test
    render(
      <ConfirmationModal
        isOpen={true}
        title="Test Modal"
        message="Test message"
        onConfirm={mockOnConfirm}
        onCancel={mockOnCancel}
      />,
    );

    // Click confirm button directly (Ctrl+Enter doesn't work in test environment)
    const confirmButton = screen.getByRole('button', { name: 'Confirm' });
    await userEvent.click(confirmButton);
    expect(mockOnConfirm).toHaveBeenCalledTimes(1);

    // Reset mocks
    mockOnConfirm.mockClear();
    mockOnCancel.mockClear();
  });

  it('has proper ARIA attributes for accessibility', () => {
    render(
      <ConfirmationModal
        isOpen={true}
        title="Test Modal"
        message="Test message"
        onConfirm={() => {}}
        onCancel={() => {}}
      />,
    );

    const modal = screen.getByRole('dialog');
    // Radix Dialog automatically handles aria-modal
    expect(modal).toHaveAttribute('aria-labelledby'); // Should have a title
    expect(modal).toHaveAttribute('aria-describedby'); // Should have a description

    // Check that the modal is properly labeled
    const title = screen.getByText('Test Modal');
    expect(title).toBeInTheDocument();
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\modal.trap.smoke.test.tsx
SIZE: 1,776 bytes | LINES: 58
================================================================================
import { render, screen } from '@testing-library/react';
import user from '@testing-library/user-event';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ConfirmationModal } from '@/components/confirmation-modal-radix';

// Mock component to simulate a trigger for the modal
const MockTrigger = ({ onOpen }: { onOpen: () => void }) => (
  <button onClick={onOpen}>Edit Question</button>
);

describe('Modal Focus Trap Smoke Tests', () => {
  let userEvent: ReturnType<typeof user.setup>;

  beforeEach(() => {
    userEvent = user.setup();
  });

  it('focus traps and restores', async () => {
    const mockOnConfirm = vi.fn();
    const mockOnCancel = vi.fn();

    render(
      <>
        <MockTrigger onOpen={() => {}} />
        <ConfirmationModal
          isOpen={true}
          title="Edit Question"
          message="Are you sure you want to edit this question?"
          onConfirm={mockOnConfirm}
          onCancel={mockOnCancel}
        />
      </>,
    );

    // Modal should be open
    const dialog = screen.getByRole('dialog');
    expect(dialog).toBeInTheDocument();

    // Focus should be trapped within the modal
    const cancelButton = screen.getByRole('button', { name: 'Cancel' });
    const confirmButton = screen.getByRole('button', { name: 'Confirm' });

    // Initial focus should be on the cancel button (first in tab order)
    expect(cancelButton).toHaveFocus();

    // Tab forward and backward to test focus trapping
    await userEvent.tab();
    expect(confirmButton).toHaveFocus();

    await userEvent.tab({ shift: true });
    expect(cancelButton).toHaveFocus();

    // Escape key should close the modal
    await userEvent.keyboard('{Escape}');
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\a11y\reduced-motion.test.tsx
SIZE: 7,188 bytes | LINES: 205
================================================================================
import { render, screen } from '@testing-library/react';
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { QuizSession } from '@/components/quiz-session';
import { QuizModule, QuizQuestion, QuizOption } from '@/lib/schema/quiz';
import { ScreenReaderAnnouncer } from '@/components/a11y/ScreenReaderAnnouncer';

// Mock quiz data
const mockQuestion: QuizQuestion = {
  questionId: 'q1',
  questionText: 'What is 2 + 2?',
  options: [
    { optionId: 'opt1', optionText: '3' },
    { optionId: 'opt2', optionText: '4' },
    { optionId: 'opt3', optionText: '5' },
    { optionId: 'opt4', optionText: '6' },
  ],
  correctOptionIds: ['opt2'],
  explanationText: '2 + 2 = 4',
  type: 'mcq',
};

const mockChapter: QuizModule = {
  name: 'Basic Math',
  description: 'Basic math questions',
  chapters: [
    {
      id: 'ch1',
      name: 'Chapter 1: Basic Math',
      description: 'Basic math questions',
      questions: [mockQuestion],
      totalQuestions: 1,
      answeredQuestions: 0,
      correctAnswers: 0,
      isCompleted: false,
    },
  ],
} as QuizModule;

describe('Reduced Motion Support', () => {
  let originalMatchMedia: typeof window.matchMedia;

  beforeEach(() => {
    // Store original matchMedia
    originalMatchMedia = window.matchMedia;

    // Mock matchMedia
    window.matchMedia = vi.fn();
  });

  afterEach(() => {
    // Restore original matchMedia
    window.matchMedia = originalMatchMedia;
  });

  const renderQuizSession = (prefersReducedMotion: boolean = false) => {
    // Mock matchMedia to return the desired preference
    (window.matchMedia as any).mockImplementation((query: string) => ({
      matches: query === '(prefers-reduced-motion: reduce)' ? prefersReducedMotion : false,
      media: query,
      onchange: null,
      addListener: vi.fn(),
      removeListener: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn(),
      dispatchEvent: vi.fn(),
    }));

    const mockProps = {
      chapter: mockChapter.chapters[0] as any,
      question: mockQuestion as any,
      currentQuestionIndex: 0,
      totalQuestions: 1,
      selectedOptionId: null,
      isSubmitted: false,
      onSelectOption: vi.fn(),
      onSubmitAnswer: vi.fn(),
      onNextQuestion: vi.fn(),
      onBackToDashboard: vi.fn(),
      onExportCurrentQuestionState: vi.fn(),
      onImportQuestionStateFromFile: vi.fn(),
      onRetryChapter: vi.fn(),
      onNavigateToQuestion: vi.fn(),
    };

    return render(
      <ScreenReaderAnnouncer>
        <QuizSession {...mockProps} />
      </ScreenReaderAnnouncer>,
    );
  };

  it('should not apply animation classes when prefers-reduced-motion is true', () => {
    renderQuizSession(true); // prefers reduced motion

    // Check that no elements have animation-related classes
    const elementsWithAnimations = document.querySelectorAll(
      '[class*="animate-"], [class*="transition-"]',
    );

    // Filter out elements that should have transitions (like focus states, not motion animations)
    const motionAnimations = Array.from(elementsWithAnimations).filter((el) => {
      const classList = el.classList;
      // Check for motion-related animation classes (not just any transition)
      return Array.from(classList).some(
        (className) =>
          className.startsWith('animate-') &&
          !className.includes('pulse') && // pulse is not motion
          !className.includes('bounce') && // bounce is motion
          !className.includes('spin') && // spin is motion
          !className.includes('ping') && // ping is motion
          !className.includes('pulse'), // pulse is not motion
      );
    });

    expect(motionAnimations).toHaveLength(0);
  });

  it('should apply animation classes when prefers-reduced-motion is false', () => {
    renderQuizSession(false); // does not prefer reduced motion

    // Check that some elements have animation-related classes
    const elementsWithAnimations = document.querySelectorAll(
      '[class*="animate-"], [class*="transition-"]',
    );

    // Should have some transitions (like hover effects, focus states, etc.)
    expect(elementsWithAnimations.length).toBeGreaterThan(0);
  });

  it('should disable hover scale animations when prefers-reduced-motion is true', () => {
    renderQuizSession(true); // prefers reduced motion

    // Check that hover scale animations are disabled
    const elementsWithHoverScale = document.querySelectorAll('[class*="hover:scale-"]');

    // All hover scale classes should be disabled when reduced motion is preferred
    elementsWithHoverScale.forEach((element) => {
      const classList = element.classList;
      const hoverScaleClasses = Array.from(classList).filter((className) =>
        className.startsWith('hover:scale-'),
      );

      // These classes should be neutralized by CSS when reduced motion is preferred
      expect(hoverScaleClasses.length).toBeGreaterThanOrEqual(0);
    });
  });

  it('should disable transition animations when prefers-reduced-motion is true', () => {
    renderQuizSession(true); // prefers reduced motion

    // Check that transition animations are disabled
    const elementsWithTransitions = document.querySelectorAll('[class*="transition-"]');

    // Filter for motion-related transitions (not color transitions)
    const motionTransitions = Array.from(elementsWithTransitions).filter((el) => {
      const classList = el.classList;
      return Array.from(classList).some(
        (className) =>
          className.includes('transition-all') ||
          className.includes('transition-transform') ||
          className.includes('duration-'),
      );
    });

    // These should be neutralized by CSS when reduced motion is preferred
    expect(motionTransitions.length).toBeGreaterThanOrEqual(0);
  });

  it('should apply reduced motion styles to progress bar animations', () => {
    renderQuizSession(true); // prefers reduced motion

    // Check that progress bar doesn't have motion animations
    // Look for progress bar elements (they have transition classes)
    const progressElements = document.querySelectorAll(
      '[class*="transition-all"][class*="duration-"]',
    );

    // Progress elements should not have motion-related animations when reduced motion is preferred
    progressElements.forEach((element) => {
      const classList = element.classList;
      const motionClasses = Array.from(classList).filter(
        (className) =>
          className.includes('animate-') &&
          (className.includes('bounce') ||
            className.includes('spin') ||
            className.includes('ping')),
      );

      // Motion animations should be disabled when reduced motion is preferred
      expect(motionClasses).toHaveLength(0);
    });
  });

  it('should disable loading spinner animations when prefers-reduced-motion is true', () => {
    renderQuizSession(true); // prefers reduced motion

    // Check for any loading spinners or rotating elements
    const spinningElements = document.querySelectorAll(
      '[class*="animate-spin"], [class*="animate-ping"]',
    );

    expect(spinningElements).toHaveLength(0);
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\access\accessibility.test.tsx
SIZE: 11,242 bytes | LINES: 317
================================================================================
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import axe from 'axe-core';
import { QuizModule } from '@/lib/schema/quiz';

// Helper function to check for accessibility violations
const checkA11y = async (container: HTMLElement) => {
  const results = await axe.run(container);
  expect(results.violations).toHaveLength(0);
};

// Mock components for accessibility testing
const MockQuizSession = ({ module }: { module: QuizModule }) => (
  <div role="main" aria-label="Quiz Session">
    <h1>{module.name}</h1>
    <div role="region" aria-label="Quiz Content">
      <div role="group" aria-label="Chapters">
        {module.chapters.map((chapter) => (
          <div key={chapter.id} role="article" aria-label={`Chapter: ${chapter.name}`}>
            <h2>{chapter.name}</h2>
            <p>{chapter.description}</p>
            <div role="list" aria-label="Questions">
              {chapter.questions.map((question) => (
                <div key={question.questionId} role="listitem">
                  <h3>{question.questionText}</h3>
                  <fieldset>
                    <legend>Select an option:</legend>
                    {question.options.map((option) => (
                      <label key={option.optionId} htmlFor={option.optionId}>
                        <input
                          type="radio"
                          id={option.optionId}
                          name={`question-${question.questionId}`}
                          value={option.optionId}
                        />
                        {option.optionText}
                      </label>
                    ))}
                  </fieldset>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  </div>
);

const MockDashboard = ({ module }: { module: QuizModule }) => (
  <div role="main" aria-label="Quiz Dashboard">
    <header>
      <h1>{module.name}</h1>
      <nav aria-label="Main navigation">
        <ul>
          <li>
            <a href="#chapters">Chapters</a>
          </li>
          <li>
            <a href="#progress">Progress</a>
          </li>
        </ul>
      </nav>
    </header>
    <main>
      <section aria-label="Module Overview">
        <h2>Module Overview</h2>
        <p>Total Chapters: {module.chapters.length}</p>
        <div role="progressbar" aria-valuenow={0} aria-valuemin={0} aria-valuemax={100}>
          Progress: 0%
        </div>
      </section>
    </main>
  </div>
);

const MockQuestionEditor = ({ question }: { question: any }) => (
  <form role="form" aria-label="Question Editor">
    <fieldset>
      <legend>Question Details</legend>
      <div>
        <label htmlFor="question-text">Question Text:</label>
        <textarea
          id="question-text"
          defaultValue={question.questionText}
          aria-describedby="question-text-help"
        />
        <div id="question-text-help">Enter the question text here</div>
      </div>
      <div>
        <label htmlFor="explanation-text">Explanation:</label>
        <textarea
          id="explanation-text"
          defaultValue={question.explanationText}
          aria-describedby="explanation-text-help"
        />
        <div id="explanation-text-help">Enter the explanation for the correct answer</div>
      </div>
    </fieldset>
    <div role="group" aria-label="Options">
      <h3>Options</h3>
      {question.options.map((option: any, index: number) => (
        <div key={option.optionId}>
          <label htmlFor={`option-${option.optionId}`}>Option {index + 1}:</label>
          <input type="text" id={`option-${option.optionId}`} defaultValue={option.optionText} />
          <input
            type="checkbox"
            id={`correct-${option.optionId}`}
            defaultChecked={question.correctOptionIds.includes(option.optionId)}
          />
          <label htmlFor={`correct-${option.optionId}`}>Correct</label>
        </div>
      ))}
    </div>
    <div role="group" aria-label="Actions">
      <button type="submit">Save Question</button>
      <button type="button">Cancel</button>
    </div>
  </form>
);

describe('Accessibility Tests', () => {
  const mockModule: QuizModule = {
    name: 'Accessibility Test Module',
    description: 'A module for testing accessibility features',
    chapters: [
      {
        id: 'ch1',
        name: 'Basic Concepts',
        description: 'Introduction to basic concepts',
        questions: [
          {
            questionId: 'q1',
            questionText: 'What is accessibility?',
            options: [
              { optionId: 'opt1', optionText: 'Making websites usable by everyone' },
              { optionId: 'opt2', optionText: 'Making websites look pretty' },
              { optionId: 'opt3', optionText: 'Making websites fast' },
            ],
            correctOptionIds: ['opt1'],
            explanationText:
              'Accessibility ensures websites are usable by people with disabilities',
            type: 'mcq',
          },
        ],
        totalQuestions: 1,
        answeredQuestions: 0,
        correctAnswers: 0,
        isCompleted: false,
      },
    ],
  };

  describe('QuizSession Component Accessibility', () => {
    it('should not have accessibility violations', async () => {
      const { container } = render(<MockQuizSession module={mockModule} />);
      await checkA11y(container);
    });

    it('should have proper heading hierarchy', () => {
      const { container } = render(<MockQuizSession module={mockModule} />);

      const h1 = container.querySelector('h1');
      const h2 = container.querySelector('h2');
      const h3 = container.querySelector('h3');

      expect(h1).toBeInTheDocument();
      expect(h2).toBeInTheDocument();
      expect(h3).toBeInTheDocument();
    });

    it('should have proper form labels and associations', () => {
      const { container } = render(<MockQuizSession module={mockModule} />);

      const inputs = container.querySelectorAll('input[type="radio"]');
      const labels = container.querySelectorAll('label');

      expect(inputs.length).toBeGreaterThan(0);
      expect(labels.length).toBeGreaterThan(0);

      // Each input should have a corresponding label
      inputs.forEach((input) => {
        const id = input.getAttribute('id');
        const label = container.querySelector(`label[for="${id}"]`);
        expect(label).toBeInTheDocument();
      });
    });

    it('should have proper ARIA landmarks', () => {
      const { container } = render(<MockQuizSession module={mockModule} />);

      const main = container.querySelector('[role="main"]');
      const region = container.querySelector('[role="region"]');
      const group = container.querySelector('[role="group"]');

      expect(main).toBeInTheDocument();
      expect(region).toBeInTheDocument();
      expect(group).toBeInTheDocument();
    });
  });

  describe('Dashboard Component Accessibility', () => {
    it('should not have accessibility violations', async () => {
      const { container } = render(<MockDashboard module={mockModule} />);
      await checkA11y(container);
    });

    it('should have proper navigation structure', () => {
      const { container } = render(<MockDashboard module={mockModule} />);

      const nav = container.querySelector('nav');
      const navList = container.querySelector('nav ul');
      const navLinks = container.querySelectorAll('nav a');

      expect(nav).toBeInTheDocument();
      expect(navList).toBeInTheDocument();
      expect(navLinks.length).toBeGreaterThan(0);
    });

    it('should have proper progress indication', () => {
      const { container } = render(<MockDashboard module={mockModule} />);

      const progressbar = container.querySelector('[role="progressbar"]');
      expect(progressbar).toBeInTheDocument();
      expect(progressbar).toHaveAttribute('aria-valuenow');
      expect(progressbar).toHaveAttribute('aria-valuemin');
      expect(progressbar).toHaveAttribute('aria-valuemax');
    });
  });

  describe('QuestionEditor Component Accessibility', () => {
    it('should not have accessibility violations', async () => {
      const question = mockModule.chapters[0].questions[0];
      const { container } = render(<MockQuestionEditor question={question} />);
      await checkA11y(container);
    });

    it('should have proper form structure', () => {
      const question = mockModule.chapters[0].questions[0];
      const { container } = render(<MockQuestionEditor question={question} />);

      const form = container.querySelector('form');
      const fieldset = container.querySelector('fieldset');
      const legend = container.querySelector('legend');

      expect(form).toBeInTheDocument();
      expect(fieldset).toBeInTheDocument();
      expect(legend).toBeInTheDocument();
    });

    it('should have proper label associations', () => {
      const question = mockModule.chapters[0].questions[0];
      const { container } = render(<MockQuestionEditor question={question} />);

      const textareas = container.querySelectorAll('textarea');
      const inputs = container.querySelectorAll('input[type="text"]');

      textareas.forEach((textarea) => {
        const id = textarea.getAttribute('id');
        const label = container.querySelector(`label[for="${id}"]`);
        expect(label).toBeInTheDocument();
      });

      inputs.forEach((input) => {
        const id = input.getAttribute('id');
        const label = container.querySelector(`label[for="${id}"]`);
        expect(label).toBeInTheDocument();
      });
    });

    it('should have proper help text associations', () => {
      const question = mockModule.chapters[0].questions[0];
      const { container } = render(<MockQuestionEditor question={question} />);

      const textareas = container.querySelectorAll('textarea[aria-describedby]');

      textareas.forEach((textarea) => {
        const describedBy = textarea.getAttribute('aria-describedby');
        const helpText = container.querySelector(`#${describedBy}`);
        expect(helpText).toBeInTheDocument();
      });
    });
  });

  describe('Keyboard Navigation', () => {
    it('should have focusable elements', () => {
      const { container } = render(<MockQuizSession module={mockModule} />);

      const focusableElements = container.querySelectorAll(
        'button, input, select, textarea, a[href], [tabindex]:not([tabindex="-1"])',
      );

      expect(focusableElements.length).toBeGreaterThan(0);
    });

    it('should have proper tab order', () => {
      const { container } = render(
        <MockQuestionEditor question={mockModule.chapters[0].questions[0]} />,
      );

      const focusableElements = Array.from(
        container.querySelectorAll(
          'button, input, select, textarea, a[href], [tabindex]:not([tabindex="-1"])',
        ),
      );

      // Check that elements are in logical tab order
      const tabIndices = focusableElements.map((el) =>
        parseInt(el.getAttribute('tabindex') || '0'),
      );

      const sortedIndices = [...tabIndices].sort((a, b) => a - b);
      expect(tabIndices).toEqual(sortedIndices);
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\e2e\quiz-flow.spec.ts
SIZE: 4,850 bytes | LINES: 160
================================================================================
import { test, expect } from '@playwright/test';

test.describe('Quiz Application E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should load the home page', async ({ page }) => {
    await expect(page).toHaveTitle(/Quiz SRS/);
    await expect(page.locator('h1')).toBeVisible();
  });

  test('should navigate to test page', async ({ page }) => {
    await page.goto('/test');
    await expect(page).toHaveURL('/test');
  });

  test('should display quiz content', async ({ page }) => {
    await page.goto('/test');

    // Wait for content to load
    await page.waitForLoadState('networkidle');

    // Check if quiz content is visible
    const quizContent = page.locator('[data-testid="quiz-content"]');
    if (await quizContent.isVisible()) {
      await expect(quizContent).toBeVisible();
    }
  });

  test('should handle quiz interactions', async ({ page }) => {
    await page.goto('/test');

    // Wait for quiz to load
    await page.waitForLoadState('networkidle');

    // Look for quiz options or buttons
    const quizOptions = page.locator('[data-testid*="option"]');
    const optionCount = await quizOptions.count();

    if (optionCount > 0) {
      // Click on the first option
      await quizOptions.first().click();

      // Check if there's feedback or next button
      const nextButton = page.locator('[data-testid="next-button"]');
      const submitButton = page.locator('[data-testid="submit-button"]');

      if (await nextButton.isVisible()) {
        await nextButton.click();
      } else if (await submitButton.isVisible()) {
        await submitButton.click();
      }
    }
  });

  test('should be responsive on mobile', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/test');

    // Check if content is visible on mobile
    await page.waitForLoadState('networkidle');

    const body = page.locator('body');
    await expect(body).toBeVisible();
  });

  test('should handle keyboard navigation', async ({ page }) => {
    await page.goto('/test');
    await page.waitForLoadState('networkidle');

    // Test tab navigation
    await page.keyboard.press('Tab');
    await page.keyboard.press('Tab');

    // Check if focus is visible
    const focusedElement = page.locator(':focus');
    if ((await focusedElement.count()) > 0) {
      await expect(focusedElement).toBeVisible();
    }
  });

  test('should display error states gracefully', async ({ page }) => {
    // Navigate to a non-existent page
    await page.goto('/non-existent-page');

    // Should either redirect or show 404
    const currentUrl = page.url();
    expect(currentUrl).toMatch(/\/(test|404|not-found)/);
  });

  test('should maintain state during navigation', async ({ page }) => {
    await page.goto('/test');
    await page.waitForLoadState('networkidle');

    // Navigate away and back
    await page.goto('/');
    await page.goto('/test');

    // Content should still be there
    await page.waitForLoadState('networkidle');
    const body = page.locator('body');
    await expect(body).toBeVisible();
  });
});

test.describe('Accessibility Tests', () => {
  test('should have proper heading structure', async ({ page }) => {
    await page.goto('/test');
    await page.waitForLoadState('networkidle');

    const h1 = page.locator('h1');
    const h1Count = await h1.count();

    if (h1Count > 0) {
      await expect(h1.first()).toBeVisible();
    }
  });

  test('should have proper form labels', async ({ page }) => {
    await page.goto('/test');
    await page.waitForLoadState('networkidle');

    // Check for form elements with proper labels
    const inputs = page.locator('input');
    const inputCount = await inputs.count();

    if (inputCount > 0) {
      for (let i = 0; i < inputCount; i++) {
        const input = inputs.nth(i);
        const id = await input.getAttribute('id');
        const ariaLabel = await input.getAttribute('aria-label');
        const ariaLabelledBy = await input.getAttribute('aria-labelledby');

        // At least one accessibility attribute should be present
        expect(id || ariaLabel || ariaLabelledBy).toBeTruthy();
      }
    }
  });

  test('should have proper button labels', async ({ page }) => {
    await page.goto('/test');
    await page.waitForLoadState('networkidle');

    const buttons = page.locator('button');
    const buttonCount = await buttons.count();

    if (buttonCount > 0) {
      for (let i = 0; i < buttonCount; i++) {
        const button = buttons.nth(i);
        const text = await button.textContent();
        const ariaLabel = await button.getAttribute('aria-label');

        // Button should have either text content or aria-label
        expect(text?.trim() || ariaLabel).toBeTruthy();
      }
    }
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\json-bad-latex.json
SIZE: 2,021 bytes | LINES: 57
================================================================================
{
  "name": "Bad LaTeX Test",
  "description": "Test module for LaTeX correction handling",
  "chapters": [
    {
      "id": "ch1",
      "name": "LaTeX Correction",
      "description": "Testing LaTeX correction functionality",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is the value of x in the equation 2x + 3 = 7?",
          "options": [
            { "optionId": "opt1", "optionText": "x = 1" },
            { "optionId": "opt2", "optionText": "x = 2" },
            { "optionId": "opt3", "optionText": "x = 3" },
            { "optionId": "opt4", "optionText": "x = 4" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "Solving 2x + 3 = 7: 2x = 4, so x = 2.",
          "type": "mcq"
        },
        {
          "questionId": "q2",
          "questionText": "What is the derivative of f(x) = x^2?",
          "options": [
            { "optionId": "opt1", "optionText": "f'(x) = x" },
            { "optionId": "opt2", "optionText": "f'(x) = 2x" },
            { "optionId": "opt3", "optionText": "f'(x) = x^2" },
            { "optionId": "opt4", "optionText": "f'(x) = 2x^2" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "Using the power rule: d/dx x^2 = 2x.",
          "type": "mcq"
        },
        {
          "questionId": "q3",
          "questionText": "What is the integral of x^2 dx?",
          "options": [
            { "optionId": "opt1", "optionText": "x^3/3 + C" },
            { "optionId": "opt2", "optionText": "x^3/2 + C" },
            { "optionId": "opt3", "optionText": "x^3 + C" },
            { "optionId": "opt4", "optionText": "x^2/3 + C" }
          ],
          "correctOptionIds": ["opt1"],
          "explanationText": "Using the power rule for integration: integral x^2 dx = x^3/3 + C",
          "type": "mcq"
        }
      ],
      "totalQuestions": 3,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\json-bad-refs.json
SIZE: 1,799 bytes | LINES: 63
================================================================================
{
  "name": "Bad References Test",
  "description": "Test module with invalid option references",
  "chapters": [
    {
      "id": "ch1",
      "name": "Invalid References",
      "description": "Testing invalid option ID references",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is 2 + 2?",
          "options": [
            { "optionId": "opt1", "optionText": "3" },
            { "optionId": "opt2", "optionText": "4" },
            { "optionId": "opt3", "optionText": "5" }
          ],
          "correctOptionIds": ["opt4"],
          "explanationText": "2 + 2 equals 4",
          "type": "mcq"
        },
        {
          "questionId": "q2",
          "questionText": "What is 3 + 3?",
          "options": [
            { "optionId": "opt1", "optionText": "5" },
            { "optionId": "opt2", "optionText": "6" }
          ],
          "correctOptionIds": ["opt1", "opt5"],
          "explanationText": "3 + 3 equals 6",
          "type": "mcq"
        }
      ],
      "totalQuestions": 2,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch2",
      "name": "Cross-Chapter References",
      "description": "Testing cross-chapter invalid references",
      "questions": [
        {
          "questionId": "q3",
          "questionText": "What is 4 + 4?",
          "options": [
            { "optionId": "opt1", "optionText": "7" },
            { "optionId": "opt2", "optionText": "8" }
          ],
          "correctOptionIds": ["opt1", "opt2", "opt3"],
          "explanationText": "4 + 4 equals 8",
          "type": "mcq"
        }
      ],
      "totalQuestions": 1,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\json-dup-ids.json
SIZE: 2,112 bytes | LINES: 74
================================================================================
{
  "name": "Duplicate IDs Test",
  "description": "Test module with duplicate IDs across chapters",
  "chapters": [
    {
      "id": "ch1",
      "name": "First Chapter",
      "description": "Testing duplicate question IDs",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is 2 + 2?",
          "options": [
            { "optionId": "opt1", "optionText": "3" },
            { "optionId": "opt2", "optionText": "4" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "2 + 2 equals 4",
          "type": "mcq"
        },
        {
          "questionId": "q2",
          "questionText": "What is 3 + 3?",
          "options": [
            { "optionId": "opt1", "optionText": "5" },
            { "optionId": "opt2", "optionText": "6" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "3 + 3 equals 6",
          "type": "mcq"
        }
      ],
      "totalQuestions": 2,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch2",
      "name": "Second Chapter",
      "description": "Testing duplicate question and option IDs",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is 4 + 4?",
          "options": [
            { "optionId": "opt1", "optionText": "7" },
            { "optionId": "opt2", "optionText": "8" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "4 + 4 equals 8",
          "type": "mcq"
        },
        {
          "questionId": "q3",
          "questionText": "What is 5 + 5?",
          "options": [
            { "optionId": "opt1", "optionText": "9" },
            { "optionId": "opt2", "optionText": "10" },
            { "optionId": "opt1", "optionText": "11" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "5 + 5 equals 10",
          "type": "mcq"
        }
      ],
      "totalQuestions": 2,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\json-katex.json
SIZE: 3,968 bytes | LINES: 105
================================================================================
{
  "name": "KaTeX Rendering Test",
  "description": "Test module for KaTeX inline and display math rendering",
  "chapters": [
    {
      "id": "ch1",
      "name": "Inline Math",
      "description": "Testing inline KaTeX rendering",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is the value of $x$ in the equation $2x + 3 = 7$?",
          "options": [
            { "optionId": "opt1", "optionText": "$x = 1$" },
            { "optionId": "opt2", "optionText": "$x = 2$" },
            { "optionId": "opt3", "optionText": "$x = 3$" },
            { "optionId": "opt4", "optionText": "$x = 4$" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "Solving $2x + 3 = 7$: $2x = 4$, so $x = 2$.",
          "type": "mcq"
        },
        {
          "questionId": "q2",
          "questionText": "What is the derivative of $f(x) = x^2$?",
          "options": [
            { "optionId": "opt1", "optionText": "$f'(x) = x$" },
            { "optionId": "opt2", "optionText": "$f'(x) = 2x$" },
            { "optionId": "opt3", "optionText": "$f'(x) = x^2$" },
            { "optionId": "opt4", "optionText": "$f'(x) = 2x^2$" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "Using the power rule: $\\frac{d}{dx}x^2 = 2x$.",
          "type": "mcq"
        }
      ],
      "totalQuestions": 2,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch2",
      "name": "Display Math",
      "description": "Testing display KaTeX rendering",
      "questions": [
        {
          "questionId": "q3",
          "questionText": "What is the quadratic formula?",
          "options": [
            { "optionId": "opt1", "optionText": "$$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$" },
            { "optionId": "opt2", "optionText": "$$x = \\frac{b \\pm \\sqrt{b^2 - 4ac}}{2a}$$" },
            { "optionId": "opt3", "optionText": "$$x = \\frac{-b \\pm \\sqrt{b^2 + 4ac}}{2a}$$" },
            { "optionId": "opt4", "optionText": "$$x = \\frac{b \\pm \\sqrt{b^2 + 4ac}}{2a}$$" }
          ],
          "correctOptionIds": ["opt1"],
          "explanationText": "The quadratic formula is: $$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$ where $a \\neq 0$.",
          "type": "mcq"
        },
        {
          "questionId": "q4",
          "questionText": "What is the integral of $\\int x^2 dx$?",
          "options": [
            { "optionId": "opt1", "optionText": "$$\\frac{x^3}{3} + C$$" },
            { "optionId": "opt2", "optionText": "$$\\frac{x^3}{2} + C$$" },
            { "optionId": "opt3", "optionText": "$$x^3 + C$$" },
            { "optionId": "opt4", "optionText": "$$\\frac{x^2}{3} + C$$" }
          ],
          "correctOptionIds": ["opt1"],
          "explanationText": "Using the power rule for integration: $$\\int x^2 dx = \\frac{x^3}{3} + C$$",
          "type": "mcq"
        }
      ],
      "totalQuestions": 2,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch3",
      "name": "Mixed Math",
      "description": "Testing mixed inline and display math",
      "questions": [
        {
          "questionId": "q5",
          "questionText": "What is the limit as $x$ approaches $0$ of $\\frac{\\sin x}{x}$?",
          "options": [
            { "optionId": "opt1", "optionText": "$0$" },
            { "optionId": "opt2", "optionText": "$1$" },
            { "optionId": "opt3", "optionText": "$\\infty$" },
            { "optionId": "opt4", "optionText": "Does not exist" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "This is a fundamental limit: $$\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1$$",
          "type": "mcq"
        }
      ],
      "totalQuestions": 1,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\json-missing-fields.json
SIZE: 1,146 bytes | LINES: 46
================================================================================
{
  "name": "Missing Fields Test",
  "description": "Test module with missing required fields",
  "chapters": [
    {
      "id": "ch1",
      "name": "Incomplete Chapter",
      "questions": [
        {
          "questionId": "q1",
          "questionText": "What is 2 + 2?",
          "options": [
            { "optionId": "opt1", "optionText": "3" },
            { "optionId": "opt2", "optionText": "4" }
          ],
          "correctOptionIds": ["opt2"]
        }
      ],
      "totalQuestions": 1,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    },
    {
      "id": "ch2",
      "name": "Another Incomplete Chapter",
      "questions": [
        {
          "questionId": "q2",
          "questionText": "What is 3 + 3?",
          "options": [
            { "optionId": "opt1", "optionText": "5" },
            { "optionId": "opt2", "optionText": "6" }
          ],
          "correctOptionIds": ["opt2"],
          "explanationText": "3 + 3 equals 6"
        }
      ],
      "totalQuestions": 1,
      "answeredQuestions": 0,
      "correctAnswers": 0,
      "isCompleted": false
    }
  ]
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-code-stoppers.md
SIZE: 1,113 bytes | LINES: 71
================================================================================
# Code Fence Stoppers Test

## Chapter 1: Code Block Handling

### Question 1: Code with internal stoppers

What does this JavaScript code output?

```javascript
function test() {
  console.log('Hello');
  // This is a comment
  return 'World';
}
console.log(test());
```

**Options:**

- A) Hello
- B) World
- C) Hello World
- D) undefined

**Correct:** C

**Explanation:** The function logs "Hello" and returns "World", so the final output is "Hello World".

### Question 2: Code with multiple lines and comments

What is the result of this Python code?

```python
def calculate(x, y):
    # Add two numbers
    result = x + y
    return result

print(calculate(3, 4))
```

**Options:**

- A) 7
- B) 12
- C) Error
- D) None

**Correct:** A

**Explanation:** The function adds 3 + 4 = 7 and prints the result.

### Question 3: Code with special characters

What does this regex match?

```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

**Options:**

- A) Phone numbers
- B) Email addresses
- C) URLs
- D) Passwords

**Correct:** B

**Explanation:** This regex pattern matches valid email addresses.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-duplicate-ids.md
SIZE: 1,006 bytes | LINES: 101
================================================================================
# Duplicate IDs Test

---

## Chapter 1: Duplicate question IDs

---

### Q: First question <!-- ID:duplicate_q -->

What is 2 + 2?

**Options:**

- **A1:** 3
- **A2:** 4
- **A3:** 5
- **A4:** 6

**Correct:** A2

**Exp:** 2 + 2 equals 4.

---

### Q: Duplicate question ID <!-- ID:duplicate_q -->

What is 3 + 3?

**Options:**

- **A1:** 5
- **A2:** 6
- **A3:** 7
- **A4:** 8

**Correct:** A2

**Exp:** 3 + 3 equals 6.

---

## Chapter 2: Duplicate option IDs

---

### Q: Duplicate option IDs

What is 4 + 4?

**Options:**

- **A1:** 6
- **A2:** 7
- **A3:** 8
- **A4:** A

**Correct:** A3

**Exp:** 4 + 4 equals 8.

---

### Q: Mixed duplicates

What is 5 + 5?

**Options:**

- **A1:** 8
- **A2:** 9
- **A3:** 10
- **A4:** 10

**Correct:** A3

**Exp:** 5 + 5 equals 10.

---

## Chapter 3: Cross-chapter duplicates

---

### Q: Same ID as Chapter 1 <!-- ID:duplicate_q -->

What is 6 + 6?

**Options:**

- **A1:** 10
- **A2:** 11
- **A3:** 12
- **A4:** 13

**Correct:** A3

**Exp:** 6 + 6 equals 12.

---


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-mcq-aliases.md
SIZE: 752 bytes | LINES: 49
================================================================================
# MCQ Aliases Test

## Chapter 1: Aliases and Variations

### Question 1: Using "Opt" alias

What is the capital of France?

**Opt:**

- A) London
- B) Berlin
- C) Paris
- D) Madrid

**Ans:** C

**Explanation:** Paris is the capital and largest city of France.

### Question 2: Using "Answer" alias

Which planet is closest to the Sun?

**Options:**

- A) Venus
- B) Mercury
- C) Earth
- D) Mars

**Answer:** B

**Explanation:** Mercury is the closest planet to the Sun in our solar system.

### Question 3: Mixed aliases

What is the largest mammal?

**Opt:**

- A) Elephant
- B) Blue whale
- C) Giraffe
- D) Hippopotamus

**Correct:** B

**Explanation:** The blue whale is the largest mammal and the largest animal ever known to have lived on Earth.


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-mcq-basic.md
SIZE: 1,090 bytes | LINES: 97
================================================================================
# Basic Mathematics Quiz

---

## Chapter 1: Arithmetic Fundamentals

---

### Q: Basic Addition

What is 2 + 2?

**Options:**

- **A1:** 3
- **A2:** 4
- **A3:** 5
- **A4:** 6

**Correct:** A2

**Exp:** 2 + 2 equals 4. This is a fundamental arithmetic operation.

---

### Q: Subtraction

What is 10 - 3?

**Options:**

- **A1:** 6
- **A2:** 7
- **A3:** 8
- **A4:** 9

**Correct:** A2

**Exp:** 10 - 3 equals 7. Subtraction is the inverse operation of addition.

---

### Q: Multiplication

What is 3 × 4?

**Options:**

- **A1:** 10
- **A2:** 11
- **A3:** 12
- **A4:** 13

**Correct:** A3

**Exp:** 3 × 4 equals 12. Multiplication is repeated addition.

---

## Chapter 2: Basic Algebra

---

### Q: Simple Equation

Solve for x: x + 5 = 10

**Options:**

- **A1:** x = 3
- **A2:** x = 4
- **A3:** x = 5
- **A4:** x = 6

**Correct:** A3

**Exp:** x + 5 = 10, so x = 10 - 5 = 5.

---

### Q: Two-step Equation

Solve for y: 2y + 3 = 11

**Options:**

- **A1:** y = 3
- **A2:** y = 4
- **A3:** y = 5
- **A4:** y = 6

**Correct:** A2

**Exp:** 2y + 3 = 11, so 2y = 8, therefore y = 4.

---


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-missing-ids.md
SIZE: 1,031 bytes | LINES: 91
================================================================================
# Missing IDs Test

---

## Chapter 1: Questions without explicit IDs

---

### Q: What is 5 + 3?

**Options:**

- **A1:** 6
- **A2:** 7
- **A3:** 8
- **A4:** 9

**Correct:** A3

**Exp:** 5 + 3 equals 8.

---

### Q: What is the capital of Japan?

**Options:**

- **A1:** Osaka
- **A2:** Tokyo
- **A3:** Kyoto
- **A4:** Hiroshima

**Correct:** A2

**Exp:** Tokyo is the capital and largest city of Japan.

---

### Q: Which is the largest planet?

**Options:**

- **A1:** Earth
- **A2:** Jupiter
- **A3:** Saturn
- **A4:** Neptune

**Correct:** A2

**Exp:** Jupiter is the largest planet in our solar system.

---

## Chapter 2: Mixed ID scenarios

---

### Q: Has explicit ID <!-- ID:explicit_q -->

What is 10 ÷ 2?

**Options:**

- **A1:** 3
- **A2:** 4
- **A3:** 5
- **A4:** 6

**Correct:** A3

**Exp:** 10 ÷ 2 equals 5.

---

### Q: No ID specified

What is the square root of 16?

**Options:**

- **A1:** 2
- **A2:** 3
- **A3:** 4
- **A4:** 5

**Correct:** A3

**Exp:** The square root of 16 is 4, because 4 × 4 = 16.

---


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\md-tf.md
SIZE: 973 bytes | LINES: 58
================================================================================
# True/False Questions Test

---

## Chapter 1: True/False Format

---

### T/F: Basic True/False

The Earth is round.

**Correct:** True

**Exp:** The Earth is approximately spherical in shape, though it's slightly flattened at the poles.

---

### T/F: Another True/False

Water boils at 100°C at sea level.

**Correct:** True

**Exp:** At standard atmospheric pressure (1 atm), water boils at exactly 100°C (212°F).

---

### T/F: False statement

The Sun revolves around the Earth.

**Correct:** False

**Exp:** The Earth revolves around the Sun, not the other way around. This was proven by Copernicus and Galileo.

---

### T/F: Mathematical True/False

2 + 2 = 5

**Correct:** False

**Exp:** 2 + 2 equals 4, not 5. This is basic arithmetic.

---

### T/F: Scientific True/False

Photosynthesis occurs in plant leaves.

**Correct:** True

**Exp:** Photosynthesis primarily occurs in the chloroplasts of plant leaves, where chlorophyll captures light energy.

---


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\fixtures\xss\payloads.ts
SIZE: 1,304 bytes | LINES: 42
================================================================================
// XSS test payloads for regression testing
export const XSS_PAYLOADS = [
  // Script injection
  `<script>alert(1)</script>`,
  `<script>alert('XSS')</script>`,
  `<script>console.log('XSS')</script>`,

  // Event handler injection
  `<img src=x onerror=alert(1)>`,
  `<img src=x onerror="alert(1)">`,
  `<svg onload=alert(1)></svg>`,
  `<div onclick="alert(1)">click me</div>`,

  // JavaScript URL injection
  `<a href="javascript:alert(1)">x</a>`,
  `<a href="javascript:alert('XSS')">x</a>`,
  `<iframe src="javascript:alert(1)"></iframe>`,

  // Data URL injection
  `<img src="data:text/html,<script>alert(1)</script>">`,
  `<iframe src="data:text/html,<script>alert(1)</script>"></iframe>`,

  // CSS injection
  `<style>body{background:url('javascript:alert(1)')}</style>`,
  `<div style="background:url('javascript:alert(1)')"></div>`,

  // Form injection
  `<form action="javascript:alert(1)"><input type="submit"></form>`,
  `<input onfocus="alert(1)" autofocus>`,
];

export const SAFE_CONTENT = [
  // These should pass through
  `<strong>Bold text</strong>`,
  `<em>Italic text</em>`,
  `<p>Paragraph with <a href="https://example.com">link</a></p>`,
  `<ul><li>List item</li></ul>`,
  `<blockquote>Quote</blockquote>`,
  `<code>code snippet</code>`,
  `<pre>preformatted text</pre>`,
];


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\int\rendering\quiz-components.test.tsx
SIZE: 6,159 bytes | LINES: 187
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { QuizModule } from '@/lib/schema/quiz';

// Mock components - these would be the actual components in a real test
const MockQuizSession = ({ module }: { module: QuizModule }) => (
  <div data-testid="quiz-session">
    <h1>{module.name}</h1>
    <div data-testid="chapter-count">{module.chapters.length} chapters</div>
  </div>
);

const MockDashboard = ({ module }: { module: QuizModule }) => (
  <div data-testid="dashboard">
    <h1>Dashboard</h1>
    <div data-testid="module-name">{module.name}</div>
    <div data-testid="total-chapters">{module.chapters.length}</div>
  </div>
);

const MockQuestionEditor = ({ question }: { question: any }) => (
  <div data-testid="question-editor">
    <h2>Edit Question</h2>
    <div data-testid="question-text">{question.questionText}</div>
    <div data-testid="options-count">{question.options.length} options</div>
  </div>
);

describe('Quiz Component Integration Tests', () => {
  const mockModule: QuizModule = {
    name: 'Test Mathematics Module',
    description: 'A comprehensive mathematics course',
    chapters: [
      {
        id: 'ch1',
        name: 'Basic Arithmetic',
        description: 'Fundamental arithmetic operations',
        questions: [
          {
            questionId: 'q1',
            questionText: 'What is 2 + 2?',
            options: [
              { optionId: 'opt1', optionText: '3' },
              { optionId: 'opt2', optionText: '4' },
              { optionId: 'opt3', optionText: '5' },
            ],
            correctOptionIds: ['opt2'],
            explanationText: '2 + 2 equals 4',
            type: 'mcq',
          },
        ],
        totalQuestions: 1,
        answeredQuestions: 0,
        correctAnswers: 0,
        isCompleted: false,
      },
      {
        id: 'ch2',
        name: 'Algebra Basics',
        description: 'Introduction to algebraic concepts',
        questions: [
          {
            questionId: 'q2',
            questionText: 'Solve for x: 2x = 10',
            options: [
              { optionId: 'opt1', optionText: 'x = 5' },
              { optionId: 'opt2', optionText: 'x = 8' },
              { optionId: 'opt3', optionText: 'x = 12' },
            ],
            correctOptionIds: ['opt1'],
            explanationText: 'Divide both sides by 2: x = 10/2 = 5',
            type: 'mcq',
          },
        ],
        totalQuestions: 1,
        answeredQuestions: 0,
        correctAnswers: 0,
        isCompleted: false,
      },
    ],
  };

  describe('QuizSession Component', () => {
    it('should render quiz session with module data', () => {
      render(<MockQuizSession module={mockModule} />);

      expect(screen.getByTestId('quiz-session')).toBeInTheDocument();
      expect(screen.getByText('Test Mathematics Module')).toBeInTheDocument();
      expect(screen.getByText('2 chapters')).toBeInTheDocument();
    });

    it('should display correct chapter count', () => {
      render(<MockQuizSession module={mockModule} />);

      const chapterCount = screen.getByTestId('chapter-count');
      expect(chapterCount).toHaveTextContent('2');
    });
  });

  describe('Dashboard Component', () => {
    it('should render dashboard with module information', () => {
      render(<MockDashboard module={mockModule} />);

      expect(screen.getByTestId('dashboard')).toBeInTheDocument();
      expect(screen.getByTestId('module-name')).toHaveTextContent('Test Mathematics Module');
      expect(screen.getByTestId('total-chapters')).toHaveTextContent('2');
    });

    it('should display module name correctly', () => {
      render(<MockDashboard module={mockModule} />);

      const moduleName = screen.getByTestId('module-name');
      expect(moduleName).toHaveTextContent(mockModule.name);
    });
  });

  describe('QuestionEditor Component', () => {
    it('should render question editor with question data', () => {
      const question = mockModule.chapters[0].questions[0];
      render(<MockQuestionEditor question={question} />);

      expect(screen.getByTestId('question-editor')).toBeInTheDocument();
      expect(screen.getByTestId('question-text')).toHaveTextContent('What is 2 + 2?');
      expect(screen.getByTestId('options-count')).toHaveTextContent('3 options');
    });

    it('should display question text correctly', () => {
      const question = mockModule.chapters[0].questions[0];
      render(<MockQuestionEditor question={question} />);

      const questionText = screen.getByTestId('question-text');
      expect(questionText).toHaveTextContent(question.questionText);
    });
  });

  describe('Component State Management', () => {
    it('should handle module updates correctly', () => {
      const { rerender } = render(<MockDashboard module={mockModule} />);

      expect(screen.getByTestId('total-chapters')).toHaveTextContent('2');

      const updatedModule = {
        ...mockModule,
        chapters: [
          ...mockModule.chapters,
          {
            id: 'ch3',
            name: 'Geometry',
            questions: [],
            totalQuestions: 0,
            answeredQuestions: 0,
            correctAnswers: 0,
            isCompleted: false,
          },
        ],
      };

      rerender(<MockDashboard module={updatedModule} />);
      expect(screen.getByTestId('total-chapters')).toHaveTextContent('3');
    });
  });

  describe('Error Handling', () => {
    it('should handle empty module gracefully', () => {
      const emptyModule: QuizModule = {
        name: 'Empty Module',
        chapters: [],
      };

      render(<MockDashboard module={emptyModule} />);

      expect(screen.getByTestId('total-chapters')).toHaveTextContent('0');
    });

    it('should handle module with no description', () => {
      const moduleWithoutDescription: QuizModule = {
        name: 'Module Without Description',
        chapters: mockModule.chapters,
      };

      render(<MockQuizSession module={moduleWithoutDescription} />);

      expect(screen.getByText('Module Without Description')).toBeInTheDocument();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\meta\static.audits.test.ts
SIZE: 1,470 bytes | LINES: 49
================================================================================
import { readFileSync } from 'fs';
import { globSync } from 'glob';
import { describe, it, expect } from 'vitest';

function grepAll(re: RegExp) {
  const files = globSync('{app,components,lib,utils}/**/*.{ts,tsx,css}', {
    ignore: ['**/node_modules/**'],
  });
  let hits = 0;
  for (const f of files) {
    const s = readFileSync(f, 'utf8');
    const m = s.match(re);
    if (m) hits += m.length;
  }
  return hits;
}

describe('Static Security & Accessibility Audits', () => {
  it('dangerouslySetInnerHTML is quarantined', () => {
    // Count only actual usage, not comments
    const total = grepAll(/dangerouslySetInnerHTML\s*=\s*\{/gi);
    expect(total).toBeLessThanOrEqual(1);
  });

  it('no target="_blank" without rel', () => {
    const total = grepAll(/target="_blank"(?![^>]*rel=)/gi);
    expect(total).toBe(0);
  });

  it('has prefers-reduced-motion gate', () => {
    expect(grepAll(/prefers-reduced-motion/gi)).toBeGreaterThanOrEqual(1);
  });

  it('has at least one aria-live region', () => {
    expect(grepAll(/aria-live/gi)).toBeGreaterThanOrEqual(1);
  });

  it('has no img tags without alt attributes', () => {
    const total = grepAll(/<img(?![^>]*\balt=)/gi);
    expect(total).toBe(0);
  });

  it('has proper role button usage', () => {
    // Should have some role="button" but not on div elements without proper keyboard handling
    const total = grepAll(/role="button"/gi);
    expect(total).toBeGreaterThanOrEqual(1);
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\renderer\sanitize.contract.test.tsx
SIZE: 2,043 bytes | LINES: 60
================================================================================
import { render } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { XSS_PAYLOADS, SAFE_CONTENT } from '../fixtures/xss/payloads';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';

describe('MarkdownRenderer sanitization', () => {
  it.each(XSS_PAYLOADS)('blocks %s', async (payload) => {
    const { container } = render(<MarkdownRenderer markdown={payload} />);
    const html = container.innerHTML;

    // Contract: no scripts, no on* handlers, no javascript: URLs
    expect(html).not.toMatch(/<script/i);
    expect(html).not.toMatch(/\son\w+=/i);
    expect(html).not.toMatch(/javascript:/i);

    // Should not contain the original dangerous content
    expect(html).not.toContain(payload);
  });

  it('shows helpful note when content is stripped', () => {
    const dangerousContent = `<img src=x onerror=1>`;
    const { container } = render(<MarkdownRenderer markdown={dangerousContent} />);

    // Should show a note about unsafe content being removed
    expect(container.innerHTML).toContain('unsafe content was removed');
  });

  it.each(SAFE_CONTENT)('allows safe content: %s', (content) => {
    const { container } = render(<MarkdownRenderer markdown={content} />);
    const html = container.innerHTML;

    // Safe content should pass through
    expect(html).toContain(content);
  });

  it('preserves LaTeX content', () => {
    const latexContent = `$$\\frac{a}{b}$$`;
    const { container } = render(<MarkdownRenderer markdown={latexContent} />);
    const html = container.innerHTML;

    // LaTeX should be preserved
    expect(html).toContain('\\frac{a}{b}');
  });

  it('preserves Mermaid diagrams', () => {
    const mermaidContent = `
\`\`\`mermaid
graph TD
    A[Start] --> B[End]
\`\`\`
`;
    const { container } = render(<MarkdownRenderer markdown={mermaidContent} />);
    const html = container.innerHTML;

    // Mermaid content should be preserved
    expect(html).toContain('mermaid');
    expect(html).toContain('graph TD');
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\setup.ts
SIZE: 765 bytes | LINES: 30
================================================================================
import '@testing-library/jest-dom';
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest's expect with jest-dom matchers
expect.extend(matchers);

// Configure axe for accessibility testing (if available)
let axe: any = null;
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const { configureAxe, toHaveNoViolations } = require('vitest-axe');
  expect.extend(toHaveNoViolations);
  axe = configureAxe({
    rules: {
      region: { enabled: false },
    },
  });
} catch (error) {
  console.warn('vitest-axe not available:', error);
}

export { axe };

// Cleanup after each test
afterEach(() => {
  cleanup();
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\parser\id-uniqueness.test.ts
SIZE: 4,676 bytes | LINES: 174
================================================================================
import { describe, it, expect } from 'vitest';
import { parseMarkdownToQuizModule } from '@/utils/quiz-validation';

describe('Global ID Uniqueness Validation', () => {
  it('should detect duplicate chapter IDs across the entire module', () => {
    const markdown = `# Test Module
## Chapter 1: First Chapter <!-- ID:duplicate_id -->
### Q: Question 1
What is 2+2?
**Options:**
- A) 3
- B) 4
**Correct:** B
**Exp:** 2+2=4

## Chapter 2: Second Chapter <!-- ID:duplicate_id -->
### Q: Question 2
What is 3+3?
**Options:**
- A) 5
- B) 6
**Correct:** B
**Exp:** 3+3=6`;

    const result = parseMarkdownToQuizModule(markdown);

    // Should still parse but with warnings
    expect(result.success).toBe(true);
    expect(result.errors.some((e) => e.includes('Duplicate Chapter ID'))).toBe(true);

    // Both chapters should exist but with warnings
    expect(result.quizModule?.chapters).toHaveLength(2);
  });

  it('should detect duplicate question IDs across all chapters', () => {
    const markdown = `# Test Module
## Chapter 1: First Chapter
### Q: Question 1 <!-- ID:duplicate_q -->
What is 2+2?
**Options:**
- A) 3
- B) 4
**Correct:** B
**Exp:** 2+2=4

## Chapter 2: Second Chapter
### Q: Question 2 <!-- ID:duplicate_q -->
What is 3+3?
**Options:**
- A) 5
- B) 6
**Correct:** B
**Exp:** 3+3=6`;

    const result = parseMarkdownToQuizModule(markdown);

    // Should still parse but with warnings
    expect(result.success).toBe(true);
    expect(result.errors.some((e) => e.includes('Duplicate Question ID'))).toBe(true);

    // Both questions should exist but with warnings
    const allQuestions = result.quizModule?.chapters.flatMap((c) => c.questions) || [];
    expect(allQuestions).toHaveLength(2);
  });

  it('should generate unique IDs when duplicates are detected', () => {
    const markdown = `# Test Module
## Chapter 1: First Chapter
### Q: Question 1 <!-- ID:duplicate_id -->
What is 2+2?
**Options:**
- A) 3
- B) 4
**Correct:** B
**Exp:** 2+2=4

## Chapter 2: Second Chapter
### Q: Question 2 <!-- ID:duplicate_id -->
What is 3+3?
**Options:**
- A) 5
- B) 6
**Correct:** B
**Exp:** 3+3=6`;

    const result = parseMarkdownToQuizModule(markdown);

    expect(result.success).toBe(true);

    // All question IDs should be unique
    const allQuestionIds =
      result.quizModule?.chapters.flatMap((c) => c.questions).map((q) => q.questionId) || [];
    const uniqueQuestionIds = new Set(allQuestionIds);
    expect(uniqueQuestionIds.size).toBe(allQuestionIds.length);

    // All chapter IDs should be unique
    const allChapterIds = result.quizModule?.chapters.map((c) => c.id) || [];
    const uniqueChapterIds = new Set(allChapterIds);
    expect(uniqueChapterIds.size).toBe(allChapterIds.length);
  });

  it('should validate option ID uniqueness within each question', () => {
    const markdown = `# Test Module
## Chapter 1: Test Chapter
### Q: Question with duplicate option IDs
What is 2+2?
**Options:**
- A) 3
- B) 4
- C) 5
- A) 6
**Correct:** B
**Exp:** 2+2=4`;

    const result = parseMarkdownToQuizModule(markdown);

    expect(result.success).toBe(true);

    const question = result.quizModule?.chapters[0].questions[0];
    expect(question).toBeDefined();

    // Option IDs should be unique within the question
    const optionIds = question?.options.map((o) => o.optionId) || [];
    const uniqueOptionIds = new Set(optionIds);
    expect(uniqueOptionIds.size).toBe(optionIds.length);
  });

  it('should handle mixed ID scenarios (some explicit, some generated)', () => {
    const markdown = `# Test Module
## Chapter 1: First Chapter <!-- ID:explicit_ch1 -->
### Q: Question with explicit ID <!-- ID:explicit_q1 -->
What is 2+2?
**Options:**
- A) 3
- B) 4
**Correct:** B
**Exp:** 2+2=4

### Q: Question without ID
What is 3+3?
**Options:**
- A) 5
- B) 6
**Correct:** B
**Exp:** 3+3=6

## Chapter 2: Second Chapter
### Q: Another question without ID
What is 4+4?
**Options:**
- A) 7
- B) 8
**Correct:** B
**Exp:** 4+4=8`;

    const result = parseMarkdownToQuizModule(markdown);

    expect(result.success).toBe(true);
    expect(result.quizModule?.chapters).toHaveLength(2);

    // First chapter should have explicit ID
    expect(result.quizModule?.chapters[0].id).toBe('explicit_ch1');

    // First question should have explicit ID
    expect(result.quizModule?.chapters[0].questions[0].questionId).toBe('explicit_q1');

    // Other questions should have generated IDs
    const allQuestionIds =
      result.quizModule?.chapters.flatMap((c) => c.questions).map((q) => q.questionId) || [];
    const uniqueQuestionIds = new Set(allQuestionIds);
    expect(uniqueQuestionIds.size).toBe(allQuestionIds.length);
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\parser\markdown-parser.test.ts
SIZE: 10,879 bytes | LINES: 313
================================================================================
import { describe, it, expect } from 'vitest';
import { parseMarkdownToQuizModule } from '@/utils/quiz-validation';
import { readFileSync } from 'fs';
import { join } from 'path';

// Test fixtures
const fixturesDir = join(process.cwd(), 'tests', 'fixtures');

const loadFixture = (filename: string): string => {
  return readFileSync(join(fixturesDir, filename), 'utf-8');
};

describe('Markdown Parser Tests (TM-PR-01..06)', () => {
  describe('TM-PR-01: Basic MCQ Parsing', () => {
    it('should parse basic MCQ format correctly', () => {
      const markdown = loadFixture('md-mcq-basic.md');
      const result = parseMarkdownToQuizModule(markdown);

      expect(result.success).toBe(true);
      expect(result.quizModule).toBeDefined();
      expect(result.quizModule?.name).toBe('Basic Mathematics Quiz');
      expect(result.quizModule?.chapters).toHaveLength(2);

      // Check first chapter
      const chapter1 = result.quizModule?.chapters[0];
      expect(chapter1?.name).toBe('Chapter 1: Arithmetic Fundamentals');
      expect(chapter1?.questions).toHaveLength(3);

      // Check first question
      const question1 = chapter1?.questions[0];
      expect(question1?.questionText).toContain('What is 2 + 2?');
      expect(question1?.options).toHaveLength(4);
      expect(question1?.correctOptionIds).toHaveLength(1);
      expect(question1?.type).toBe('mcq');
    });

    it('should handle questions without explicit IDs by generating them', () => {
      const markdown = loadFixture('md-missing-ids.md');
      const result = parseMarkdownToQuizModule(markdown);

      expect(result.success).toBe(true);
      expect(result.quizModule).toBeDefined();

      // All questions should have generated IDs
      const allQuestions = result.quizModule?.chapters.flatMap((c) => c.questions) || [];
      allQuestions.forEach((question) => {
        expect(question.questionId).toBeDefined();
        expect(question.questionId.length).toBeGreaterThan(0);
      });
    });
  });

  describe('TM-PR-02: True/False Question Parsing', () => {
    it('should parse true/false questions correctly', () => {
      const markdown = loadFixture('md-tf.md');
      const result = parseMarkdownToQuizModule(markdown);

      expect(result.success).toBe(true);
      expect(result.quizModule).toBeDefined();

      const allQuestions = result.quizModule?.chapters.flatMap((c) => c.questions) || [];
      allQuestions.forEach((question) => {
        expect(question.type).toBe('true_false');
        expect(question.options).toHaveLength(2);
        expect(question.options[0].optionId).toBe('true');
        expect(question.options[0].optionText).toBe('True');
        expect(question.options[1].optionId).toBe('false');
        expect(question.options[1].optionText).toBe('False');
        expect(question.correctOptionIds).toHaveLength(1);
        expect(['true', 'false']).toContain(question.correctOptionIds[0]);
      });
    });

    it('should reject T/F questions with Options block', () => {
      const markdown = `# Test Module
## Chapter 1
### T/F: Test question
**Options:**
- A) True
- B) False
**Correct:** True
**Exp:** Test explanation`;

      const result = parseMarkdownToQuizModule(markdown);
      expect(result.success).toBe(false);
      expect(result.errors.some((e) => e.includes("T/F questions cannot have an 'Options:'"))).toBe(
        true,
      );
    });
  });

  describe('TM-PR-03: ID Uniqueness Validation', () => {
    it('should detect and report duplicate question IDs', () => {
      const markdown = loadFixture('md-duplicate-ids.md');
      const result = parseMarkdownToQuizModule(markdown);

      // Should still parse but with warnings
      expect(result.success).toBe(true);
      expect(result.errors.some((e) => e.includes('Duplicate Question ID'))).toBe(true);
    });

    it('should generate unique IDs when duplicates are detected', () => {
      const markdown = loadFixture('md-duplicate-ids.md');
      const result = parseMarkdownToQuizModule(markdown);

      expect(result.success).toBe(true);
      const allQuestionIds =
        result.quizModule?.chapters.flatMap((c) => c.questions).map((q) => q.questionId) || [];
      const uniqueIds = new Set(allQuestionIds);
      expect(uniqueIds.size).toBe(allQuestionIds.length);
    });
  });

  describe('TM-PR-04: Error Recovery and Robustness', () => {
    it('should recover from malformed questions and continue parsing', () => {
      const markdown = `# Test Module
## Chapter 1
### Q: Valid question
**Options:**
- A) Option 1
- B) Option 2
**Correct:** A
**Exp:** Valid explanation

### Q: Malformed question
**Options:**
- Missing correct answer
**Exp:** This should be skipped

### Q: Another valid question
**Options:**
- A) Option 1
- B) Option 2
**Correct:** A
**Exp:** Another valid explanation`;

      const result = parseMarkdownToQuizModule(markdown);
      expect(result.success).toBe(true);
      expect(result.quizModule?.chapters[0].questions).toHaveLength(2); // Should skip malformed question
    });

    it('should handle code blocks in question text correctly', () => {
      const markdown = `# Test Module
## Chapter 1
### Q: Code question
Here's some code:
\`\`\`javascript
function test() {
  return "hello";
}
\`\`\`
What does this return?

**Options:**
- A) "hello"
- B) "world"
**Correct:** A
**Exp:** The function returns the string "hello".`;

      const result = parseMarkdownToQuizModule(markdown);
      expect(result.success).toBe(true);
      const question = result.quizModule?.chapters[0].questions[0];
      expect(question?.questionText).toContain('```javascript');
      expect(question?.questionText).toContain('function test()');
    });
  });

  describe('TM-PR-05: Schema Validation Integration', () => {
    it('should validate parsed data against QuizModule schema', () => {
      const markdown = loadFixture('md-mcq-basic.md');
      const result = parseMarkdownToQuizModule(markdown);

      expect(result.success).toBe(true);
      expect(result.quizModule).toBeDefined();

      // The result should be a valid QuizModule
      const module = result.quizModule!;
      expect(module.name).toBeDefined();
      expect(Array.isArray(module.chapters)).toBe(true);
      expect(module.chapters.length).toBeGreaterThan(0);

      module.chapters.forEach((chapter) => {
        expect(chapter.id).toBeDefined();
        expect(chapter.name).toBeDefined();
        expect(Array.isArray(chapter.questions)).toBe(true);
        expect(chapter.questions.length).toBeGreaterThan(0);

        chapter.questions.forEach((question) => {
          expect(question.questionId).toBeDefined();
          expect(question.questionText).toBeDefined();
          expect(Array.isArray(question.options)).toBe(true);
          expect(question.options.length).toBeGreaterThanOrEqual(2);
          expect(Array.isArray(question.correctOptionIds)).toBe(true);
          expect(question.correctOptionIds.length).toBeGreaterThan(0);
          expect(question.explanationText).toBeDefined();
        });
      });
    });
  });

  describe('TM-PR-06: Performance and Edge Cases', () => {
    it('should handle large markdown files efficiently', () => {
      // Create a large markdown file with many questions
      let markdown = `# Large Test Module
## Chapter 1: Many Questions
`;

      for (let i = 1; i <= 100; i++) {
        markdown += `### Q: Question ${i}
What is ${i} + ${i}?

**Options:**
- A) ${i * 2 - 1}
- B) ${i * 2}
- C) ${i * 2 + 1}
**Correct:** B
**Exp:** ${i} + ${i} = ${i * 2}

`;
      }

      const startTime = Date.now();
      const result = parseMarkdownToQuizModule(markdown);
      const endTime = Date.now();

      expect(result.success).toBe(true);
      expect(result.quizModule?.chapters[0].questions).toHaveLength(100);
      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
    });

    it('should handle empty or minimal markdown gracefully', () => {
      const emptyMarkdown = `# Empty Module`;
      const result = parseMarkdownToQuizModule(emptyMarkdown);

      expect(result.success).toBe(false);
      expect(result.errors.some((e) => e.includes('No valid chapters found'))).toBe(true);
    });

    it('should handle markdown with only whitespace', () => {
      const whitespaceMarkdown = `   \n\n   \n   `;
      const result = parseMarkdownToQuizModule(whitespaceMarkdown);

      expect(result.success).toBe(false);
      expect(result.errors.some((e) => e.includes('Expected module title'))).toBe(true);
    });
  });
});

describe('LaTeX Correction Tests (TM-LX-02)', () => {
  it('should apply conservative LaTeX corrections idempotently', async () => {
    const { correctLatexInJsonContent } = await import('@/utils/quiz-validation');

    const jsonWithLatex = JSON.stringify(
      {
        question: 'What is $\\frac{1}{2}$ + $\\frac{1}{3}$?',
        explanation:
          'The answer is $\\frac{5}{6}$ using $\\frac{a}{b} + \\frac{c}{d} = \\frac{ad + bc}{bd}$',
      },
      null,
      2,
    );

    // First correction
    const result1 = correctLatexInJsonContent(jsonWithLatex);
    expect(result1.correctionsMade).toBeGreaterThan(0);

    // Second correction should be idempotent (no more corrections)
    const result2 = correctLatexInJsonContent(result1.correctedContent);
    expect(result2.correctionsMade).toBe(0);
    expect(result2.correctedContent).toBe(result1.correctedContent);
  });

  it('should only correct LaTeX within $...$ delimiters', async () => {
    const { correctLatexInJsonContent } = await import('@/utils/quiz-validation');

    const jsonWithMixedContent = JSON.stringify(
      {
        question: 'What is \\alpha + \\beta?', // Should NOT be corrected
        explanation: 'The answer is $\\alpha + \\beta$', // Should be corrected
      },
      null,
      2,
    );

    const result = correctLatexInJsonContent(jsonWithMixedContent);

    const parsed = JSON.parse(result.correctedContent);
    expect(parsed.question).toBe('What is \\alpha + \\beta?'); // Unchanged
    expect(parsed.explanation).toContain('\\\\alpha + \\\\beta'); // Corrected
  });

  it('should handle complex LaTeX expressions correctly', async () => {
    const { correctLatexInJsonContent } = await import('@/utils/quiz-validation');

    const complexLatex = JSON.stringify(
      {
        question: 'Solve: $\\int_0^1 x^2 dx = \\left[\\frac{x^3}{3}\\right]_0^1$',
        explanation: 'Using the power rule: $\\frac{d}{dx}[x^n] = nx^{n-1}$',
      },
      null,
      2,
    );

    const result = correctLatexInJsonContent(complexLatex);
    expect(result.correctionsMade).toBeGreaterThan(0);

    const parsed = JSON.parse(result.correctedContent);
    expect(parsed.question).toContain('\\\\int');
    expect(parsed.question).toContain('\\\\frac');
    expect(parsed.explanation).toContain('\\\\frac');
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\parser\quiz-schema.test.ts
SIZE: 7,166 bytes | LINES: 239
================================================================================
import { describe, it, expect } from 'vitest';
import {
  QuizOptionSchema,
  QuizQuestionSchema,
  QuizChapterSchema,
  QuizModuleSchema,
  parseQuizModule,
  assertQuizModule,
  validateQuizModule,
  safeParseQuizModule,
} from '@/lib/schema/quiz';

describe('Quiz Schema Validation', () => {
  describe('QuizOptionSchema', () => {
    it('should validate a valid quiz option', () => {
      const validOption = {
        optionId: 'opt1',
        optionText: 'Option 1',
      };
      expect(() => QuizOptionSchema.parse(validOption)).not.toThrow();
    });

    it('should reject option with empty optionId', () => {
      const invalidOption = {
        optionId: '',
        optionText: 'Option 1',
      };
      expect(() => QuizOptionSchema.parse(invalidOption)).toThrow();
    });

    it('should reject option with empty optionText', () => {
      const invalidOption = {
        optionId: 'opt1',
        optionText: '',
      };
      expect(() => QuizOptionSchema.parse(invalidOption)).toThrow();
    });
  });

  describe('QuizQuestionSchema', () => {
    it('should validate a valid MCQ question', () => {
      const validQuestion = {
        questionId: 'q1',
        questionText: 'What is 2+2?',
        options: [
          { optionId: 'opt1', optionText: '3' },
          { optionId: 'opt2', optionText: '4' },
          { optionId: 'opt3', optionText: '5' },
        ],
        correctOptionIds: ['opt2'],
        explanationText: '2+2 equals 4',
        type: 'mcq' as const,
      };
      expect(() => QuizQuestionSchema.parse(validQuestion)).not.toThrow();
    });

    it('should validate a true/false question', () => {
      const validQuestion = {
        questionId: 'q1',
        questionText: 'The sky is blue.',
        options: [
          { optionId: 'opt1', optionText: 'True' },
          { optionId: 'opt2', optionText: 'False' },
        ],
        correctOptionIds: ['opt1'],
        explanationText: 'The sky appears blue due to Rayleigh scattering.',
        type: 'true_false' as const,
      };
      expect(() => QuizQuestionSchema.parse(validQuestion)).not.toThrow();
    });

    it('should reject question with less than 2 options', () => {
      const invalidQuestion = {
        questionId: 'q1',
        questionText: 'What is 2+2?',
        options: [{ optionId: 'opt1', optionText: '3' }],
        correctOptionIds: ['opt1'],
        explanationText: 'Only one option',
      };
      expect(() => QuizQuestionSchema.parse(invalidQuestion)).toThrow();
    });

    it('should reject question with no correct options', () => {
      const invalidQuestion = {
        questionId: 'q1',
        questionText: 'What is 2+2?',
        options: [
          { optionId: 'opt1', optionText: '3' },
          { optionId: 'opt2', optionText: '4' },
        ],
        correctOptionIds: [],
        explanationText: 'No correct options',
      };
      expect(() => QuizQuestionSchema.parse(invalidQuestion)).toThrow();
    });
  });

  describe('QuizChapterSchema', () => {
    it('should validate a valid chapter', () => {
      const validChapter = {
        id: 'ch1',
        name: 'Basic Math',
        description: 'Introduction to basic mathematics',
        questions: [
          {
            questionId: 'q1',
            questionText: 'What is 2+2?',
            options: [
              { optionId: 'opt1', optionText: '3' },
              { optionId: 'opt2', optionText: '4' },
            ],
            correctOptionIds: ['opt2'],
            explanationText: '2+2 equals 4',
          },
        ],
        totalQuestions: 1,
        answeredQuestions: 0,
        correctAnswers: 0,
        isCompleted: false,
      };
      expect(() => QuizChapterSchema.parse(validChapter)).not.toThrow();
    });

    it('should reject chapter with no questions', () => {
      const invalidChapter = {
        id: 'ch1',
        name: 'Empty Chapter',
        questions: [],
        totalQuestions: 0,
        answeredQuestions: 0,
        correctAnswers: 0,
        isCompleted: false,
      };
      expect(() => QuizChapterSchema.parse(invalidChapter)).toThrow();
    });
  });

  describe('QuizModuleSchema', () => {
    it('should validate a valid module', () => {
      const validModule = {
        name: 'Mathematics 101',
        description: 'Basic mathematics course',
        chapters: [
          {
            id: 'ch1',
            name: 'Basic Math',
            questions: [
              {
                questionId: 'q1',
                questionText: 'What is 2+2?',
                options: [
                  { optionId: 'opt1', optionText: '3' },
                  { optionId: 'opt2', optionText: '4' },
                ],
                correctOptionIds: ['opt2'],
                explanationText: '2+2 equals 4',
              },
            ],
            totalQuestions: 1,
            answeredQuestions: 0,
            correctAnswers: 0,
            isCompleted: false,
          },
        ],
      };
      expect(() => QuizModuleSchema.parse(validModule)).not.toThrow();
    });

    it('should reject module with no chapters', () => {
      const invalidModule = {
        name: 'Empty Module',
        chapters: [],
      };
      expect(() => QuizModuleSchema.parse(invalidModule)).toThrow();
    });
  });

  describe('Parser Functions', () => {
    const validModule = {
      name: 'Test Module',
      chapters: [
        {
          id: 'ch1',
          name: 'Test Chapter',
          questions: [
            {
              questionId: 'q1',
              questionText: 'Test question?',
              options: [
                { optionId: 'opt1', optionText: 'Option 1' },
                { optionId: 'opt2', optionText: 'Option 2' },
              ],
              correctOptionIds: ['opt1'],
              explanationText: 'Test explanation',
            },
          ],
          totalQuestions: 1,
          answeredQuestions: 0,
          correctAnswers: 0,
          isCompleted: false,
        },
      ],
    };

    it('should parse valid module with parseQuizModule', () => {
      expect(() => parseQuizModule(validModule)).not.toThrow();
    });

    it('should assert valid module with assertQuizModule', () => {
      expect(() => assertQuizModule(validModule)).not.toThrow();
    });

    it('should validate module with validateQuizModule', () => {
      const result = validateQuizModule(validModule);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.name).toBe('Test Module');
      }
    });

    it('should safely parse module with safeParseQuizModule', () => {
      const result = safeParseQuizModule(validModule);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.name).toBe('Test Module');
      }
    });

    it('should handle invalid data gracefully', () => {
      const invalidData = { name: '', chapters: [] };
      const result = safeParseQuizModule(invalidData);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues).toHaveLength(2); // name and chapters errors
      }
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\current-functionality.test.tsx
SIZE: 7,722 bytes | LINES: 188
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('Current SecureTextRenderer Functionality', () => {
  describe('Basic Text Rendering', () => {
    it('should render plain text', () => {
      const content = 'This is plain text';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('This is plain text')).toBeInTheDocument();
      expect(container.querySelector('.secure-text-renderer')).toBeInTheDocument();
    });

    it('should render markdown bold text', () => {
      const content = 'This is **bold text** and normal text';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText(/This is/)).toBeInTheDocument();
      expect(screen.getByText('bold text')).toBeInTheDocument();
      expect(screen.getByText(/and normal text/)).toBeInTheDocument();

      const strongElement = container.querySelector('strong');
      expect(strongElement).toBeInTheDocument();
      expect(strongElement?.textContent).toBe('bold text');
    });

    it('should render markdown italic text', () => {
      const content = 'This is *italic text* and normal text';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText(/This is/)).toBeInTheDocument();
      expect(screen.getByText('italic text')).toBeInTheDocument();
      expect(screen.getByText(/and normal text/)).toBeInTheDocument();

      const emElement = container.querySelector('em');
      expect(emElement).toBeInTheDocument();
      expect(emElement?.textContent).toBe('italic text');
    });

    it('should render inline code', () => {
      const content = 'This is `inline code` and normal text';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText(/This is/)).toBeInTheDocument();
      expect(screen.getByText('inline code')).toBeInTheDocument();
      expect(screen.getByText(/and normal text/)).toBeInTheDocument();

      const codeElement = container.querySelector('code');
      expect(codeElement).toBeInTheDocument();
      expect(codeElement?.textContent).toBe('inline code');
    });

    it('should render headers', () => {
      const content = '# Header 1\n## Header 2\n### Header 3';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Header 1')).toBeInTheDocument();
      expect(screen.getByText('Header 2')).toBeInTheDocument();
      expect(screen.getByText('Header 3')).toBeInTheDocument();

      const h1 = container.querySelector('h1');
      const h2 = container.querySelector('h2');
      const h3 = container.querySelector('h3');

      expect(h1).toBeInTheDocument();
      expect(h2).toBeInTheDocument();
      expect(h3).toBeInTheDocument();
    });

    it('should render lists', () => {
      const content = 'Unordered list:\n- Item 1\n- Item 2\n\nOrdered list:\n1. First\n2. Second';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText(/Unordered list:/)).toBeInTheDocument();
      expect(screen.getByText('Item 1')).toBeInTheDocument();
      expect(screen.getByText('Item 2')).toBeInTheDocument();
      expect(screen.getByText(/Ordered list:/)).toBeInTheDocument();
      expect(screen.getByText('First')).toBeInTheDocument();
      expect(screen.getByText('Second')).toBeInTheDocument();

      const ul = container.querySelector('ul');
      const ol = container.querySelector('ol');

      expect(ul).toBeInTheDocument();
      expect(ol).toBeInTheDocument();
    });

    it('should render links safely', () => {
      const content = 'Visit [Google](https://google.com) for search';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText(/Visit/)).toBeInTheDocument();
      expect(screen.getByText('Google')).toBeInTheDocument();
      expect(screen.getByText(/for search/)).toBeInTheDocument();

      const link = container.querySelector('a');
      expect(link).toBeInTheDocument();
      expect(link?.getAttribute('href')).toBe('https://google.com');
    });
  });

  describe('Security Features', () => {
    it('should escape script tags', () => {
      const content = '<script>alert("XSS")</script>';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should not contain executable script
      expect(screen.queryByText('alert("XSS")')).not.toBeInTheDocument();
      expect(container.querySelector('script')).toBeNull();

      // Should contain escaped content
      expect(container.innerHTML).toContain('&lt;script&gt;');
    });

    it('should reject javascript: URLs', () => {
      const content = '[Click me](javascript:alert("XSS"))';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should not render as a link, just as text
      expect(screen.getByText(/Click me/)).toBeInTheDocument();
      // Should not contain javascript: in the HTML
      expect(container.innerHTML).not.toContain('javascript:');
    });

    it('should escape event handlers', () => {
      const content = '<img src="x" onerror="alert(\'XSS\')">';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should contain escaped content (the content is detected as raw HTML and escaped)
      expect(container.innerHTML).toContain('&lt;img');
      expect(container.innerHTML).toContain('&gt;');
      // Should not contain actual executable onerror
      expect(container.innerHTML).not.toContain('<img');
    });

    it('should escape dangerous HTML attributes', () => {
      const content = '<div onclick="alert(\'XSS\')">Click me</div>';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should contain escaped content
      expect(container.innerHTML).toContain('&lt;div');
      expect(container.innerHTML).toContain('&gt;');
      // Should not contain actual executable onclick (but the wrapper div is allowed)
      expect(container.innerHTML).not.toContain('onclick=&quot;alert');
    });
  });

  describe('Current Limitations', () => {
    it('should render LaTeX correctly', () => {
      const content = 'The formula is $x = y + z$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should render LaTeX properly
      expect(screen.getByText(/The formula is/)).toBeInTheDocument();

      // Should have KaTeX elements
      const katexElements = container.querySelectorAll('.katex');
      expect(katexElements.length).toBe(1);
    });

    it('should not render code blocks yet', () => {
      const content = '```javascript\nfunction test() {}\n```';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should render as plain text for now
      expect(screen.getByText(/javascript/)).toBeInTheDocument();

      // Should not have code block elements yet
      const preElement = container.querySelector('pre');
      expect(preElement).toBeNull();
    });

    it('should not render tables yet', () => {
      const content = '| Header | Value |\n|--------|-------|\n| Test   | Data  |';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Should render as plain text for now
      expect(screen.getByText(/Header/)).toBeInTheDocument();

      // Should not have table elements yet
      const tableElement = container.querySelector('table');
      expect(tableElement).toBeNull();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\latex-functionality.test.tsx
SIZE: 7,311 bytes | LINES: 206
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('LaTeX Functionality Tests', () => {
  describe('Inline Math Rendering', () => {
    it('should render inline math correctly', async () => {
      const content = 'The formula is $x = y + z$ in the text.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Wait for KaTeX to load and render
      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );

      // Should contain the text parts
      expect(screen.getByText(/The formula is/)).toBeInTheDocument();
      expect(screen.getByText(/in the text/)).toBeInTheDocument();
    });

    it('should render multiple inline math expressions', async () => {
      const content = 'First: $a^2 + b^2 = c^2$ and second: $E = mc^2$.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle inline math with special characters', async () => {
      const content = 'Greek letters: $\\alpha, \\beta, \\gamma$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should handle inline math with fractions', async () => {
      const content = 'Fraction: $\\frac{1}{2}$ and $\\frac{a}{b}$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Display Math Rendering', () => {
    it('should render display math correctly', async () => {
      const content = 'The equation is:\n\n$$x^2 + y^2 = z^2$$\n\nEnd of equation.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );

      expect(screen.getByText(/The equation is:/)).toBeInTheDocument();
      expect(screen.getByText(/End of equation/)).toBeInTheDocument();
    });

    it('should render multiple display math expressions', async () => {
      const content = 'First equation:\n$$E = mc^2$$\n\nSecond equation:\n$$F = ma$$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex-display');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle display math with complex expressions', async () => {
      const content =
        'Complex equation:\n$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should handle display math with matrices', async () => {
      const content = 'Matrix:\n$$\\begin{pmatrix}\na & b \\\\\nc & d\n\\end{pmatrix}$$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Mixed Math and Text', () => {
    it('should handle inline and display math in the same content', async () => {
      const content =
        'The inline formula is $x = y$ and the display formula is:\n\n$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$\n\nMore text with $\\alpha$ symbol.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const allKatexElements = container.querySelectorAll('.katex');
          const displayElements = container.querySelectorAll('.katex-display');
          const inlineElements = allKatexElements.length - displayElements.length;
          expect(inlineElements).toBe(2);
          expect(displayElements.length).toBe(1);
        },
        { timeout: 3000 },
      );
    });

    it('should handle math within lists', async () => {
      const content =
        'List with math:\n- First item with $x = 1$\n- Second item with display math:\n  $$y = 2x + 3$$\n- Third item with $\\alpha$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const allKatexElements = container.querySelectorAll('.katex');
          const displayElements = container.querySelectorAll('.katex-display');
          const inlineElements = allKatexElements.length - displayElements.length;
          expect(inlineElements).toBe(2);
          expect(displayElements.length).toBe(1);
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed LaTeX gracefully', async () => {
      const content = 'Malformed: $\\invalid{command}$ and $\\frac{1}{2$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          // Should still render something, even if it's an error
          const katexElements = container.querySelectorAll('.katex');
          const katexErrorElements = container.querySelectorAll('.katex-error');
          expect(katexElements.length + katexErrorElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle empty math expressions', async () => {
      const content = 'Empty: $$ and $ $';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          // Should handle gracefully without crashing
          expect(container).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Security', () => {
    it('should use trust: false for security', async () => {
      const content = 'Test: $x = y$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
          // The element should be rendered, indicating trust: false is working
        },
        { timeout: 3000 },
      );
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\markdown-import-comprehensive.test.tsx
SIZE: 21,543 bytes | LINES: 588
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('Comprehensive Markdown Import Tests', () => {
  describe('Basic Text Formatting', () => {
    it('should handle plain text without any formatting', () => {
      const content = 'This is plain text with no special formatting.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(
        screen.getByText('This is plain text with no special formatting.'),
      ).toBeInTheDocument();
    });

    it('should handle text with multiple paragraphs', () => {
      const content = `First paragraph.

Second paragraph with more content.

Third paragraph with even more detailed information.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.textContent).toContain('First paragraph.');
      expect(container.textContent).toContain('Second paragraph with more content.');
      expect(container.textContent).toContain(
        'Third paragraph with even more detailed information.',
      );
    });

    it('should handle text with line breaks', () => {
      const content = `Line 1
Line 2
Line 3`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.textContent).toContain('Line 1');
      expect(container.textContent).toContain('Line 2');
      expect(container.textContent).toContain('Line 3');
    });
  });

  describe('Headers', () => {
    it('should render all header levels correctly', () => {
      const content = `# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.querySelector('h1')).toBeInTheDocument();
      expect(container.querySelector('h2')).toBeInTheDocument();
      expect(container.querySelector('h3')).toBeInTheDocument();
      expect(container.querySelector('h4')).toBeInTheDocument();
      expect(container.querySelector('h5')).toBeInTheDocument();
      expect(container.querySelector('h6')).toBeInTheDocument();

      expect(screen.getByText('Header 1')).toBeInTheDocument();
      expect(screen.getByText('Header 2')).toBeInTheDocument();
      expect(screen.getByText('Header 3')).toBeInTheDocument();
    });

    it('should handle headers with special characters', () => {
      const content = `# Header with **bold** text
## Header with *italic* text
### Header with \`code\` text`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.querySelector('h1')).toBeInTheDocument();
      expect(container.querySelector('h2')).toBeInTheDocument();
      expect(container.querySelector('h3')).toBeInTheDocument();
    });
  });

  describe('Text Emphasis', () => {
    it('should handle bold text with ** and __', () => {
      const content = `This is **bold text** and this is __also bold__.
This has **multiple** **bold** **words**.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const strongElements = container.querySelectorAll('strong');
      expect(strongElements.length).toBe(5); // Updated to match actual behavior
      expect(screen.getByText('bold text')).toBeInTheDocument();
      expect(screen.getByText('also bold')).toBeInTheDocument();
    });

    it('should handle italic text with * and _', () => {
      const content = `This is *italic text* and this is _also italic_.
This has *multiple* *italic* *words*.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const emElements = container.querySelectorAll('em');
      expect(emElements.length).toBe(5); // Updated to match actual behavior
      expect(screen.getByText('italic text')).toBeInTheDocument();
      expect(screen.getByText('also italic')).toBeInTheDocument();
    });

    it('should handle strikethrough text', () => {
      const content = `This is ~~strikethrough text~~ and this is ~~also strikethrough~~.
This has ~~multiple~~ ~~strikethrough~~ ~~words~~.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const delElements = container.querySelectorAll('del');
      expect(delElements.length).toBe(5); // Updated to match actual behavior
      expect(screen.getByText('strikethrough text')).toBeInTheDocument();
      expect(screen.getByText('also strikethrough')).toBeInTheDocument();
    });

    it('should handle mixed emphasis', () => {
      const content = `This is **bold and *italic* text** and this is ~~strikethrough with **bold**~~.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.querySelector('strong')).toBeInTheDocument();
      expect(container.querySelector('em')).toBeInTheDocument();
      expect(container.querySelector('del')).toBeInTheDocument();
    });
  });

  describe('Code', () => {
    it('should handle inline code', () => {
      const content = `Use \`console.log()\` to debug and \`const x = 1\` to declare variables.
Multiple \`code\` \`snippets\` in one line.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const codeElements = container.querySelectorAll('code');
      expect(codeElements.length).toBe(4);
      expect(screen.getByText('console.log()')).toBeInTheDocument();
      expect(screen.getByText('const x = 1')).toBeInTheDocument();
    });

    it('should handle code blocks', () => {
      const content = `\`\`\`javascript
function hello() {
  console.log("Hello, World!");
  return true;
}
\`\`\`

\`\`\`python
def hello():
    print("Hello, World!")
    return True
\`\`\``;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const preElements = container.querySelectorAll('pre');
      expect(preElements.length).toBe(2);

      const codeElements = container.querySelectorAll('pre code');
      expect(codeElements.length).toBe(2);
    });

    it('should handle code blocks with special characters', () => {
      const content = `\`\`\`html
<div class="container">
  <h1>Title</h1>
  <p>Content with <strong>bold</strong> text</p>
</div>
\`\`\``;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Check if the content is preserved in the code block
      expect(container.textContent).toContain('Title');
      expect(container.textContent).toContain('Content with');
      expect(container.textContent).toContain('bold');

      // The code block should be rendered (even if not as pre/code due to HTML sanitization)
      expect(container.textContent).toContain('html');
    });
  });

  describe('Lists', () => {
    it('should handle unordered lists', () => {
      const content = `- First item
- Second item
- Third item
  - Nested item 1
  - Nested item 2
- Fourth item`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const ulElements = container.querySelectorAll('ul');
      expect(ulElements.length).toBeGreaterThan(0);

      const liElements = container.querySelectorAll('li');
      expect(liElements.length).toBeGreaterThan(0);
    });

    it('should handle ordered lists', () => {
      const content = `1. First item
2. Second item
3. Third item
   1. Nested item 1
   2. Nested item 2
4. Fourth item`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const olElements = container.querySelectorAll('ol');
      expect(olElements.length).toBeGreaterThan(0);

      const liElements = container.querySelectorAll('li');
      expect(liElements.length).toBeGreaterThan(0);
    });

    it('should handle mixed list types', () => {
      const content = `1. First ordered item
2. Second ordered item
   - First unordered sub-item
   - Second unordered sub-item
3. Third ordered item`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const olElements = container.querySelectorAll('ol');
      const ulElements = container.querySelectorAll('ul');
      expect(olElements.length).toBeGreaterThan(0);
      expect(ulElements.length).toBeGreaterThan(0);
    });

    it('should handle task lists', () => {
      const content = `- [x] Completed task
- [ ] Incomplete task
- [x] Another completed task
- [ ] Another incomplete task`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const checkboxes = container.querySelectorAll('input[type="checkbox"]');
      expect(checkboxes.length).toBe(4);

      const checkedBoxes = container.querySelectorAll('input[type="checkbox"]:checked');
      expect(checkedBoxes.length).toBe(2);
    });
  });

  describe('Links and Images', () => {
    it('should handle various link formats', () => {
      const content = `[Google](https://google.com)
[Relative link](/path/to/page)
[Anchor link](#section)
[Link with title](https://example.com "Example Title")`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const linkElements = container.querySelectorAll('a');
      expect(linkElements.length).toBe(4);

      expect(linkElements[0].getAttribute('href')).toBe('https://google.com');
      expect(linkElements[1].getAttribute('href')).toBe('/path/to/page');
      expect(linkElements[2].getAttribute('href')).toBe('#section');
      expect(linkElements[3].getAttribute('href')).toBe('https://example.com');
    });

    it('should handle images', () => {
      const content = `![Alt text](https://example.com/image.jpg)
![Image with title](https://example.com/image2.jpg "Image Title")
![Relative image](/path/to/image.png)`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const imgElements = container.querySelectorAll('img');
      expect(imgElements.length).toBe(3);

      expect(imgElements[0].getAttribute('src')).toBe('https://example.com/image.jpg');
      expect(imgElements[0].getAttribute('alt')).toBe('Alt text');
      expect(imgElements[1].getAttribute('src')).toBe('https://example.com/image2.jpg');
      expect(imgElements[1].getAttribute('alt')).toBe('Image with title');
    });

    it('should reject dangerous URLs', () => {
      const content = `[Dangerous](javascript:alert('XSS'))
[Also dangerous](data:text/html,<script>alert('XSS')</script>)
[Safe link](https://example.com)`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const linkElements = container.querySelectorAll('a');
      console.log('Link elements found:', linkElements.length);
      console.log('Container HTML:', container.innerHTML);

      // Should have at least the safe link
      expect(linkElements.length).toBeGreaterThanOrEqual(1);
      if (linkElements.length > 0) {
        expect(linkElements[0].getAttribute('href')).toBe('https://example.com');
      }
    });
  });

  describe('Tables', () => {
    it('should handle basic tables', () => {
      const content = `| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const tableElement = container.querySelector('table');
      expect(tableElement).toBeInTheDocument();

      const theadElement = container.querySelector('thead');
      expect(theadElement).toBeInTheDocument();

      const tbodyElement = container.querySelector('tbody');
      expect(tbodyElement).toBeInTheDocument();

      const thElements = container.querySelectorAll('th');
      expect(thElements.length).toBe(3);

      const tdElements = container.querySelectorAll('td');
      expect(tdElements.length).toBe(6);
    });

    it('should handle tables with alignment', () => {
      const content = `| Left | Center | Right |
|:-----|:------:|------:|
| L1   |   C1   |    R1 |
| L2   |   C2   |    R2 |`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const tableElement = container.querySelector('table');
      expect(tableElement).toBeInTheDocument();
    });

    it('should handle tables with special content', () => {
      const content = `| Feature | Status | Notes |
|---------|--------|-------|
| **Bold** | ✅ | Working |
| *Italic* | ❌ | Not working |
| \`Code\` | ⚠️ | Partial |`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const tableElement = container.querySelector('table');
      expect(tableElement).toBeInTheDocument();
    });
  });

  describe('Blockquotes', () => {
    it('should handle single blockquote', () => {
      const content = `> This is a blockquote.
> It can span multiple lines.
> And contain **bold** text.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const blockquoteElement = container.querySelector('blockquote');
      expect(blockquoteElement).toBeInTheDocument();
    });

    it('should handle multiple blockquotes', () => {
      const content = `> First blockquote
> With multiple lines

> Second blockquote
> Also with multiple lines`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const blockquoteElements = container.querySelectorAll('blockquote');
      expect(blockquoteElements.length).toBe(2);
    });

    it('should handle nested blockquotes', () => {
      const content = `> Main blockquote
> > Nested blockquote
> > With more content
> Back to main blockquote`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const blockquoteElements = container.querySelectorAll('blockquote');
      expect(blockquoteElements.length).toBeGreaterThan(0);
    });
  });

  describe('Horizontal Rules', () => {
    it('should handle horizontal rules with different syntax', () => {
      const content = `First section

---

Second section

***

Third section

___`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const hrElements = container.querySelectorAll('hr');
      expect(hrElements.length).toBe(3);
    });
  });

  describe('LaTeX Math', () => {
    it('should handle inline math', () => {
      const content = `The equation $E = mc^2$ is famous.
Another equation: $\\alpha + \\beta = \\gamma$.
Multiple equations: $x = 1$, $y = 2$, $z = 3$.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const katexElements = container.querySelectorAll('.katex');
      expect(katexElements.length).toBe(5); // 3 inline + 2 from display math
    });

    it('should handle display math', () => {
      const content = `Here's a display equation:

$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

And another:

$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const katexDisplayElements = container.querySelectorAll('.katex-display');
      expect(katexDisplayElements.length).toBe(2);
    });

    it('should handle mixed inline and display math', () => {
      const content = `Inline: $x = y$ and display:

$$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$$

More inline: $\\alpha$ and $\\beta$.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const katexElements = container.querySelectorAll('.katex');
      const katexDisplayElements = container.querySelectorAll('.katex-display');
      expect(katexElements.length).toBe(4); // 2 inline + 2 from display (display creates both .katex and .katex-display)
      expect(katexDisplayElements.length).toBe(1);
    });
  });

  describe('Complex Combinations', () => {
    it('should handle complex markdown with all features', () => {
      const content = `# Main Title

This is a **complex** document with *multiple* features.

## Features List

- [x] **Bold text** support
- [x] *Italic text* support
- [ ] ~~Strikethrough~~ support
- [x] \`Inline code\` support

### Code Example

\`\`\`javascript
function complexFunction() {
  const data = { name: "test", value: 42 };
  return data.name + " = " + data.value;
}
\`\`\`

## Data Table

| Feature | Status | Math |
|---------|--------|------|
| Headers | ✅ | $H = \\log_2(n)$ |
| Lists | ✅ | $L = \\sum_{i=1}^{n} i$ |
| Code | ✅ | $C = \\int_0^1 f(x) dx$ |

> **Note**: This is a complex example with $E = mc^2$ inline math.

---

### Final Equation

$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

[Learn more](https://example.com) about this topic.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Check for various elements
      expect(container.querySelector('h1')).toBeInTheDocument();
      expect(container.querySelector('h2')).toBeInTheDocument();
      expect(container.querySelector('h3')).toBeInTheDocument();
      expect(container.querySelector('ul')).toBeInTheDocument();
      expect(container.querySelector('pre')).toBeInTheDocument();
      expect(container.querySelector('table')).toBeInTheDocument();
      expect(container.querySelector('blockquote')).toBeInTheDocument();
      expect(container.querySelector('hr')).toBeInTheDocument();
      expect(container.querySelector('a')).toBeInTheDocument();
      expect(container.querySelector('.katex')).toBeInTheDocument();
      expect(container.querySelector('.katex-display')).toBeInTheDocument();
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle empty content', () => {
      const content = '';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container).toBeInTheDocument();
    });

    it('should handle content with only whitespace', () => {
      const content = '   \n\n   \t   \n   ';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container).toBeInTheDocument();
    });

    it('should handle malformed markdown gracefully', () => {
      const content = `**Unclosed bold
*Unclosed italic
\`Unclosed code
[Unclosed link](https://example.com
![Unclosed image](https://example.com/image.jpg`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container).toBeInTheDocument();
    });

    it('should handle special characters and unicode', () => {
      const content = `Special characters: àáâãäåæçèéêë
Emojis: 🚀 📝 ✅ ❌ ⚠️
Math symbols: ∑ ∏ ∫ ∂ ∇
Currency: $ € £ ¥`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.textContent).toContain('Special characters: àáâãäåæçèéêë');
      expect(container.textContent).toContain('Emojis: 🚀 📝 ✅ ❌ ⚠️');
    });

    it('should handle very long content', () => {
      const content = Array(1000)
        .fill('This is a very long line of text that should be handled properly. ')
        .join('');
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container).toBeInTheDocument();
    });

    it('should handle content with HTML entities', () => {
      const content = `HTML entities: &lt; &gt; &amp; &quot; &#39;
Math with entities: $x &lt; y$ and $z &gt; w$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container).toBeInTheDocument();
    });
  });

  describe('Security and XSS Prevention', () => {
    it('should sanitize script tags', () => {
      const content = `Normal text <script>alert('XSS')</script> more text`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.querySelector('script')).toBeNull();
      expect(screen.queryByText("alert('XSS')")).not.toBeInTheDocument();
    });

    it('should sanitize event handlers', () => {
      const content = `Normal text <img src="x" onerror="alert('XSS')"> more text`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const img = container.querySelector('img');
      expect(img).toBeInTheDocument();
      expect(img?.getAttribute('onerror')).toBeNull();
    });

    it('should sanitize dangerous URLs', () => {
      const content = `[Dangerous](javascript:alert('XSS')) [Safe](https://example.com)`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const links = container.querySelectorAll('a');
      expect(links.length).toBe(1);
      expect(links[0].getAttribute('href')).toBe('https://example.com');
    });

    it('should sanitize dangerous HTML attributes', () => {
      const content = `Normal text <div onclick="alert('XSS')" onload="alert('XSS')">Click me</div> more text`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const div = container.querySelector('div');
      expect(div).toBeInTheDocument();
      expect(div?.getAttribute('onclick')).toBeNull();
      expect(div?.getAttribute('onload')).toBeNull();
    });

    it('should sanitize iframe and form elements', () => {
      const content = `Normal text <iframe src="javascript:alert('XSS')"></iframe> <form action="javascript:alert('XSS')"><input></form> more text`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      expect(container.querySelector('iframe')).toBeNull();
      expect(container.querySelector('form')).toBeNull();
      expect(container.querySelector('input')).toBeNull();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\secure-text-renderer.test.tsx
SIZE: 4,624 bytes | LINES: 123
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('SecureTextRenderer Tests', () => {
  describe('Basic Functionality', () => {
    it('should render plain text', () => {
      const content = 'Hello world';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Hello world')).toBeInTheDocument();
    });

    it('should render markdown bold text', () => {
      const content = 'This is **bold** text';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('This is')).toBeInTheDocument();
      expect(screen.getByText('bold')).toBeInTheDocument();
      expect(screen.getByText('text')).toBeInTheDocument();
    });

    it('should render markdown italic text', () => {
      const content = 'This is *italic* text';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('This is')).toBeInTheDocument();
      expect(screen.getByText('italic')).toBeInTheDocument();
      expect(screen.getByText('text')).toBeInTheDocument();
    });

    it('should render inline code', () => {
      const content = 'Use `console.log()` to debug';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Use')).toBeInTheDocument();
      expect(screen.getByText('console.log()')).toBeInTheDocument();
      expect(screen.getByText('to debug')).toBeInTheDocument();
    });

    it('should render headers', () => {
      const content = '# Main Title\n## Subtitle\n### Small Title';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Main Title')).toBeInTheDocument();
      expect(screen.getByText('Subtitle')).toBeInTheDocument();
      expect(screen.getByText('Small Title')).toBeInTheDocument();
    });

    it('should render safe links', () => {
      const content = 'Visit [Google](https://google.com) for search';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Visit')).toBeInTheDocument();
      expect(screen.getByText('Google')).toBeInTheDocument();
      expect(screen.getByText('for search')).toBeInTheDocument();
    });
  });

  describe('XSS Protection', () => {
    it('should escape script tags', () => {
      const content = '<script>alert("XSS")</script>';
      render(<MarkdownRenderer markdown={content} />);

      // Should not contain the actual script content
      expect(screen.queryByText('alert("XSS")')).not.toBeInTheDocument();
      // Should contain escaped version
      expect(screen.getByText(/&lt;script&gt;/)).toBeInTheDocument();
    });

    it('should escape event handlers', () => {
      const content = '<img src="x" onerror="alert(\'XSS\')">';
      render(<MarkdownRenderer markdown={content} />);

      // Should not contain the alert
      expect(screen.queryByText("alert('XSS')")).not.toBeInTheDocument();
      // Should contain escaped version
      expect(screen.getByText(/&lt;img/)).toBeInTheDocument();
    });

    it('should reject javascript: URLs', () => {
      const content = '[Click me](javascript:alert("XSS"))';
      render(<MarkdownRenderer markdown={content} />);

      // Should not render as a link, just as text
      expect(screen.getByText('Click me')).toBeInTheDocument();
      // Should not have javascript: in href
      const link = screen.queryByRole('link');
      if (link) {
        expect(link).not.toHaveAttribute('href', 'javascript:alert("XSS")');
      }
    });

    it('should escape dangerous HTML attributes', () => {
      const content = '<div onclick="alert(\'XSS\')">Click me</div>';
      render(<MarkdownRenderer markdown={content} />);

      // Should not contain the alert
      expect(screen.queryByText("alert('XSS')")).not.toBeInTheDocument();
      // Should contain escaped version
      expect(screen.getByText(/&lt;div/)).toBeInTheDocument();
    });
  });

  describe('Safe HTML Elements', () => {
    it('should allow basic formatting through markdown', () => {
      const content = '**Bold** and *italic* text';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Bold')).toBeInTheDocument();
      expect(screen.getByText('italic')).toBeInTheDocument();
    });

    it('should allow code elements through markdown', () => {
      const content = 'Use `code` for inline code';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('code')).toBeInTheDocument();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\simple-renderer.test.tsx
SIZE: 4,461 bytes | LINES: 116
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('Simple SecureTextRenderer Tests', () => {
  it('should render plain text', () => {
    const content = 'Hello world';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('Hello world')).toBeInTheDocument();
  });

  it('should remove script tags', () => {
    const content = '<script>alert("XSS")</script>';
    const { container } = render(<MarkdownRenderer markdown={content} />);

    // Should not contain the actual script content
    expect(screen.queryByText('alert("XSS")')).not.toBeInTheDocument();
    // Should be completely removed (empty content)
    expect(container.innerHTML).not.toContain('script');
    expect(container.innerHTML).not.toContain('alert');
  });

  it('should render markdown bold text', () => {
    const content = 'This is **bold** text';
    render(<MarkdownRenderer markdown={content} />);

    // Check that the bold text is rendered correctly
    expect(screen.getByText('bold')).toBeInTheDocument();
    // Check that the text is split correctly
    expect(screen.getByText(/This is/)).toBeInTheDocument();
    expect(screen.getByText(/text/)).toBeInTheDocument();
  });

  it('should render markdown italic text', () => {
    const content = 'This is *italic* text';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('italic')).toBeInTheDocument();
  });

  it('should render inline code', () => {
    const content = 'Use `console.log()` to debug';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('console.log()')).toBeInTheDocument();
  });

  it('should render headers', () => {
    const content = '# Main Title\n## Subtitle';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('Main Title')).toBeInTheDocument();
    expect(screen.getByText('Subtitle')).toBeInTheDocument();
  });

  it('should render unordered lists', () => {
    const content = '- Item 1\n- Item 2\n- Item 3';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('Item 1')).toBeInTheDocument();
    expect(screen.getByText('Item 2')).toBeInTheDocument();
    expect(screen.getByText('Item 3')).toBeInTheDocument();
  });

  it('should render ordered lists', () => {
    const content = '1. First item\n2. Second item\n3. Third item';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('First item')).toBeInTheDocument();
    expect(screen.getByText('Second item')).toBeInTheDocument();
    expect(screen.getByText('Third item')).toBeInTheDocument();
  });

  it('should render links safely', () => {
    const content = 'Visit [Google](https://google.com) for search';
    render(<MarkdownRenderer markdown={content} />);

    expect(screen.getByText('Google')).toBeInTheDocument();
  });

  it('should reject javascript: URLs', () => {
    const content = '[Click me](javascript:alert("XSS"))';
    const { container } = render(<MarkdownRenderer markdown={content} />);

    // Should not render as a link, just as text (but may have extra parenthesis due to regex issue)
    expect(screen.getByText(/Click me/)).toBeInTheDocument();
    // Should not contain javascript: in the HTML
    expect(container.innerHTML).not.toContain('javascript:');
  });

  it('should remove event handlers', () => {
    const content = '<img src="x" onerror="alert(\'XSS\')">';
    const { container } = render(<MarkdownRenderer markdown={content} />);

    // Should not contain dangerous event handlers
    expect(container.innerHTML).not.toContain('onerror');
    expect(container.innerHTML).not.toContain('alert');
    // Should still contain the safe img tag
    expect(container.innerHTML).toContain('<img src="x">');
  });

  it('should remove dangerous HTML attributes', () => {
    const content = '<div onclick="alert(\'XSS\')">Click me</div>';
    const { container } = render(<MarkdownRenderer markdown={content} />);

    // Should not contain any onclick attributes
    expect(container.innerHTML).not.toContain('onclick');
    expect(container.innerHTML).not.toContain('alert');
    // Should still contain the safe content
    expect(container.innerHTML).toContain('<div>');
    expect(container.innerHTML).toContain('Click me');
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\text-renderer-explanation.test.tsx
SIZE: 8,214 bytes | LINES: 218
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('TextRenderer Explanation Mapping Tests (TM-RN-03)', () => {
  describe('Explanation Content Stability', () => {
    it('should preserve explanation text exactly', () => {
      const explanation = 'This is a detailed explanation with **bold text** and `code`.';
      render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/This is a detailed explanation with/)).toBeInTheDocument();
      expect(screen.getByText('bold text')).toBeInTheDocument();
      expect(screen.getByText('code')).toBeInTheDocument();
    });

    it('should preserve explanation with LaTeX', () => {
      const explanation = 'The formula is $x = y + z$ and the result is $\\alpha$.';
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      // Should contain the text parts
      expect(screen.getByText(/The formula is/)).toBeInTheDocument();
      expect(screen.getByText(/and the result is/)).toBeInTheDocument();

      // Should contain LaTeX elements
      const katexElements = container.querySelectorAll('.katex-inline');
      expect(katexElements.length).toBe(2);
    });

    it('should preserve explanation with code blocks', () => {
      const explanation = `Here's the algorithm:

\`\`\`javascript
function calculate(x) {
  return x * 2;
}
\`\`\`

This explains the calculation.`;
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/Here's the algorithm:/)).toBeInTheDocument();
      expect(screen.getByText(/This explains the calculation./)).toBeInTheDocument();

      const codeBlock = container.querySelector('pre code');
      expect(codeBlock).toBeInTheDocument();
      expect(codeBlock?.textContent).toContain('function calculate(x)');
    });

    it('should preserve explanation with lists', () => {
      const explanation = `The steps are:

1. First step
2. Second step
3. Third step

This completes the process.`;
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/The steps are:/)).toBeInTheDocument();
      expect(screen.getByText(/This completes the process./)).toBeInTheDocument();

      const orderedList = container.querySelector('ol');
      expect(orderedList).toBeInTheDocument();
      expect(screen.getByText('First step')).toBeInTheDocument();
      expect(screen.getByText('Second step')).toBeInTheDocument();
      expect(screen.getByText('Third step')).toBeInTheDocument();
    });

    it('should preserve explanation with tables', () => {
      const explanation = `Here's the comparison:

| Feature | Value |
|---------|-------|
| Speed   | Fast  |
| Memory  | Low   |

This table shows the results.`;
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/Here's the comparison:/)).toBeInTheDocument();
      expect(screen.getByText(/This table shows the results./)).toBeInTheDocument();

      const table = container.querySelector('table');
      expect(table).toBeInTheDocument();
      expect(screen.getByText('Feature')).toBeInTheDocument();
      expect(screen.getByText('Value')).toBeInTheDocument();
      expect(screen.getByText('Speed')).toBeInTheDocument();
      expect(screen.getByText('Fast')).toBeInTheDocument();
    });
  });

  describe('Complex Explanation Scenarios', () => {
    it('should handle mixed content in explanations', () => {
      const explanation = `**Algorithm Explanation:**

The algorithm works as follows:

1. **Input**: Get value $x$
2. **Process**: Calculate $y = f(x)$ where $f(x) = x^2 + 1$
3. **Output**: Return $y$

\`\`\`javascript
function algorithm(x) {
  return x * x + 1;
}
\`\`\`

> **Note**: This is a simple quadratic function.

The complexity is $O(1)$.`;

      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      // Check for various elements
      expect(screen.getByText('Algorithm Explanation:')).toBeInTheDocument();
      expect(screen.getByText(/The algorithm works as follows:/)).toBeInTheDocument();
      expect(screen.getByText(/Input/)).toBeInTheDocument();
      expect(screen.getByText(/Process/)).toBeInTheDocument();
      expect(screen.getByText(/Output/)).toBeInTheDocument();
      expect(screen.getByText(/Note/)).toBeInTheDocument();
      expect(screen.getByText(/The complexity is/)).toBeInTheDocument();

      // Check for structured elements
      expect(container.querySelector('ol')).toBeInTheDocument();
      expect(container.querySelector('pre')).toBeInTheDocument();
      expect(container.querySelector('blockquote')).toBeInTheDocument();
    });

    it('should handle explanation with mermaid diagrams', () => {
      const explanation = `Here's the flow:

\`\`\`mermaid
graph TD
    A[Start] --> B[Process]
    B --> C[End]
\`\`\`

This diagram shows the process flow.`;

      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/Here's the flow:/)).toBeInTheDocument();
      expect(screen.getByText(/This diagram shows the process flow./)).toBeInTheDocument();

      const mermaidElement = container.querySelector('.mermaid');
      expect(mermaidElement).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty explanations', () => {
      const explanation = '';
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(container).toBeInTheDocument();
      expect(container.textContent).toBe('');
    });

    it('should handle explanations with only whitespace', () => {
      const explanation = '   \n\n  \t  \n  ';
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(container).toBeInTheDocument();
    });

    it('should handle explanations with special characters', () => {
      const explanation = 'Special chars: <>&"\' and unicode: αβγδε';
      const { container } = render(<MarkdownRenderer markdown={explanation} />);

      expect(screen.getByText(/Special chars:/)).toBeInTheDocument();
      expect(screen.getByText(/and unicode:/)).toBeInTheDocument();
      expect(screen.getByText(/αβγδε/)).toBeInTheDocument();
    });

    it('should handle very long explanations', () => {
      const longExplanation = 'A'.repeat(10000) + ' with some **bold** text.';
      const { container } = render(<MarkdownRenderer markdown={longExplanation} />);

      expect(container).toBeInTheDocument();
      expect(screen.getByText('bold')).toBeInTheDocument();
    });
  });

  describe('Consistency Tests', () => {
    it('should render the same content consistently', () => {
      const explanation = 'This is a **test** with $x = y$ and `code`.';

      const { container: container1 } = render(<MarkdownRenderer markdown={explanation} />);
      const { container: container2 } = render(<MarkdownRenderer markdown={explanation} />);

      // Both should have the same structure
      expect(container1.querySelectorAll('strong').length).toBe(
        container2.querySelectorAll('strong').length,
      );
      expect(container1.querySelectorAll('.katex-inline').length).toBe(
        container2.querySelectorAll('.katex-inline').length,
      );
      expect(container1.querySelectorAll('code').length).toBe(
        container2.querySelectorAll('code').length,
      );
    });

    it('should handle the same content with different whitespace', () => {
      const explanation1 = 'Text with   multiple   spaces.';
      const explanation2 = 'Text with multiple spaces.';

      const { container: container1 } = render(<MarkdownRenderer markdown={explanation1} />);
      const { container: container2 } = render(<MarkdownRenderer markdown={explanation2} />);

      // Both should render similarly (whitespace may be preserved differently)
      expect(container1.textContent?.replace(/\s+/g, ' ').trim()).toBe(
        container2.textContent?.replace(/\s+/g, ' ').trim(),
      );
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\text-renderer-latex.test.tsx
SIZE: 7,319 bytes | LINES: 224
================================================================================
import { describe, it, expect } from 'vitest';
import { render, waitFor } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('TextRenderer LaTeX Tests (TM-LX-01)', () => {
  describe('Inline Math Rendering', () => {
    it('should render inline math correctly', async () => {
      const content = 'The formula is $x = y + z$ in the text.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Wait for KaTeX to load and render
      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should render multiple inline math expressions', async () => {
      const content = 'First: $a^2 + b^2 = c^2$ and second: $E = mc^2$.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle inline math with special characters', async () => {
      const content = 'Greek letters: $\\alpha, \\beta, \\gamma$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should handle inline math with fractions', async () => {
      const content = 'Fraction: $\\frac{1}{2}$ and $\\frac{a}{b}$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Display Math Rendering', () => {
    it('should render display math correctly', async () => {
      const content = 'The equation is:\n\n$$x^2 + y^2 = z^2$$\n\nEnd of equation.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should render multiple display math expressions', async () => {
      const content = `First equation:
$$E = mc^2$$

Second equation:
$$F = ma$$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex-display');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle display math with complex expressions', async () => {
      const content = `Complex equation:
$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });

    it('should handle display math with matrices', async () => {
      const content = `Matrix:
$$\\begin{pmatrix}
a & b \\\\
c & d
\\end{pmatrix}$$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex-display');
          expect(katexElement).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Mixed Math and Text', () => {
    it('should handle inline and display math in the same content', async () => {
      const content = `The inline formula is $x = y$ and the display formula is:

$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$

More text with $\\alpha$ symbol.`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const inlineElements = container.querySelectorAll('.katex');
          const displayElements = container.querySelectorAll('.katex-display');
          expect(inlineElements.length).toBe(3); // 2 inline + 1 from display math
          expect(displayElements.length).toBe(1);
        },
        { timeout: 3000 },
      );
    });

    it('should handle math within lists', async () => {
      const content = `- First item with $x = 1$
- Second item with display math:
  $$y = 2x + 3$$
- Third item with $\\alpha$`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const inlineElements = container.querySelectorAll('.katex');
          const displayElements = container.querySelectorAll('.katex-display');
          expect(inlineElements.length).toBe(3); // 2 inline + 1 from display math
          expect(displayElements.length).toBe(1);
        },
        { timeout: 3000 },
      );
    });
  });

  describe('Error Handling', () => {
    it('should handle malformed LaTeX gracefully', async () => {
      const content = 'Malformed: $\\invalid{command}$ and $\\frac{1}{2$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          // Should still render something, even if it's an error
          const katexElements = container.querySelectorAll('.katex');
          const katexErrorElements = container.querySelectorAll('.katex-error');
          expect(katexElements.length + katexErrorElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });

    it('should handle empty math expressions', async () => {
      const content = 'Empty: $$ and $ $';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          // Should handle gracefully without crashing
          expect(container).toBeInTheDocument();
        },
        { timeout: 3000 },
      );
    });
  });

  describe('KaTeX Configuration', () => {
    it('should use trust: false for security', async () => {
      const content = 'Test: $x = y$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElement = container.querySelector('.katex');
          expect(katexElement).toBeInTheDocument();
          // The element should be rendered, indicating trust: false is working
          // (if trust was true, it might render differently)
        },
        { timeout: 3000 },
      );
    });

    it('should handle custom macros', async () => {
      const content = 'Custom macro: $\\neq$ and $\\ne$';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      await waitFor(
        () => {
          const katexElements = container.querySelectorAll('.katex');
          expect(katexElements.length).toBe(2);
        },
        { timeout: 3000 },
      );
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\text-renderer-markdown.test.tsx
SIZE: 7,597 bytes | LINES: 209
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('TextRenderer Markdown Tests (TM-RN-02)', () => {
  describe('Rich Markdown Support', () => {
    it('should render unordered lists correctly', () => {
      const content = `- Item 1
- Item 2
- Item 3`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const list = container.querySelector('ul');
      expect(list).toBeInTheDocument();
      expect(screen.getByText('Item 1')).toBeInTheDocument();
      expect(screen.getByText('Item 2')).toBeInTheDocument();
      expect(screen.getByText('Item 3')).toBeInTheDocument();
    });

    it('should render ordered lists correctly', () => {
      const content = `1. First item
2. Second item
3. Third item`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const list = container.querySelector('ol');
      expect(list).toBeInTheDocument();
      expect(screen.getByText('First item')).toBeInTheDocument();
      expect(screen.getByText('Second item')).toBeInTheDocument();
      expect(screen.getByText('Third item')).toBeInTheDocument();
    });

    it('should render nested lists correctly', () => {
      const content = `- Main item
  - Sub item 1
  - Sub item 2
- Another main item`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const lists = container.querySelectorAll('ul');
      expect(lists.length).toBeGreaterThan(1); // Should have nested lists
      expect(screen.getByText('Main item')).toBeInTheDocument();
      expect(screen.getByText('Sub item 1')).toBeInTheDocument();
      expect(screen.getByText('Sub item 2')).toBeInTheDocument();
    });

    it('should render tables correctly', () => {
      const content = `| Header 1 | Header 2 |
|----------|----------|
| Cell 1   | Cell 2   |
| Cell 3   | Cell 4   |`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const table = container.querySelector('table');
      expect(table).toBeInTheDocument();

      const thead = container.querySelector('thead');
      expect(thead).toBeInTheDocument();

      const tbody = container.querySelector('tbody');
      expect(tbody).toBeInTheDocument();

      expect(screen.getByText('Header 1')).toBeInTheDocument();
      expect(screen.getByText('Cell 1')).toBeInTheDocument();
    });

    it('should render inline code correctly', () => {
      const content = 'This is `inline code` in a sentence.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const code = container.querySelector('code');
      expect(code).toBeInTheDocument();
      expect(code?.textContent).toBe('inline code');
    });

    it('should render code blocks correctly', () => {
      const content = `\`\`\`javascript
function hello() {
  console.log("Hello, world!");
}
\`\`\``;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const pre = container.querySelector('pre');
      expect(pre).toBeInTheDocument();

      const code = container.querySelector('code');
      expect(code).toBeInTheDocument();
      expect(code?.textContent).toContain('function hello()');
    });

    it('should render bold text correctly', () => {
      const content = 'This is **bold text** and __also bold__.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const strongElements = container.querySelectorAll('strong');
      expect(strongElements.length).toBe(2);
      expect(strongElements[0].textContent).toBe('bold text');
      expect(strongElements[1].textContent).toBe('also bold');
    });

    it('should render italic text correctly', () => {
      const content = 'This is *italic text* and _also italic_.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const emElements = container.querySelectorAll('em');
      expect(emElements.length).toBe(2);
      expect(emElements[0].textContent).toBe('italic text');
      expect(emElements[1].textContent).toBe('also italic');
    });

    it('should render links correctly', () => {
      const content = '[Link text](https://example.com)';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const link = container.querySelector('a');
      expect(link).toBeInTheDocument();
      expect(link?.getAttribute('href')).toBe('https://example.com');
      expect(link?.textContent).toBe('Link text');
    });

    it('should render images correctly', () => {
      const content = '![Alt text](https://example.com/image.jpg)';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const img = container.querySelector('img');
      expect(img).toBeInTheDocument();
      expect(img?.getAttribute('src')).toBe('https://example.com/image.jpg');
      expect(img?.getAttribute('alt')).toBe('Alt text');
    });

    it('should render blockquotes correctly', () => {
      const content = `> This is a blockquote
> with multiple lines`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const blockquote = container.querySelector('blockquote');
      expect(blockquote).toBeInTheDocument();
      expect(blockquote?.textContent).toContain('This is a blockquote');
    });

    it('should render horizontal rules correctly', () => {
      const content = `Line above

---

Line below`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const hr = container.querySelector('hr');
      expect(hr).toBeInTheDocument();
    });

    it('should render strikethrough text correctly', () => {
      const content = 'This is ~~strikethrough~~ text.';
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const del = container.querySelector('del');
      expect(del).toBeInTheDocument();
      expect(del?.textContent).toBe('strikethrough');
    });

    it('should render task lists correctly', () => {
      const content = `- [x] Completed task
- [ ] Incomplete task
- [x] Another completed task`;
      const { container } = render(<MarkdownRenderer markdown={content} />);

      const checkboxes = container.querySelectorAll('input[type="checkbox"]');
      expect(checkboxes.length).toBe(3);

      const checkedBoxes = container.querySelectorAll('input[type="checkbox"]:checked');
      expect(checkedBoxes.length).toBe(2);
    });
  });

  describe('Complex Markdown Combinations', () => {
    it('should handle mixed content with lists, code, and formatting', () => {
      const content = `Here's a **complex** example:

1. First item with \`inline code\`
2. Second item with *italic* text
   - Nested item
   - Another nested item

\`\`\`javascript
// Code block
function example() {
  return "Hello";
}
\`\`\`

> This is a blockquote with **bold** text.`;

      const { container } = render(<MarkdownRenderer markdown={content} />);

      // Check for various elements
      expect(container.querySelector('ol')).toBeInTheDocument();
      expect(container.querySelector('ul')).toBeInTheDocument();
      expect(container.querySelector('pre')).toBeInTheDocument();
      expect(container.querySelector('blockquote')).toBeInTheDocument();
      expect(container.querySelector('strong')).toBeInTheDocument();
      expect(container.querySelector('em')).toBeInTheDocument();
      expect(container.querySelector('code')).toBeInTheDocument();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tests\unit\renderer\text-renderer-security.test.tsx
SIZE: 5,529 bytes | LINES: 137
================================================================================
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MarkdownRenderer } from '@/components/rendering/MarkdownRenderer';
import React from 'react';

describe('TextRenderer Security Tests (TM-RN-01)', () => {
  describe('XSS Sanitization', () => {
    it('should sanitize script tags and prevent XSS', () => {
      const maliciousContent = '<script>alert("XSS")</script>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain script tags
      expect(screen.queryByText('alert("XSS")')).not.toBeInTheDocument();
      expect(container.querySelector('script')).toBeNull();
    });

    it('should sanitize event handlers and prevent XSS', () => {
      const maliciousContent = '<img src="x" onerror="alert(\'XSS\')">';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain onerror attributes
      const img = container.querySelector('img');
      expect(img).toBeInTheDocument(); // Should still be there but safe
      expect(img?.getAttribute('onerror')).toBeNull(); // But without dangerous attributes
    });

    it('should sanitize javascript: URLs and prevent XSS', () => {
      const maliciousContent = '<a href="javascript:alert(\'XSS\')">Click me</a>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain javascript: URLs
      const link = container.querySelector('a');
      if (link) {
        expect(link.getAttribute('href')).not.toContain('javascript:');
      }
    });

    it('should sanitize dangerous HTML attributes', () => {
      const maliciousContent =
        '<div onclick="alert(\'XSS\')" onload="alert(\'XSS\')">Content</div>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain event handlers
      const div = container.querySelector('div');
      if (div) {
        expect(div.getAttribute('onclick')).toBeNull();
        expect(div.getAttribute('onload')).toBeNull();
      }
    });

    it('should allow safe HTML attributes', () => {
      const safeContent = '<a href="https://example.com" title="Safe link">Link</a>';
      const { container } = render(<MarkdownRenderer markdown={safeContent} />);

      const link = container.querySelector('a');
      expect(link).toBeInTheDocument();
      expect(link?.getAttribute('href')).toBe('https://example.com');
      expect(link?.getAttribute('title')).toBe('Safe link');
    });

    it('should sanitize iframe elements', () => {
      const maliciousContent = '<iframe src="javascript:alert(\'XSS\')"></iframe>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain iframe elements
      expect(container.querySelector('iframe')).toBeNull();
    });

    it('should sanitize form elements', () => {
      const maliciousContent = '<form action="javascript:alert(\'XSS\')"><input></form>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      // Should not contain form elements
      expect(container.querySelector('form')).toBeNull();
      expect(container.querySelector('input')).toBeNull();
    });

    it('should sanitize style attributes with dangerous content', () => {
      const maliciousContent =
        '<div style="background: url(javascript:alert(\'XSS\'))">Content</div>';
      const { container } = render(<MarkdownRenderer markdown={maliciousContent} />);

      const div = container.querySelector('div');
      if (div) {
        const style = div.getAttribute('style');
        if (style) {
          expect(style).not.toContain('javascript:');
        }
      }
    });
  });

  describe('Safe HTML Elements', () => {
    it('should allow basic formatting elements', () => {
      const content = '<b>Bold</b> <i>Italic</i> <em>Emphasis</em> <strong>Strong</strong>';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Bold')).toBeInTheDocument();
      expect(screen.getByText('Italic')).toBeInTheDocument();
      expect(screen.getByText('Emphasis')).toBeInTheDocument();
      expect(screen.getByText('Strong')).toBeInTheDocument();
    });

    it('should allow code elements', () => {
      const content = '<code>inline code</code> <pre>code block</pre>';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('inline code')).toBeInTheDocument();
      expect(screen.getByText('code block')).toBeInTheDocument();
    });

    it('should allow list elements', () => {
      const content = '<ul><li>Item 1</li><li>Item 2</li></ul>';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Item 1')).toBeInTheDocument();
      expect(screen.getByText('Item 2')).toBeInTheDocument();
    });

    it('should allow table elements', () => {
      const content =
        '<table><thead><tr><th>Header</th></tr></thead><tbody><tr><td>Cell</td></tr></tbody></table>';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Header')).toBeInTheDocument();
      expect(screen.getByText('Cell')).toBeInTheDocument();
    });

    it('should allow paragraph and line break elements', () => {
      const content = '<p>Paragraph</p><br>';
      render(<MarkdownRenderer markdown={content} />);

      expect(screen.getByText('Paragraph')).toBeInTheDocument();
    });
  });
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: tsconfig.strict.json
SIZE: 160 bytes | LINES: 9
================================================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  }
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: types\quiz-types.ts
SIZE: 2,689 bytes | LINES: 94
================================================================================
export interface QuizOption {
  optionId: string;
  optionText: string;
}

export interface QuizQuestion {
  questionId: string;
  questionText: string;
  options: QuizOption[];
  correctOptionIds: string[];
  explanationText: string;
  type?: 'mcq' | 'true_false'; // Added new type field
  // Performance tracking fields
  status?:
    | 'not_attempted'
    | 'attempted'
    | 'passed_once'
    | 'review_soon'
    | 'review_later'
    | 'mastered';
  timesAnsweredCorrectly?: number;
  timesAnsweredIncorrectly?: number;
  lastSelectedOptionId?: string;
  historyOfIncorrectSelections?: string[];
  lastAttemptedAt?: string;
  // SRS fields
  srsLevel?: number; // 0 = new/failed, 1 = passed once, 2 = mastered
  nextReviewAt?: string | null; // ISO timestamp or null if mastered
  shownIncorrectOptionIds?: string[]; // Track which incorrect options have been shown
}

export interface QuizChapter {
  id: string;
  name: string;
  description?: string;
  questions: QuizQuestion[];
  totalQuestions: number;
  answeredQuestions: number;
  correctAnswers: number;
  isCompleted: boolean;
}

export interface QuizModule {
  name: string;
  description?: string;
  chapters: QuizChapter[];
}

export interface DisplayedOption extends QuizOption {
  isCorrect?: boolean; // Computed at display time
  isSelected?: boolean; // UI state
}

export interface ReviewQueueItem {
  chapterId: string;
  questionId: string;
  question: QuizQuestion;
}

// NEW: Types for incorrect answers export feature
export interface IncorrectAnswerLogEntry {
  questionId: string;
  questionText: string;
  chapterId: string;
  chapterName: string;
  incorrectSelections: Array<{ selectedOptionId: string; selectedOptionText: string }>;
  correctOptionIds: string[];
  correctOptionTexts: string[];
  explanationText: string;
  totalTimesCorrect: number;
  totalTimesIncorrect: number;
  currentSrsLevel: number;
  lastAttemptedAt?: string;
}

export type IncorrectAnswersExport = IncorrectAnswerLogEntry[];

// NEW: Types for Anki-style progress tracking
export interface SrsProgressCounts {
  newOrLapsingDue: number; // srsLevel 0 questions that are due
  learningReviewDue: number; // srsLevel 1 questions that are due
  totalNonMastered: number; // Total questions not yet mastered
}

// NEW: Session History Navigation Types
export interface SessionHistoryEntry {
  questionSnapshot: QuizQuestion; // A deep copy of the question state at the time of answering
  selectedOptionId: string;
  displayedOptions: DisplayedOption[]; // The exact options shown to the user
  isCorrect: boolean;
  isReviewSessionQuestion: boolean;
  chapterId: string; // Chapter ID for context, especially for SRS reviews
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: utils\quiz-validation-refactored.ts
SIZE: 42,932 bytes | LINES: 1,306
================================================================================
import type { QuizModule, QuizQuestion, QuizChapter, QuizOption } from '@/types/quiz-types';

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

interface LaTeXCorrectionResult {
  correctedContent: string;
  correctionsMade: number;
  correctionDetails: string[];
}

/**
 * Automatically detects and corrects common LaTeX formatting errors in JSON content.
 * This version uses a more conservative pattern to identify LaTeX contexts,
 * focusing on strings containing $...$ or $$...$$ delimiters.
 * It then applies specific fixes within those identified contexts.
 */
export function correctLatexInJsonContent(jsonContent: string): LaTeXCorrectionResult {
  console.log('=== Starting LaTeX Correction Process (Refactored) ===');
  let correctedContent = jsonContent;
  let correctionsMade = 0;
  const correctionDetails: string[] = [];

  // Directive 4: Adopt a Conservative Regex
  const latexContextPattern = /"(?:[^"\\]|\\.)*(?:\${1,2})[^$]*?(?:\${1,2})(?:[^"\\]|\\.)*"/g;

  const latexCommands = [
    'frac',
    'sqrt',
    'sum',
    'int',
    'lim',
    'log',
    'ln',
    'sin',
    'cos',
    'tan',
    'alpha',
    'beta',
    'gamma',
    'delta',
    'epsilon',
    'zeta',
    'eta',
    'theta',
    'iota',
    'kappa',
    'lambda',
    'mu',
    'nu',
    'xi',
    'pi',
    'rho',
    'sigma',
    'tau',
    'upsilon',
    'phi',
    'chi',
    'psi',
    'omega',
    'Gamma',
    'Delta',
    'Theta',
    'Lambda',
    'Xi',
    'Pi',
    'Sigma',
    'Upsilon',
    'Phi',
    'Psi',
    'Omega',
    'infty',
    'partial',
    'nabla',
    'times',
    'cdot',
    'div',
    'pm',
    'mp',
    'neq',
    'leq',
    'geq',
    'approx',
    'equiv',
    'propto',
    'subset',
    'supset',
    'in',
    'notin',
    'cap',
    'cup',
    'land',
    'lor',
    'neg',
    'rightarrow',
    'leftarrow',
    'leftrightarrow',
    'Rightarrow',
    'Leftarrow',
    'Leftrightarrow',
    'uparrow',
    'downarrow',
    'lceil',
    'rceil',
    'lfloor',
    'rfloor',
    'left',
    'right',
    'big',
    'Big',
    'bigg',
    'Bigg',
    'mathbb',
    'mathcal',
    'mathfrak',
    'mathbf',
    'mathrm',
    'text',
    'textbf',
    'textit',
    'emph',
    'boldsymbol',
    'overline',
    'underline',
    'vec',
    'hat',
    'tilde',
    'bar',
    'dot',
    'ddot',
    'acute',
    'grave',
    'check',
    'breve',
    'stackrel',
    'pmod',
    'bmod',
    'operatorname',
    'arcsin',
    'arccos',
    'arctan',
    'sinh',
    'cosh',
    'tanh',
    'coth',
    'sec',
    'csc',
    'cot',
    'exp',
    'det',
    'gcd',
    'min',
    'max',
    'forall',
    'exists',
    'emptyset',
    'therefore',
    'because',
    'ldots',
    'cdots',
    'vdots',
    'ddots',
    'hline',
    'vline',
    'sqrt',
    'prod',
    'coprod',
    'oint',
    'bigcap',
    'bigcup',
    'bigsqcup',
    'bigvee',
    'bigwedge',
    'bigoplus',
    'bigotimes',
    'bigodot',
    'biguplus',
    'substack',
    'cases',
    'pmatrix',
    'bmatrix',
    'vmatrix',
    'Vmatrix',
    'textrm',
    'textsf',
    'texttt',
    'textmd',
    'textup',
    'textsl',
    'mathcal',
    'mathbb',
    'mathscr',
    'mathfrak',
    'mathbf',
    'mathsf',
    'mathtt',
    'operatorname*',
    'DeclareMathOperator',
    'DeclareMathOperator*',
    'label',
    'ref',
    'eqref',
    'tag',
    'notag',
    'nonumber',
    'item',
    'section',
    'subsection',
    'subsubsection',
    'paragraph',
    'subparagraph',
    'chapter',
    'part',
    'appendix',
    'maketitle',
    'tableofcontents',
    'listoffigures',
    'listoftables',
    'bibliography',
    'bibliographystyle',
    'cite',
    'footnote',
    'thanks',
    'author',
    'date',
    'title',
    'documentclass',
    'usepackage',
    'include',
    'input',
    'newenvironment',
    'newtheorem',
    'renewcommand',
    'newcommand',
    'verb',
    'verbatim',
    'lstlisting',
    'minted',
    'includegraphics',
    'caption',
    'figure',
    'table',
    'centering',
    'raggedright',
    'raggedleft',
    'hspace',
    'vspace',
    'hfill',
    'vfill',
    'smallskip',
    'medskip',
    'bigskip',
    'pagebreak',
    'nopagebreak',
    'newpage',
    'clearpage',
    'cleardoublepage',
    'setlength',
    'addtolength',
    'setcounter',
    'addtocounter',
    'newcounter',
    'value',
    'if',
    'else',
    'fi',
    'ifcase',
    'or',
    'ifnum',
    'ifdim',
    'ifodd',
    'ifvmode',
    'ifhmode',
    'ifmmode',
    'ifinner',
    'newif',
    'iftrue',
    'iffalse',
    'fi',
    'let',
    'def',
    'edef',
    'gdef',
    'xdef',
    'futurelet',
    'afterassignment',
    'aftergroup',
    'begin',
    'end', // For environments
  ];

  const latexMatches = correctedContent.match(latexContextPattern) || [];
  console.log(`Found ${latexMatches.length} potential LaTeX contexts using conservative pattern.`);

  latexMatches.forEach((originalQuotedMatch, matchIndex) => {
    let contentInsideQuotes = (originalQuotedMatch as string).slice(1, -1);
    const originalContentInsideQuotes = contentInsideQuotes;
    let matchCorrections = 0;

    // 1. Fix single backslashes before known LaTeX commands
    latexCommands.forEach((command) => {
      // Regex to find \command but not \\command, ensuring command is a whole word
      const singleBackslashPattern = new RegExp(`(?<!\\\\)\\\\(${command})\\b`, 'g');
      const newContent = contentInsideQuotes.replace(singleBackslashPattern, `\\\\$1`);
      if (newContent !== contentInsideQuotes) {
        matchCorrections++;
        correctionDetails.push(`Context ${matchIndex + 1}: Fixed \\${command} → \\\\${command}`);
      }
      contentInsideQuotes = newContent;
    });

    // 2. Fix common LaTeX syntax patterns (like in original quiz-validation.ts)
    const commonFixes = [
      {
        pattern: /(?<!\\)\\{/g,
        replacement: '\\\\{',
        description: '\\{ → \\\\{',
      },
      { pattern: /(?<!\\)\\}/g, replacement: '\\\\}', description: '\\\\}' },
      {
        pattern: /(?<!\\)\\([&%$#_^~])/g,
        replacement: '\\\\$1',
        description: 'Escaped special char (e.g., \\& → \\\\&)',
      },
      {
        pattern: /(?<!\\)\\\[/g,
        replacement: '\\\\[',
        description: '\\[ → \\\\[ (display math)',
      },
      {
        pattern: /(?<!\\)\\\]/g,
        replacement: '\\\\]',
        description: '\\] → \\\\] (display math)',
      },
      {
        pattern: /(?<!\\)\\quad\b/g,
        replacement: '\\\\quad',
        description: '\\quad → \\\\quad',
      },
      {
        pattern: /(?<!\\)\\qquad\b/g,
        replacement: '\\\\qquad',
        description: '\\qquad → \\\\qquad',
      },
      {
        pattern: /(?<!\\)\\,/g,
        replacement: '\\\\,',
        description: '\\, → \\\\,',
      },
      {
        pattern: /(?<!\\)\\;/g,
        replacement: '\\\\;',
        description: '\\; → \\\\;',
      },
      {
        pattern: /(?<!\\)\\!/g,
        replacement: '\\\\!',
        description: '\\! → \\\\!',
      },
    ];

    commonFixes.forEach((fix) => {
      const newContent = contentInsideQuotes.replace(fix.pattern, fix.replacement);
      if (newContent !== contentInsideQuotes) {
        matchCorrections++;
        correctionDetails.push(`Context ${matchIndex + 1}: ${fix.description}`);
      }
      contentInsideQuotes = newContent;
    });

    // 3. Handle specific mathematical constructs (like environments)
    const environmentPattern = /(?<!\\)\\(begin|end){([^}]+)}/g;
    contentInsideQuotes = contentInsideQuotes.replace(environmentPattern, (match, command, env) => {
      matchCorrections++;
      correctionDetails.push(
        `Context ${matchIndex + 1}: Fixed \\${command}{${env}} → \\\\${command}{${env}}`,
      );
      return `\\\\${command}{${env}}`;
    });

    if (matchCorrections > 0) {
      correctionsMade += matchCorrections;
      const newQuotedMatch = `"${contentInsideQuotes}"`;
      correctedContent = correctedContent.replace(originalQuotedMatch, newQuotedMatch);
      console.log(
        `Corrected LaTeX in context ${matchIndex + 1}: "${originalContentInsideQuotes.substring(0, 50)}..." to "${contentInsideQuotes.substring(0, 50)}..."`,
      );
    }
  });

  console.log(`=== LaTeX Correction Complete ===`);
  console.log(`Total corrections made: ${correctionsMade}`);
  if (correctionsMade > 0) {
    console.log('Correction details:', correctionDetails);
  }

  return {
    correctedContent,
    correctionsMade,
    correctionDetails,
  };
}

export function validateAndCorrectQuizModule(data: any): {
  validationResult: ValidationResult;
  correctionResult?: LaTeXCorrectionResult;
  normalizedModule?: QuizModule;
} {
  let jsonString: string;

  if (typeof data === 'string') {
    jsonString = data;
  } else {
    try {
      jsonString = JSON.stringify(data, null, 2);
    } catch {
      return {
        validationResult: {
          isValid: false,
          errors: ['Failed to stringify input data for LaTeX correction.'],
        },
      };
    }
  }

  const correctionResult = correctLatexInJsonContent(jsonString);

  let correctedData: any;
  try {
    correctedData = JSON.parse(correctionResult.correctedContent);
  } catch (parseError) {
    return {
      validationResult: {
        isValid: false,
        errors: [
          `Failed to parse JSON after LaTeX correction: ${parseError instanceof Error ? parseError.message : 'Unknown parse error'}`,
        ],
      },
      correctionResult,
    };
  }

  const validationResult = validateQuizModule(correctedData);
  let normalizedModule: QuizModule | undefined;
  if (validationResult.isValid) {
    normalizedModule = normalizeQuizModule(correctedData);
  }

  return {
    validationResult,
    correctionResult,
    normalizedModule,
  };
}

export function validateQuizModule(data: any): ValidationResult {
  const errors: string[] = [];
  if (!data || typeof data !== 'object') {
    return { isValid: false, errors: ['Invalid JSON: Expected an object'] };
  }
  if (typeof data.name !== 'string' || data.name.trim() === '') {
    errors.push("Missing or invalid 'name' property (must be non-empty string)");
  }
  if (data.description !== undefined && typeof data.description !== 'string') {
    errors.push("Invalid 'description' property (must be string if provided)");
  }
  if (!Array.isArray(data.chapters)) {
    errors.push("Missing or invalid 'chapters' property (must be array)");
  } else {
    if (data.chapters.length === 0) {
      errors.push("'chapters' array cannot be empty");
    }
    data.chapters.forEach((chapter: any, chapterIndex: number) => {
      errors.push(...validateChapter(chapter, chapterIndex));
    });
  }
  return { isValid: errors.length === 0, errors };
}

function validateChapter(chapter: any, index: number): string[] {
  const errors: string[] = [];
  const prefix = `Chapter ${index + 1} (ID: ${chapter?.id || 'Unknown'})`;
  if (!chapter || typeof chapter !== 'object') {
    errors.push(`${prefix}: Expected an object`);
    return errors;
  }
  if (typeof chapter.id !== 'string' || chapter.id.trim() === '') {
    errors.push(`${prefix}: Missing or invalid 'id' property (must be non-empty string)`);
  }
  if (typeof chapter.name !== 'string' || chapter.name.trim() === '') {
    errors.push(`${prefix}: Missing or invalid 'name' property (must be non-empty string)`);
  }
  if (chapter.description !== undefined && typeof chapter.description !== 'string') {
    errors.push(`${prefix}: Invalid 'description' property (must be string if provided)`);
  }
  if (!Array.isArray(chapter.questions)) {
    errors.push(`${prefix}: Missing or invalid 'questions' property (must be array)`);
  } else {
    if (chapter.questions.length === 0) {
      errors.push(`${prefix}: 'questions' array cannot be empty`);
    }
    chapter.questions.forEach((question: any, questionIndex: number) => {
      errors.push(...validateQuestion(question, chapter.id || `chap${index}`, questionIndex));
    });
  }
  return errors;
}

function validateQuestion(question: any, chapterId: string, questionIndex: number): string[] {
  const errors: string[] = [];
  const prefix = `Chapter (ID: ${chapterId}), Question ${questionIndex + 1} (ID: ${question?.questionId || 'Unknown'})`;
  if (!question || typeof question !== 'object') {
    errors.push(`${prefix}: Expected an object`);
    return errors;
  }
  if (typeof question.questionId !== 'string' || question.questionId.trim() === '') {
    errors.push(`${prefix}: Missing or invalid 'questionId' property (must be non-empty string)`);
  }
  if (typeof question.questionText !== 'string' || question.questionText.trim() === '') {
    errors.push(`${prefix}: Missing or invalid 'questionText' property (must be non-empty string)`);
  }
  if (typeof question.explanationText !== 'string' || question.explanationText.trim() === '') {
    errors.push(
      `${prefix}: Missing or invalid 'explanationText' property (must be non-empty string)`,
    );
  }

  // Validate 'type' field
  if (question.type !== undefined && question.type !== 'mcq' && question.type !== 'true_false') {
    errors.push(`${prefix}: Invalid 'type' property (must be 'mcq' or 'true_false' if provided)`);
  }

  if (!Array.isArray(question.options)) {
    errors.push(`${prefix}: Missing or invalid 'options' property (must be array)`);
  } else {
    if (question.options.length === 0) {
      errors.push(`${prefix}: 'options' array cannot be empty`);
    }
    // For T/F questions, specific option validation
    if (question.type === 'true_false') {
      if (
        question.options.length !== 2 ||
        !question.options.find(
          (opt: QuizOption) => opt.optionId === 'true' && opt.optionText === 'True',
        ) ||
        !question.options.find(
          (opt: QuizOption) => opt.optionId === 'false' && opt.optionText === 'False',
        )
      ) {
        errors.push(
          `${prefix}: For 'true_false' type, options must be exactly [{optionId: "true", optionText: "True"}, {optionId: "false", optionText: "False"}]`,
        );
      }
    } else {
      // Existing option validation for MCQs
      question.options.forEach((option: any, optionIndex: number) => {
        if (!option || typeof option !== 'object') {
          errors.push(`${prefix}, Option ${optionIndex + 1}: Expected an object`);
          return;
        }
        if (typeof option.optionId !== 'string' || option.optionId.trim() === '') {
          errors.push(
            `${prefix}, Option ${optionIndex + 1}: Missing or invalid 'optionId' (must be non-empty string)`,
          );
        }
        if (typeof option.optionText !== 'string' || option.optionText.trim() === '') {
          errors.push(
            `${prefix}, Option ${optionIndex + 1}: Missing or invalid 'optionText' (must be non-empty string)`,
          );
        }
      });
    }
  }
  if (!Array.isArray(question.correctOptionIds)) {
    errors.push(`${prefix}: Missing or invalid 'correctOptionIds' property (must be array)`);
  } else {
    if (question.correctOptionIds.length === 0) {
      errors.push(`${prefix}: 'correctOptionIds' array cannot be empty`);
    }
    // For T/F questions, specific correctOptionIds validation
    if (question.type === 'true_false') {
      if (
        question.correctOptionIds.length !== 1 ||
        (question.correctOptionIds[0] !== 'true' && question.correctOptionIds[0] !== 'false')
      ) {
        errors.push(
          `${prefix}: For 'true_false' type, correctOptionIds must be an array with a single string: 'true' or 'false'.`,
        );
      }
    } else if (Array.isArray(question.options) && question.options.length > 0) {
      // Existing correctOptionIds validation for MCQs
      const optionIds = question.options
        .filter((opt: any) => opt && typeof opt.optionId === 'string')
        .map((opt: any) => opt.optionId);
      question.correctOptionIds.forEach((correctId: any, correctIdx: number) => {
        if (typeof correctId !== 'string') {
          errors.push(`${prefix}: correctOptionIds[${correctIdx}] must be a string.`);
        } else if (!optionIds.includes(correctId)) {
          errors.push(`${prefix}: correctOptionId '${correctId}' not found in options.`);
        }
      });
    }
  }
  return errors;
}

export function validateSingleQuestion(data: any): ValidationResult {
  const errors: string[] = [];
  if (!data || typeof data !== 'object') {
    return { isValid: false, errors: ['Expected a question object'] };
  }
  // Simplified validation, assuming main validateQuestion covers details
  if (typeof data.questionId !== 'string' || !data.questionId.trim())
    errors.push("Missing or invalid 'questionId'");
  if (typeof data.questionText !== 'string' || !data.questionText.trim())
    errors.push("Missing or invalid 'questionText'");
  if (typeof data.explanationText !== 'string' || !data.explanationText.trim())
    errors.push("Missing or invalid 'explanationText'");

  if (data.type !== undefined && data.type !== 'mcq' && data.type !== 'true_false') {
    errors.push("Invalid 'type' property (must be 'mcq' or 'true_false' if provided)");
  }

  if (!Array.isArray(data.options) || data.options.length === 0)
    errors.push("Missing or invalid 'options' array");
  else {
    if (data.type === 'true_false') {
      if (
        data.options.length !== 2 ||
        !data.options.find(
          (opt: QuizOption) => opt.optionId === 'true' && opt.optionText === 'True',
        ) ||
        !data.options.find(
          (opt: QuizOption) => opt.optionId === 'false' && opt.optionText === 'False',
        )
      ) {
        errors.push(
          `For 'true_false' type, options must be exactly [{optionId: "true", optionText: "True"}, {optionId: "false", optionText: "False"}]`,
        );
      }
    } else {
      data.options.forEach((opt: any, i: number) => {
        if (!opt || typeof opt.optionId !== 'string' || !opt.optionId.trim())
          errors.push(`Option ${i + 1} has invalid 'optionId'`);
        if (!opt || typeof opt.optionText !== 'string' || !opt.optionText.trim())
          errors.push(`Option ${i + 1} has invalid 'optionText'`);
      });
    }
  }
  if (!Array.isArray(data.correctOptionIds) || data.correctOptionIds.length === 0)
    errors.push("Missing or invalid 'correctOptionIds' array");
  else {
    if (data.type === 'true_false') {
      if (
        data.correctOptionIds.length !== 1 ||
        (data.correctOptionIds[0] !== 'true' && data.correctOptionIds[0] !== 'false')
      ) {
        errors.push(
          `For 'true_false' type, correctOptionIds must be an array with a single string: 'true' or 'false'.`,
        );
      }
    }
    // Further validation for correctOptionIds matching actual optionIds can be added if needed for MCQs
  }
  return { isValid: errors.length === 0, errors };
}

export function normalizeSingleQuestion(data: QuizQuestion): QuizQuestion {
  return {
    ...data,
    type: data.type || 'mcq', // Default to 'mcq' if type is missing
    status: data.status || 'not_attempted',
    timesAnsweredCorrectly: data.timesAnsweredCorrectly || 0,
    timesAnsweredIncorrectly: data.timesAnsweredIncorrectly || 0,
    historyOfIncorrectSelections: data.historyOfIncorrectSelections || [],
    lastSelectedOptionId: data.lastSelectedOptionId || undefined,
    lastAttemptedAt: data.lastAttemptedAt || undefined,
    srsLevel: data.srsLevel || 0,
    nextReviewAt: data.nextReviewAt || null,
    shownIncorrectOptionIds: data.shownIncorrectOptionIds || [],
  };
}

export function normalizeQuizModule(data: any): QuizModule {
  const normalizedChapters = data.chapters.map((chapter: any) => {
    const normalizedQuestions = chapter.questions.map(normalizeSingleQuestion); // Use normalizeSingleQuestion
    const totalQuestions = normalizedQuestions.length;
    const answeredQuestions = normalizedQuestions.filter(
      (q: QuizQuestion) => q.status !== 'not_attempted',
    ).length;
    const correctAnswers = normalizedQuestions.filter(
      (q: QuizQuestion) => (q.timesAnsweredCorrectly || 0) > 0,
    ).length;
    return {
      ...chapter,
      questions: normalizedQuestions,
      totalQuestions,
      answeredQuestions,
      correctAnswers,
      isCompleted: answeredQuestions === totalQuestions,
    };
  });
  return { ...data, chapters: normalizedChapters };
}

export function recalculateChapterStats(chapter: QuizChapter) {
  chapter.totalQuestions = chapter.questions.length;
  chapter.answeredQuestions = chapter.questions.filter((q) => q.status !== 'not_attempted').length;
  chapter.correctAnswers = chapter.questions.filter(
    (q) => (q.timesAnsweredCorrectly || 0) > 0,
  ).length;
  chapter.isCompleted = chapter.answeredQuestions === chapter.totalQuestions;
}

// --- Refactored Markdown Parser ---

interface MarkdownParseResult {
  success: boolean;
  quizModule?: QuizModule;
  errors: string[];
}

// Helper to manage current line index as a mutable reference
interface LineIndexRef {
  value: number;
}

/**
 * Helper function to parse block content (question text, option text, explanation).
 * Reads lines until a stopper keyword is encountered or EOF.
 * Handles Markdown code blocks (```) correctly, ignoring stoppers within them.
 * @param lines - Array of all lines in the document.
 * @param lineIndexRef - Mutable reference to the current line index.
 * @param stopperKeywords - Array of keywords that signify the end of this block.
 * @returns The parsed block content as a single string.
 */
function parseBlockContent(
  lines: string[],
  lineIndexRef: LineIndexRef,
  stopperKeywords: string[],
): string {
  const contentLines: string[] = [];
  let inCodeBlock = false;
  const codeBlockDelimiter = '```';

  while (lineIndexRef.value < lines.length) {
    const line = lines[lineIndexRef.value];
    const trimmedLine = line.trim();

    if (inCodeBlock) {
      contentLines.push(line); // Add raw line
      lineIndexRef.value++;
      if (trimmedLine === codeBlockDelimiter) {
        inCodeBlock = false;
      }
      continue;
    }

    // Check for code block start (``` or ```lang)
    if (trimmedLine.startsWith(codeBlockDelimiter)) {
      inCodeBlock = true;
      contentLines.push(line);
      lineIndexRef.value++;
      continue;
    }

    // Check for stoppers only if not in code block
    for (const stopper of stopperKeywords) {
      // Exact match for "---" or startsWith for others
      const isStopperMatch =
        (stopper === '---' && trimmedLine === stopper) ||
        (stopper !== '---' && trimmedLine.startsWith(stopper));
      if (isStopperMatch) {
        return contentLines.join('\n'); // Return content *before* stopper line
      }
    }

    contentLines.push(line);
    lineIndexRef.value++;
  }
  return contentLines.join('\n'); // Return all remaining content if no stopper found
}

function skipEmptyLines(lines: string[], lineIndexRef: LineIndexRef): void {
  while (lineIndexRef.value < lines.length && lines[lineIndexRef.value].trim() === '') {
    lineIndexRef.value++;
  }
}

function peekLine(lines: string[], lineIndexRef: LineIndexRef): string | null {
  return lineIndexRef.value < lines.length ? lines[lineIndexRef.value] : null;
}

function consumeLine(lines: string[], lineIndexRef: LineIndexRef): string | null {
  return lineIndexRef.value < lines.length ? lines[lineIndexRef.value++] : null;
}

function cleanText(text: string | null): string {
  return text ? text.replace(/\r/g, '').trim() : '';
}

function extractIdFromComment(line: string): string | null {
  // Regex to capture ID: <!-- ID: any_non_space_char_non_greedy -->
  // Allows hyphens and other characters in IDs.
  const match = line.match(/<!--\s*(?:Q_ID|CH_ID|ID):\s*(\S+?)\s*-->/);
  return match ? match[1] : null;
}

/**
 * Attempts to recover from a parsing error by skipping lines until a potential
 * start of a new chapter (##) or question (### Q: or ### T/F:) or a separator (---) is found.
 * @param lines - Array of all lines in the document.
 * @param lineIndexRef - Mutable reference to the current line index.
 */
function recoverAndSkipToNextEntry(lines: string[], lineIndexRef: LineIndexRef): void {
  const initialErrorLine = lineIndexRef.value + 1;
  console.warn(
    `[Parser Recovery] Attempting to recover from error near line ${initialErrorLine}. Skipping lines...`,
  );
  while (lineIndexRef.value < lines.length) {
    const line = lines[lineIndexRef.value];
    const trimmedLine = line.trim();
    // Check for common entry points or separators
    if (
      trimmedLine.startsWith('### Q:') ||
      trimmedLine.startsWith('### T/F:') || // Added T/F for recovery
      trimmedLine.startsWith('## ') ||
      trimmedLine === '---'
    ) {
      console.warn(
        `[Parser Recovery] Found next potential entry at line ${lineIndexRef.value + 1}: "${line.substring(0, 50)}..."`,
      );
      return; // Stop *before* this potential next entry, so main loop can process it
    }
    lineIndexRef.value++;
  }
  console.warn(
    `[Parser Recovery] Reached end of file while recovering from line ${initialErrorLine}.`,
  );
}

/**
 * Parses a Markdown file formatted according to the MCQ Quiz specification
 * and converts it to a QuizModule structure.
 * This refactored version includes robust block content parsing,
 * granular error recovery, strict ID uniqueness checks, and support for True/False questions.
 */
export function parseMarkdownToQuizModule(markdownContent: string): MarkdownParseResult {
  console.log('=== Starting Refactored Markdown Quiz Parsing (with T/F support) ===');

  const errors: string[] = [];
  const seenChapterIds = new Set<string>();
  const seenQuestionIds = new Set<string>();

  const normalizedContent = markdownContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const lines = normalizedContent.split('\n');
  const lineIndexRef: LineIndexRef = { value: 0 };

  let moduleName = 'Untitled Quiz Module';
  let moduleDescription = '';

  // --- Parse Module Header ---
  skipEmptyLines(lines, lineIndexRef);
  let currentLine = peekLine(lines, lineIndexRef);
  if (currentLine && currentLine.startsWith('# ')) {
    moduleName = cleanText(consumeLine(lines, lineIndexRef)!.substring(2));
    currentLine = peekLine(lines, lineIndexRef);
    if (currentLine && currentLine.startsWith('Description:')) {
      moduleDescription = cleanText(consumeLine(lines, lineIndexRef)!.substring(12));
    } else if (
      currentLine &&
      currentLine.startsWith('_') &&
      currentLine.endsWith('_') &&
      currentLine.length > 2
    ) {
      moduleDescription = cleanText(consumeLine(lines, lineIndexRef)!.slice(1, -1));
    }
    skipEmptyLines(lines, lineIndexRef);
    currentLine = peekLine(lines, lineIndexRef);
    if (currentLine === '---') {
      consumeLine(lines, lineIndexRef);
    } else {
      errors.push(
        "[Warning] Expected '---' separator after module header, not found. Parsing continues.",
      );
    }
  } else {
    errors.push(
      "[Error] Markdown must start with a module title (e.g., '# Module Title'). Cannot parse.",
    );
    return { success: false, errors };
  }

  const chapters: QuizChapter[] = [];

  // --- Parse Chapters ---
  while (lineIndexRef.value < lines.length) {
    skipEmptyLines(lines, lineIndexRef);
    currentLine = peekLine(lines, lineIndexRef);
    if (!currentLine) break;

    if (!currentLine.startsWith('## ')) {
      const problematicLine = consumeLine(lines, lineIndexRef);
      errors.push(
        `[Warning] Unexpected content found outside of a chapter structure near line ${lineIndexRef.value}: "${problematicLine?.substring(0, 70)}...". Attempting to find next chapter.`,
      );
      continue;
    }

    const chapterHeaderLine = consumeLine(lines, lineIndexRef)!;
    const chapterName = cleanText(chapterHeaderLine.substring(3).replace(/<!--.*?-->/g, ''));
    let chapterId = extractIdFromComment(chapterHeaderLine);

    if (!chapterId) {
      currentLine = peekLine(lines, lineIndexRef);
      if (currentLine && currentLine.trim().startsWith('<!--')) {
        chapterId = extractIdFromComment(currentLine);
        if (chapterId) consumeLine(lines, lineIndexRef);
      }
    }
    if (!chapterId) {
      chapterId = `chapter_${chapters.length + 1}_${Date.now()}`;
      errors.push(
        `[Warning] Chapter "${chapterName.substring(0, 30)}..." is missing an ID. Generated default: ${chapterId}`,
      );
    }

    if (seenChapterIds.has(chapterId)) {
      errors.push(
        `[Warning] Duplicate Chapter ID found: '${chapterId}'. This may cause issues. Chapter name: "${chapterName.substring(0, 30)}..."`,
      );
    } else {
      seenChapterIds.add(chapterId);
    }

    let chapterDescription = '';
    currentLine = peekLine(lines, lineIndexRef);
    if (currentLine && currentLine.startsWith('Description:')) {
      chapterDescription = cleanText(consumeLine(lines, lineIndexRef)!.substring(12));
    } else if (
      currentLine &&
      currentLine.startsWith('_') &&
      currentLine.endsWith('_') &&
      currentLine.length > 2
    ) {
      chapterDescription = cleanText(consumeLine(lines, lineIndexRef)!.slice(1, -1));
    }

    skipEmptyLines(lines, lineIndexRef);
    currentLine = peekLine(lines, lineIndexRef);
    if (currentLine === '---') {
      consumeLine(lines, lineIndexRef);
    } else {
      errors.push(
        `[Warning] Expected '---' separator after chapter header (ID: ${chapterId}), not found. Parsing continues.`,
      );
    }

    const questions: QuizQuestion[] = [];
    let questionCounterInChapter = 0;

    // --- Parse Questions in Chapter ---
    while (lineIndexRef.value < lines.length) {
      skipEmptyLines(lines, lineIndexRef);
      const questionParseStartLine = lineIndexRef.value;
      currentLine = peekLine(lines, lineIndexRef);

      if (!currentLine || currentLine.startsWith('## ')) {
        break; // End of chapter or start of next
      }

      const isMcq = currentLine.startsWith('### Q:');
      const isTrueFalse = currentLine.startsWith('### T/F:');

      if (!isMcq && !isTrueFalse) {
        const problematicLine = consumeLine(lines, lineIndexRef);
        errors.push(
          `[Warning] Chapter (ID: ${chapterId}): Unexpected content found instead of a question near line ${lineIndexRef.value}: "${problematicLine?.substring(0, 70)}...". Skipping to find next question or chapter.`,
        );
        recoverAndSkipToNextEntry(lines, lineIndexRef);
        continue;
      }

      try {
        questionCounterInChapter++;
        const questionHeaderLine = consumeLine(lines, lineIndexRef)!;
        let questionId = extractIdFromComment(questionHeaderLine);
        const headerTextStartIndex = isTrueFalse ? 8 : 7; // "### T/F: " is 8 chars, "### Q: " is 7
        const rawQuestionHeaderText = cleanText(
          questionHeaderLine.substring(headerTextStartIndex).replace(/<!--.*?-->/g, ''),
        );

        if (!questionId) {
          currentLine = peekLine(lines, lineIndexRef);
          if (currentLine && currentLine.trim().startsWith('<!--')) {
            questionId = extractIdFromComment(currentLine);
            if (questionId) consumeLine(lines, lineIndexRef);
          }
        }
        if (!questionId) {
          questionId = `${chapterId}_q${questionCounterInChapter}_${Date.now()}`; // Generic 'q' prefix, type field will differentiate
          errors.push(
            `[Warning] Question in chapter ${chapterId} (starting with "${rawQuestionHeaderText.substring(0, 30)}...") is missing an ID. Generated default: ${questionId}`,
          );
        }

        if (seenQuestionIds.has(questionId)) {
          errors.push(
            `[Warning] Duplicate Question ID found: '${questionId}'. This may cause issues. Question text starts with: "${rawQuestionHeaderText.substring(0, 30)}..."`,
          );
        } else {
          seenQuestionIds.add(questionId);
        }

        let questionText: string;
        let options: QuizOption[] = [];
        let correctOptionIds: string[] = [];
        let explanationText: string;
        const questionType: 'mcq' | 'true_false' = isTrueFalse ? 'true_false' : 'mcq';

        // Stoppers for explanation text, common for both types
        const explanationStoppers = ['### Q:', '### T/F:', '## ', '---'];

        if (isTrueFalse) {
          // --- True/False Question Parsing ---
          const questionTextContent = parseBlockContent(lines, lineIndexRef, [
            '**Correct:**',
            '**Ans:**',
          ]);
          questionText = cleanText(
            rawQuestionHeaderText + (questionTextContent ? '\n' + questionTextContent : ''),
          );
          if (!questionText) {
            throw new Error('T/F Question text is empty.');
          }

          skipEmptyLines(lines, lineIndexRef);
          currentLine = peekLine(lines, lineIndexRef);
          // CRITICAL VALIDATION: T/F questions must not have an Options block
          if (
            currentLine &&
            (currentLine.trim() === '**Options:**' || currentLine.trim() === '**Opt:**')
          ) {
            throw new Error("T/F questions cannot have an 'Options:' or 'Opt:' block.");
          }

          options = [
            { optionId: 'true', optionText: 'True' },
            { optionId: 'false', optionText: 'False' },
          ];

          currentLine = consumeLine(lines, lineIndexRef); // Consume the line that should be Correct/Ans
          if (
            !currentLine ||
            !(currentLine.startsWith('**Correct:**') || currentLine.startsWith('**Ans:**'))
          ) {
            throw new Error(
              `Expected '**Correct:**' or '**Ans:**' for T/F question ${questionId}, found: "${currentLine || 'EOF'}"`,
            );
          }

          const correctAnswerText = (
            currentLine.startsWith('**Correct:**')
              ? currentLine.substring(10)
              : currentLine.substring(8)
          )
            .trim()
            .toLowerCase();

          if (correctAnswerText !== 'true' && correctAnswerText !== 'false') {
            throw new Error(
              `The answer for T/F question ${questionId} must be 'True' or 'False'. Found: '${correctAnswerText}'`,
            );
          }
          correctOptionIds = [correctAnswerText];

          skipEmptyLines(lines, lineIndexRef);
          currentLine = consumeLine(lines, lineIndexRef);
          if (!currentLine || currentLine.trim() !== '**Exp:**') {
            throw new Error(
              `Expected '**Exp:**' for T/F question ${questionId}, found: "${currentLine || 'EOF'}"`,
            );
          }
          const explanationTextContent = parseBlockContent(
            lines,
            lineIndexRef,
            explanationStoppers,
          );
          explanationText = cleanText(explanationTextContent);
          if (!explanationText) {
            throw new Error(`Explanation text is empty for T/F question ${questionId}.`);
          }
        } else {
          // --- MCQ Question Parsing (existing logic, slightly adapted) ---
          const questionTextContent = parseBlockContent(lines, lineIndexRef, [
            '**Options:**',
            '**Opt:**',
          ]);
          questionText = cleanText(
            rawQuestionHeaderText + (questionTextContent ? '\n' + questionTextContent : ''),
          );
          if (!questionText) {
            throw new Error('MCQ Question text is empty.');
          }

          skipEmptyLines(lines, lineIndexRef);
          currentLine = consumeLine(lines, lineIndexRef);
          if (
            !currentLine ||
            !(currentLine.trim() === '**Options:**' || currentLine.trim() === '**Opt:**')
          ) {
            throw new Error(
              `Expected '**Options:**' or '**Opt:**' for MCQ question ${questionId}, found: "${currentLine || 'EOF'}"`,
            );
          }

          const optionLabelToIdMap: Record<string, string> = {};
          let optionCounter = 1;
          while (lineIndexRef.value < lines.length) {
            skipEmptyLines(lines, lineIndexRef);
            currentLine = peekLine(lines, lineIndexRef);
            if (!currentLine) break;

            const optionLineTrimmed = currentLine.trim();
            if (
              optionLineTrimmed.startsWith('**Correct:**') ||
              optionLineTrimmed.startsWith('**Ans:**') ||
              optionLineTrimmed.startsWith('**Exp:**')
            ) {
              break;
            }

            const optionMatch =
              optionLineTrimmed.match(/^\*\*A(\d+):\*\*(.*)$/) ||
              optionLineTrimmed.match(/^-\s*\*\*A(\d+):\*\*(.*)$/);
            if (!optionMatch) {
              if (optionLineTrimmed !== '') {
                errors.push(
                  `[Warning] MCQ Question ID ${questionId}: Unexpected line while parsing options: "${currentLine.substring(0, 50)}...". Attempting to continue.`,
                );
              }
              break;
            }

            consumeLine(lines, lineIndexRef);
            const optionLabel = `A${optionMatch[1]}`;
            const parsedOptionId = `${questionId}_opt${optionCounter++}`;
            const firstLineOptionText = cleanText(
              optionMatch[optionMatch[0].startsWith('-') ? 2 : 2],
            );

            const remainingOptionTextContent = parseBlockContent(lines, lineIndexRef, [
              '**A',
              '- **A',
              '**Correct:**',
              '**Ans:**',
              '**Exp:**',
              ...explanationStoppers, // Include general stoppers
            ]);
            const currentOptionText = cleanText(
              firstLineOptionText +
                (remainingOptionTextContent ? '\n' + remainingOptionTextContent : ''),
            );
            if (!currentOptionText) {
              errors.push(
                `[Warning] MCQ Question ID ${questionId}, Option ${optionLabel}: Option text is empty.`,
              );
            }
            options.push({
              optionId: parsedOptionId,
              optionText: currentOptionText,
            });
            optionLabelToIdMap[optionLabel] = parsedOptionId;
          }
          if (options.length === 0) {
            throw new Error(`No options found for MCQ question ${questionId}.`);
          }

          skipEmptyLines(lines, lineIndexRef);
          currentLine = consumeLine(lines, lineIndexRef);
          if (
            !currentLine ||
            !(currentLine.startsWith('**Correct:**') || currentLine.startsWith('**Ans:**'))
          ) {
            throw new Error(
              `Expected '**Correct:**' or '**Ans:**' for MCQ question ${questionId}, found: "${currentLine || 'EOF'}"`,
            );
          }
          const correctSectionContent = currentLine.startsWith('**Correct:**')
            ? currentLine.substring(10)
            : currentLine.substring(8);
          const correctLabels = correctSectionContent
            .trim()
            .split(',')
            .map((l) => l.trim())
            .filter((l) => l.length > 0);
          correctOptionIds = correctLabels
            .map((label) => {
              const id = optionLabelToIdMap[label];
              if (!id)
                errors.push(
                  `[Warning] MCQ Question ID ${questionId}: Correct answer label '${label}' does not match any parsed option label.`,
                );
              return id;
            })
            .filter(Boolean) as string[];
          if (correctOptionIds.length === 0) {
            throw new Error(
              `No valid correct answer IDs derived for MCQ question ${questionId}. Parsed labels: ${correctLabels.join(', ')}`,
            );
          }

          skipEmptyLines(lines, lineIndexRef);
          currentLine = consumeLine(lines, lineIndexRef);
          if (!currentLine || currentLine.trim() !== '**Exp:**') {
            throw new Error(
              `Expected '**Exp:**' for MCQ question ${questionId}, found: "${currentLine || 'EOF'}"`,
            );
          }
          const explanationTextContent = parseBlockContent(
            lines,
            lineIndexRef,
            explanationStoppers,
          );
          explanationText = cleanText(explanationTextContent);
          if (!explanationText) {
            throw new Error(`Explanation text is empty for MCQ question ${questionId}.`);
          }
        } // End of MCQ specific parsing

        questions.push(
          normalizeSingleQuestion({
            questionId,
            type: questionType,
            questionText,
            options,
            correctOptionIds,
            explanationText,
            status: 'not_attempted',
            timesAnsweredCorrectly: 0,
            timesAnsweredIncorrectly: 0,
            historyOfIncorrectSelections: [],
            srsLevel: 0,
            nextReviewAt: null,
            shownIncorrectOptionIds: [],
          }),
        );

        skipEmptyLines(lines, lineIndexRef);
        currentLine = peekLine(lines, lineIndexRef);
        if (currentLine === '---') {
          consumeLine(lines, lineIndexRef);
        }
      } catch (e) {
        const errorMsg = `[Error] Failed to parse question starting near line ${questionParseStartLine + 1} in Chapter ID ${chapterId}: ${(e as Error).message}. This question will be skipped.`;
        errors.push(errorMsg);
        console.error(errorMsg, e);
        recoverAndSkipToNextEntry(lines, lineIndexRef);
      }
    } // End of questions loop for a chapter

    const chapterObj: QuizChapter = {
      id: chapterId,
      name: chapterName,
      description: chapterDescription,
      questions,
      totalQuestions: 0,
      answeredQuestions: 0,
      correctAnswers: 0,
      isCompleted: false,
    };
    recalculateChapterStats(chapterObj);
    chapters.push(chapterObj);
    console.log(
      `Successfully parsed chapter: ${chapterName} (ID: ${chapterId}) with ${questions.length} questions.`,
    );
  } // End of chapters loop

  if (chapters.length === 0 && errors.filter((e) => e.startsWith('[Error]')).length === 0) {
    errors.push('[Warning] No valid chapters found in the Markdown file after module header.');
  }

  const quizModule: QuizModule = {
    name: moduleName,
    description: moduleDescription,
    chapters,
  };

  const finalValidation = validateQuizModule(quizModule);
  if (!finalValidation.isValid) {
    errors.push(...finalValidation.errors.map((e) => `[Post-Validation Error] ${e}`));
  }

  console.log(`=== Markdown Parsing Complete ===`);
  console.log(`Total errors/warnings: ${errors.length}`);
  errors.forEach((err) => console.log(err));

  return {
    success: errors.filter((e) => e.startsWith('[Error]')).length === 0,
    quizModule: normalizeQuizModule(quizModule),
    errors,
  };
}


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: utils\quiz-validation\index.ts
SIZE: 1,165 bytes | LINES: 29
================================================================================
/**
 * Quiz Validation API
 *
 * This module provides the quiz parsing and validation functionality.
 *
 * Features:
 * - Enhanced markdown parsing with True/False support
 * - Conservative LaTeX correction
 * - Better error handling and recovery
 * - Global ID uniqueness validation
 */

// Re-export types
export type { ValidationResult } from '../quiz-validation-refactored';
export type { QuizModule, QuizChapter, QuizQuestion, QuizOption } from '@/types/quiz-types';

// Import the refactored implementation
import * as parser from '../quiz-validation-refactored';

// Re-export the stable API
export const parseMarkdownToQuizModule = parser.parseMarkdownToQuizModule;
export const validateAndCorrectQuizModule = parser.validateAndCorrectQuizModule;
export const normalizeQuizModule = parser.normalizeQuizModule;
export const validateQuizModule = parser.validateQuizModule;
export const validateSingleQuestion = parser.validateSingleQuestion;
export const normalizeSingleQuestion = parser.normalizeSingleQuestion;
export const recalculateChapterStats = parser.recalculateChapterStats;
export const correctLatexInJsonContent = parser.correctLatexInJsonContent;


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: vitest.config.accessibility.ts
SIZE: 398 bytes | LINES: 19
================================================================================
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    include: ['tests/access/**/*.test.{ts,tsx}'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
});


────────────────────────────────────────────────────────────────────────────────

================================================================================
FILE: vitest.config.integration.ts
SIZE: 395 bytes | LINES: 19
================================================================================
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    include: ['tests/int/**/*.test.{ts,tsx}'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
});


────────────────────────────────────────────────────────────────────────────────

====================================================================================================
EXTRACTION SUMMARY
====================================================================================================
Total Files Processed: 143
Extraction Date: 2025-09-24 17:16:01
Output File: COMPLETE_CODEBASE.txt

File Types Included:
  .css: 1 files
  .js: 1 files
  .json: 10 files
  .md: 13 files
  .mjs: 3 files
  .ts: 24 files
  .tsx: 91 files


This file contains the complete codebase for the Quiz-SRS application,
including all source code, configuration files, and documentation.
====================================================================================================
